{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"00_intro/","text":"Introduction \u2693\ufe0e Objectifs \u2693\ufe0e Le 1er objectif est de d\u00e9couvrir quel est le r\u00f4le d'un OS afin de pouvoir coder des programmes utilisant des processus / threads . Cela permettra de parall\u00e9liser des actions dans nos futurs programmes. Aussi, nous verrons de mani\u00e8re simplifi\u00e9e comment sont ordonnanc\u00e9s les processus, puis comment sont organis\u00e9s les fichiers. D\u00e9finition \u2693\ufe0e Un OS est la couche logicielle qui permet et coordonne l\u2019utilisation du mat\u00e9riel entre les diff\u00e9rents programmes d\u2019applications. Tip C'est donc le lien entre l'homme et le hardware ! On parle d' IHM - Interface Homme Machine Example Quelques exemples d'OS : - Unix based : Linux, Mac, Android, iOS ... - Windows : XP, Vista, 7, 10 ... On peut voir l'OS de deux points de vues diff\u00e9rents : Utilisateur Lambda : Une IHM Un d\u00e9veloppeur : Un ensemble d'appels syst\u00e8mes Fonctions d'un OS \u2693\ufe0e Offrir une interface de programmation & interpr\u00e9teur de commandes \u2693\ufe0e Un IDE, Une Command Line etc ... Offrir une interface op\u00e9rateur conviviale \u2693\ufe0e Pour les non programmeurs. Ceci n'est pas obligatoire ;) Optimiser l\u2019utilisation des \u00e9l\u00e9ments du syst\u00e8me informatique : \u2693\ufe0e Gestion du processeur \u2693\ufe0e Le syst\u00e8me doit g\u00e9rer l'allocation du processeur aux diff\u00e9rents programmes pouvant s'ex\u00e9cuter (les processus). Cette allocation se fait par le biais d'un algorithme d'ordonnancement qui planifie l'ex\u00e9cution des programmes. Selon le type de syst\u00e8me d'exploitation, l'algorithme d'ordonnancement r\u00e9pond \u00e0 des objectifs diff\u00e9rents (Ex. Syst\u00e8mes Temps R\u00e9el) 1 D\u00e9finition d'un Processus Processus = programme en cours d'ex\u00e9cution. 1 Processus poss\u00e8de trois \u00e9l\u00e9ments : programme ex\u00e9cutable donn\u00e9es associ\u00e9es au programme contexte d\u2019ex\u00e9cution du programme Gestion de la concurrence \u2693\ufe0e Comme plusieurs programmes coexistent en RAM, ceux-ci peuvent vouloir communiquer pour \u00e9changer des donn\u00e9es. Par ailleurs, il faut synchroniser l'acc\u00e8s aux donn\u00e9es partag\u00e9es afin de maintenir leur coh\u00e9rence. Le syst\u00e8me offre des outils de communication et de synchronisation entre programmes. Gestion de la m\u00e9moire \u2693\ufe0e Le syst\u00e8me doit g\u00e9rer l'allocation de la RAM entre les diff\u00e9rents programmes pouvant s'ex\u00e9cuter. Comme la m\u00e9moire physique est souvent trop petite pour contenir la totalit\u00e9 des programmes, la gestion de la m\u00e9moire se fait selon le principe de la m\u00e9moire virtuelle. A un instant donn\u00e9, seules sont charg\u00e9es en RAM les parties de code et donn\u00e9es utiles \u00e0 l'ex\u00e9cution. Ainsi, chacun des processus acc\u00e8de \u00e0 toute la m\u00e9moire \u00e0 un instant T. A cela on ajoute le m\u00e9canisme de SWAP qui permet de d\u00e9sengorger le syst\u00e8me en d\u00e9pla\u00e7ant des modules \u00e9xecutables sur la m\u00e9moire secondaire (le HDD). C'est plus lent, mais au moins le syst\u00e8me continue de fonctionner ! Gestion des entr\u00e9es/sorties \u2693\ufe0e Le syst\u00e8me doit g\u00e9rer l'acc\u00e8s aux p\u00e9riph\u00e9riques, c'est-\u00e0-dire faire la liaison entre les appels de haut niveau des programmes utilisateurs (exemple getchar()) et les op\u00e9rations de bas niveau de l\u2018unit\u00e9 d\u2019ex\u00e9cution responsable du p\u00e9riph\u00e9rique (UE clavier) C'est le pilote d'entr\u00e9es/sorties (driver) qui assure cette correspondance. Gestion des objets externes \u2693\ufe0e La m\u00e9moire centrale est une m\u00e9moire volatile (RAM). Aussi, toutes les donn\u00e9es devant \u00eatre conserv\u00e9es au-del\u00e0 de l'arr\u00eat de la machine, doivent \u00eatre stock\u00e9es sur une m\u00e9moire de masse ( disque dur ). Gestion de l\u2019acc\u00e8s au r\u00e9seau \u2693\ufe0e Le syst\u00e8me doit permettre \u00e0 des ex\u00e9cutions de programmes, plac\u00e9es sur des machines distinctes, de communiquer. Le syst\u00e8me offre des outils de type socket pour acc\u00e9der \u00e0 la couche de protocoles de communication. Gestion de la protection \u2693\ufe0e Le syst\u00e8me doit fournir des m\u00e9canismes garantissant que ses ressources (CPU, m\u00e9moire, fichiers,\u2026) ne peuvent \u00eatre utilis\u00e9es que par les programmes auxquels les droits n\u00e9cessaires ont \u00e9t\u00e9 accord\u00e9s. Syst\u00e8mes TR : Les programmes en ex\u00e9cution sont soumis \u00e0 des contraintes de temps fortes, c'est-\u00e0-dire que leurs ex\u00e9cutions doivent \u00eatre imp\u00e9rativement achev\u00e9es \u00e0 une date butoir appel\u00e9e \u00e9ch\u00e9ance (Robotique / S\u00e9curit\u00e9 / D\u00e9fense) \u21a9","title":"Introduction"},{"location":"00_intro/#introduction","text":"","title":"Introduction"},{"location":"00_intro/#objectifs","text":"Le 1er objectif est de d\u00e9couvrir quel est le r\u00f4le d'un OS afin de pouvoir coder des programmes utilisant des processus / threads . Cela permettra de parall\u00e9liser des actions dans nos futurs programmes. Aussi, nous verrons de mani\u00e8re simplifi\u00e9e comment sont ordonnanc\u00e9s les processus, puis comment sont organis\u00e9s les fichiers.","title":"Objectifs"},{"location":"00_intro/#definition","text":"Un OS est la couche logicielle qui permet et coordonne l\u2019utilisation du mat\u00e9riel entre les diff\u00e9rents programmes d\u2019applications. Tip C'est donc le lien entre l'homme et le hardware ! On parle d' IHM - Interface Homme Machine Example Quelques exemples d'OS : - Unix based : Linux, Mac, Android, iOS ... - Windows : XP, Vista, 7, 10 ... On peut voir l'OS de deux points de vues diff\u00e9rents : Utilisateur Lambda : Une IHM Un d\u00e9veloppeur : Un ensemble d'appels syst\u00e8mes","title":"D\u00e9finition"},{"location":"00_intro/#fonctions-dun-os","text":"","title":"Fonctions d'un OS"},{"location":"00_intro/#offrir-une-interface-de-programmation-interpreteur-de-commandes","text":"Un IDE, Une Command Line etc ...","title":"Offrir une interface de programmation &amp; interpr\u00e9teur de commandes"},{"location":"00_intro/#offrir-une-interface-operateur-conviviale","text":"Pour les non programmeurs. Ceci n'est pas obligatoire ;)","title":"Offrir une interface op\u00e9rateur conviviale"},{"location":"00_intro/#optimiser-lutilisation-des-elements-du-systeme-informatique","text":"","title":"Optimiser l\u2019utilisation des \u00e9l\u00e9ments du syst\u00e8me informatique :"},{"location":"00_intro/#gestion-du-processeur","text":"Le syst\u00e8me doit g\u00e9rer l'allocation du processeur aux diff\u00e9rents programmes pouvant s'ex\u00e9cuter (les processus). Cette allocation se fait par le biais d'un algorithme d'ordonnancement qui planifie l'ex\u00e9cution des programmes. Selon le type de syst\u00e8me d'exploitation, l'algorithme d'ordonnancement r\u00e9pond \u00e0 des objectifs diff\u00e9rents (Ex. Syst\u00e8mes Temps R\u00e9el) 1 D\u00e9finition d'un Processus Processus = programme en cours d'ex\u00e9cution. 1 Processus poss\u00e8de trois \u00e9l\u00e9ments : programme ex\u00e9cutable donn\u00e9es associ\u00e9es au programme contexte d\u2019ex\u00e9cution du programme","title":"Gestion du processeur"},{"location":"00_intro/#gestion-de-la-concurrence","text":"Comme plusieurs programmes coexistent en RAM, ceux-ci peuvent vouloir communiquer pour \u00e9changer des donn\u00e9es. Par ailleurs, il faut synchroniser l'acc\u00e8s aux donn\u00e9es partag\u00e9es afin de maintenir leur coh\u00e9rence. Le syst\u00e8me offre des outils de communication et de synchronisation entre programmes.","title":"Gestion de la concurrence"},{"location":"00_intro/#gestion-de-la-memoire","text":"Le syst\u00e8me doit g\u00e9rer l'allocation de la RAM entre les diff\u00e9rents programmes pouvant s'ex\u00e9cuter. Comme la m\u00e9moire physique est souvent trop petite pour contenir la totalit\u00e9 des programmes, la gestion de la m\u00e9moire se fait selon le principe de la m\u00e9moire virtuelle. A un instant donn\u00e9, seules sont charg\u00e9es en RAM les parties de code et donn\u00e9es utiles \u00e0 l'ex\u00e9cution. Ainsi, chacun des processus acc\u00e8de \u00e0 toute la m\u00e9moire \u00e0 un instant T. A cela on ajoute le m\u00e9canisme de SWAP qui permet de d\u00e9sengorger le syst\u00e8me en d\u00e9pla\u00e7ant des modules \u00e9xecutables sur la m\u00e9moire secondaire (le HDD). C'est plus lent, mais au moins le syst\u00e8me continue de fonctionner !","title":"Gestion de la m\u00e9moire"},{"location":"00_intro/#gestion-des-entreessorties","text":"Le syst\u00e8me doit g\u00e9rer l'acc\u00e8s aux p\u00e9riph\u00e9riques, c'est-\u00e0-dire faire la liaison entre les appels de haut niveau des programmes utilisateurs (exemple getchar()) et les op\u00e9rations de bas niveau de l\u2018unit\u00e9 d\u2019ex\u00e9cution responsable du p\u00e9riph\u00e9rique (UE clavier) C'est le pilote d'entr\u00e9es/sorties (driver) qui assure cette correspondance.","title":"Gestion des entr\u00e9es/sorties"},{"location":"00_intro/#gestion-des-objets-externes","text":"La m\u00e9moire centrale est une m\u00e9moire volatile (RAM). Aussi, toutes les donn\u00e9es devant \u00eatre conserv\u00e9es au-del\u00e0 de l'arr\u00eat de la machine, doivent \u00eatre stock\u00e9es sur une m\u00e9moire de masse ( disque dur ).","title":"Gestion des objets externes"},{"location":"00_intro/#gestion-de-lacces-au-reseau","text":"Le syst\u00e8me doit permettre \u00e0 des ex\u00e9cutions de programmes, plac\u00e9es sur des machines distinctes, de communiquer. Le syst\u00e8me offre des outils de type socket pour acc\u00e9der \u00e0 la couche de protocoles de communication.","title":"Gestion de l\u2019acc\u00e8s au r\u00e9seau"},{"location":"00_intro/#gestion-de-la-protection","text":"Le syst\u00e8me doit fournir des m\u00e9canismes garantissant que ses ressources (CPU, m\u00e9moire, fichiers,\u2026) ne peuvent \u00eatre utilis\u00e9es que par les programmes auxquels les droits n\u00e9cessaires ont \u00e9t\u00e9 accord\u00e9s. Syst\u00e8mes TR : Les programmes en ex\u00e9cution sont soumis \u00e0 des contraintes de temps fortes, c'est-\u00e0-dire que leurs ex\u00e9cutions doivent \u00eatre imp\u00e9rativement achev\u00e9es \u00e0 une date butoir appel\u00e9e \u00e9ch\u00e9ance (Robotique / S\u00e9curit\u00e9 / D\u00e9fense) \u21a9","title":"Gestion de la protection"},{"location":"01_history/","text":"Histoire \u2693\ufe0e 1940 : Traitement en S\u00e9rie \u2693\ufe0e Un programmeur \u00e0 la fois, un programme \u00e0 la fois. N\u00e9cessite l'intervention humaine pour changer de programme. 1950 : Traitement par Lots \u2693\ufe0e Introduction d'un programme moniteur , qui surveille les t\u00e2ches en cours et permet d'enchainer automatiquement une liste de taches. Chaque utilisateur soumet ses t\u00e2ches \u00e0 l\u2019op\u00e9rateur de l\u2019ordinateur : cartes perfor\u00e9es, rubans magn\u00e9tiques Il y a un regroupement des t\u00e2ches Puis ex\u00e9cution s\u00e9quentielle des regroupements La fin d\u2019une t\u00e2che est suivie par un branchement vers le moniteur. Le moniteur charge en m\u00e9moire la t\u00e2che suivante et l\u2019ex\u00e9cute dans le processeur L\u2019ordinateur est soit en ex\u00e9cution d\u2019un programme utilisateur soit en ex\u00e9cution du programme moniteur 1950- 1960 : Traitement par Lots Multiprogramm\u00e9s \u2693\ufe0e L'am\u00e9lioration logique consiste \u00e0 ex\u00e9cuter une autre t\u00e2che dans les portions de temps o\u00f9 le processeur est inactif. Ceci exige la coop\u00e9ration du mat\u00e9riel. Apparition des interruptions mat\u00e9rielles & Module de gestion des interruptions : Transfert rapide des donn\u00e9es sans intervention du processeur. Cr\u00e9ation d\u2019un module de Memory Management : maintenir en m\u00e9moire les t\u00e2ches pour l\u2019ex\u00e9cution. Cr\u00e9ation d\u2019un module d\u2019ordonnancement des t\u00e2ches : permet d\u2019avoir plus d\u2019une t\u00e2che en m\u00e9moire, s\u00e9lectionne l\u2019une des t\u00e2ches pour l\u2019ex\u00e9cution. Important ! Traitement par lots = pas d\u2019interactivit\u00e9 ! D\u00e9but 1960 : Traitement en Temps Partag\u00e9 \u2693\ufe0e Une nouvelle technique doit \u00eatre d\u00e9velopp\u00e9e: le CTSS (Compatible Time-Sharing System) de MIT. Blocage / Red\u00e9marrage p\u00e9riodique des t\u00e2ches \u00e0 l\u2019aide d\u2019une interruption cadenc\u00e9e par une source stable (CLK). Chaque utilisateur du syst\u00e8me est reli\u00e9 \u00e0 l\u2019ordinateur par le biais d\u2019un terminal. Utilisateur = terminal = t\u00e2che Important ! Le processeur est contr\u00f4l\u00e9 par chaque terminal durant une br\u00e8ve p\u00e9riode de temps. Ainsi, les t\u00e2ches ont tour \u00e0 tour l\u2019attention du processeur ( round-robin ). Lorsqu\u2019une t\u00e2che est en attente d\u2019une op\u00e9ration E/S : elle est imm\u00e9diatement bloqu\u00e9e le contr\u00f4le du processeur est pass\u00e9 \u00e0 une autre t\u00e2che Multi Programming Temps Partag\u00e9 Objectif Maximiser l'utilisation du processeur Minimiser le Temps de R\u00e9ponse Source des Commandes Job Control Language (JCL) Commandes interactives via le Terminal 1965 ~ : Multi-t\u00e2ches et multi-utilisateur \u2693\ufe0e Success Association du Multi-tache (multi-programmation) + Multi-Utilisateur (temps partag\u00e9) : MULTICS. En ajoutant un Syst\u00e8me de Gestion de Fichiers (SGF) , on a d\u00e9j\u00e0 la structure d'un SE Moderne ! Pour r\u00e9sumer en Vid\u00e9o \u2693\ufe0e","title":"Histoire"},{"location":"01_history/#histoire","text":"","title":"Histoire"},{"location":"01_history/#1940-traitement-en-serie","text":"Un programmeur \u00e0 la fois, un programme \u00e0 la fois. N\u00e9cessite l'intervention humaine pour changer de programme.","title":"1940 : Traitement en S\u00e9rie"},{"location":"01_history/#1950-traitement-par-lots","text":"Introduction d'un programme moniteur , qui surveille les t\u00e2ches en cours et permet d'enchainer automatiquement une liste de taches. Chaque utilisateur soumet ses t\u00e2ches \u00e0 l\u2019op\u00e9rateur de l\u2019ordinateur : cartes perfor\u00e9es, rubans magn\u00e9tiques Il y a un regroupement des t\u00e2ches Puis ex\u00e9cution s\u00e9quentielle des regroupements La fin d\u2019une t\u00e2che est suivie par un branchement vers le moniteur. Le moniteur charge en m\u00e9moire la t\u00e2che suivante et l\u2019ex\u00e9cute dans le processeur L\u2019ordinateur est soit en ex\u00e9cution d\u2019un programme utilisateur soit en ex\u00e9cution du programme moniteur","title":"1950 : Traitement par Lots"},{"location":"01_history/#1950-1960-traitement-par-lots-multiprogrammes","text":"L'am\u00e9lioration logique consiste \u00e0 ex\u00e9cuter une autre t\u00e2che dans les portions de temps o\u00f9 le processeur est inactif. Ceci exige la coop\u00e9ration du mat\u00e9riel. Apparition des interruptions mat\u00e9rielles & Module de gestion des interruptions : Transfert rapide des donn\u00e9es sans intervention du processeur. Cr\u00e9ation d\u2019un module de Memory Management : maintenir en m\u00e9moire les t\u00e2ches pour l\u2019ex\u00e9cution. Cr\u00e9ation d\u2019un module d\u2019ordonnancement des t\u00e2ches : permet d\u2019avoir plus d\u2019une t\u00e2che en m\u00e9moire, s\u00e9lectionne l\u2019une des t\u00e2ches pour l\u2019ex\u00e9cution. Important ! Traitement par lots = pas d\u2019interactivit\u00e9 !","title":"1950- 1960 : Traitement par Lots Multiprogramm\u00e9s"},{"location":"01_history/#debut-1960-traitement-en-temps-partage","text":"Une nouvelle technique doit \u00eatre d\u00e9velopp\u00e9e: le CTSS (Compatible Time-Sharing System) de MIT. Blocage / Red\u00e9marrage p\u00e9riodique des t\u00e2ches \u00e0 l\u2019aide d\u2019une interruption cadenc\u00e9e par une source stable (CLK). Chaque utilisateur du syst\u00e8me est reli\u00e9 \u00e0 l\u2019ordinateur par le biais d\u2019un terminal. Utilisateur = terminal = t\u00e2che Important ! Le processeur est contr\u00f4l\u00e9 par chaque terminal durant une br\u00e8ve p\u00e9riode de temps. Ainsi, les t\u00e2ches ont tour \u00e0 tour l\u2019attention du processeur ( round-robin ). Lorsqu\u2019une t\u00e2che est en attente d\u2019une op\u00e9ration E/S : elle est imm\u00e9diatement bloqu\u00e9e le contr\u00f4le du processeur est pass\u00e9 \u00e0 une autre t\u00e2che Multi Programming Temps Partag\u00e9 Objectif Maximiser l'utilisation du processeur Minimiser le Temps de R\u00e9ponse Source des Commandes Job Control Language (JCL) Commandes interactives via le Terminal","title":"D\u00e9but 1960 : Traitement en Temps Partag\u00e9"},{"location":"01_history/#1965-multi-taches-et-multi-utilisateur","text":"Success Association du Multi-tache (multi-programmation) + Multi-Utilisateur (temps partag\u00e9) : MULTICS. En ajoutant un Syst\u00e8me de Gestion de Fichiers (SGF) , on a d\u00e9j\u00e0 la structure d'un SE Moderne !","title":"1965 ~ : Multi-t\u00e2ches et multi-utilisateur"},{"location":"01_history/#pour-resumer-en-video","text":"","title":"Pour r\u00e9sumer en Vid\u00e9o"},{"location":"02_sgf/","text":"Le Syst\u00e8me de Gestion de Fichiers \u2693\ufe0e Pourquoi ? \u2693\ufe0e On ne peut pas stocker d'informations de mani\u00e8re durable dans la RAM puisqu'elle est volatile, et de taille restreinte. Il faut donc organiser nos donn\u00e9es qui doivent perdurer sur le Disque Dur, afin de pouvoir stocker de gros volumes, de pouvoir les partager etc ... Le SGF d\u00e9finit : organisation coh\u00e9rente de la m\u00e9moire secondaire Notion de fichiers et de r\u00e9pertoires Les sous-r\u00e9pertoires sont des enfants d\u2019un r\u00e9pertoire racine On a donc un hi\u00e9rarchie , o\u00f9 un r\u00e9pertoire peut en contenir d\u2019autres. comment nommer les fichiers (caract\u00e8res interdits, r\u00e9serv\u00e9s, extensions etc ...)? comment les structurer ? comment les utiliser, les prot\u00e9ger ? Important ! Sur un syst\u00e8me UNIX : l'OS g\u00e8re un fichier et un dossier de la m\u00eame mani\u00e8re ! Un dossier est un fichier qui peut en contenir d'autres. Un fichier simple est un fichier qui ne peut pas en contenir d'autres. La distinction ne tient qu'\u00e0 un attribut qui indique que le fichier en question est en fait un dossier. Inodes \u2693\ufe0e Le SGF conserve une liste de tous les fichiers : la table des inodes. Un inode est un n\u0153ud d\u2019information qui contient les attributs d'un fichier (jusqu'\u00e0 40+ sur certains OS !) : type de fichier (fichier simple, r\u00e9pertoire, socket ...) propri\u00e9taire (user, group) permissions compteur de lien : nb de r\u00e9pertoires contenant une entr\u00e9e avec ce num\u00e9ro d\u2019inode marques temporelles (date/heure cr\u00e9ation, date/heure modification) liste de blocs (liste des n\u00b0 de blocs contenant le 1er segment du fichier) ... Important ! Un inode ne contient PAS le nom du fichier. Un fichier simple \u00e9tant forc\u00e9ment dans un fichier de type r\u00e9pertoire, c'est le fichier r\u00e9pertoire qui contient les noms des fichiers qu'il contient ! Cela permet d'avoir une table d'inodes de petites dimension, qui se parcourt rapidement ! Types des fichiers \u2693\ufe0e Tip On peut facilement voir le type d'un fichier en faisant la commande ls -l qui affiche le nom du fichier pr\u00e9c\u00e9d\u00e9 de son type et droits d'acc\u00e8s : 1 2 3 4 5 ls -l l rw-r--r-- 1 jberger 1049089 309 Oct 29 10 :06 monLien -> SE/TP2/src/bonjour.c - rw-r--r-- 1 jberger 1049089 16 Oct 29 10 :36 testRegexp d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP1/ d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP2/ Fichiers normaux : \u2693\ufe0e Utilis\u00e9s par les users Fichiers ASCII : lignes de texte (caract\u00e8re \u00ab fin de ligne \u00bb variable selon les SE) avantage = facilement lisibles et modifiables Fichiers binaires : structur\u00e9s pour que l \u2019on puisse retrouver ses informations. R\u00e9pertoires : \u2693\ufe0e Utilis\u00e9s par les users Fichiers de type particulier qui contiennent une liste d\u2019autres fichiers Lien permanent : \u2693\ufe0e Entr\u00e9e de r\u00e9pertoire normale qui au lieu de pointer vers un fichier unique, pointe sur un fichier d\u00e9j\u00e0 existant. Permets de donner plusieurs noms \u00e0 un fichier, dans des r\u00e9pertoires diff\u00e9rents. Donc de le partager ! Ce fichier ne sera effac\u00e9 que lorsque son dernier nom est supprim\u00e9 (pas d\u2019inode suppl\u00e9mentaire). Lien symbolique : \u2693\ufe0e Ne pointe pas vers un autre inode comme un lien permanent mais vers un autre nom de fichier (inode suppl\u00e9mentaire). Lors d'un parcours automatique de disque, on passera plusieurs fois au m\u00eame endroit de la m\u00e9moire vu qu'il y a une nouvelle inode ... Peut perf ! Diff\u00e9rence en image : Socket : \u2693\ufe0e Moyen de communication avec d\u2019autres machines via le r\u00e9seau. Pipes nomm\u00e9s : \u2693\ufe0e Moyen de communication entre processus d'une m\u00eame machine. Fichiers sp\u00e9ciaux caract\u00e8res : \u2693\ufe0e Offre un m\u00e9canisme de communication avec les pilotes de p\u00e9riph\u00e9riques \u00e0 raison d\u2019un caract\u00e8re \u00e0 la fois. Mod\u00e9lisation d\u2019E/S (terminaux,imprimante ...) (Contenu non gard\u00e9 en m\u00e9moire). Fichiers sp\u00e9ciaux bloc : \u2693\ufe0e Offre un m\u00e9canisme de communication avec les pilotes de p\u00e9riph\u00e9riques, similitude avec les fichiers sp\u00e9ciaux \u00e0 caract\u00e8re, mais avec une quantit\u00e9 de donn\u00e9es plus importante. Mod\u00e9lisation des disques (Contenu gard\u00e9 en m\u00e9moire). Permissions sur les Fichiers \u2693\ufe0e D\u00e9finition des Droits \u2693\ufe0e Un fichier peut appartenir \u00e0 un utilisateur qui lui-m\u00eame fait partie d'un ensemble d'utilisateur ( groupe ) qui ont tous les m\u00eames droits sur une m\u00eame machine. Par exemple, il peut y avoir un groupe \u00e9l\u00e8ves et profs sur une m\u00eame machine et les \u00e9l\u00e8ves connect\u00e9s n'ont pas acc\u00e8s aux fichiers de correction ! On va donc g\u00e9rer les acc\u00e8s pour : Un User Un Groupe d'Users Les Autres Tip On peut facilement voir les droits d'acc\u00e8s \u00e0 un fichier en faisant la commande ls -l 1 2 3 4 5 ls -l l rw-r--r-- 1 jberger 1049089 309 Oct 29 10 :06 monLien -> SE/TP2/src/bonjour.c - rw-r--r-- 1 jberger 1049089 16 Oct 29 10 :36 testRegexp d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP1/ d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP2/ Ici, l'utilisateur jberger en particulier peut lire et \u00e9crire le fichier testRegexp . Les utilisateurs appartenant au groupe 1049089 peuvent uniquement le lire. Idem pour tous les autres utilisateurs. Modification des Droits \u2693\ufe0e Le codage des droits est fait sous forme binaire (en puissances de 2), pour chaque bloc de permissions (user/group/others). Ainsi le codage des droits rwxr-x--- donne 750 : - Droits User : \\(2^2 + 2^1 + 2^0 = 7\\) - Droits Groupe : \\(2^2 + 0 + 2^0 = 5\\) - Droits Autres : \\(0 + 0 + 0 = 0\\) Tip Pour modifier les droits, il existe la commande chmod . Elle permet de modifier avec la notation binaire, mais aussi en changent juste certains bits sur un set de droits : chmod 750 toto.txt chmod u+rwx,g+rx,o-rwx toto.txt Avec la deuxi\u00e8me notation, les bits non mentionn\u00e9s ne sont pas chang\u00e9s !! Hi\u00e9rarchie \u2693\ufe0e On a un syst\u00e8me de catalogues : m\u00e9morisation des noms, attributs et adresses des fichiers. La structure courante est une arborescence de catalogues . Un chemin d\u2019acc\u00e8s est le moyen d'arriver \u00e0 un fichier situ\u00e9 dans cet arbre. Chemin absolu = \u00e0 partir de la racine de l\u2019arbre (ROOT) Chemin relatif = \u00e0 partir de la position courante dans l\u2019arbre Chemin non lin\u00e9aire = permet de couper l'arborescence en suivant un lien Dans les SE UNIX Based : . = catalogue courant .. = catalogue p\u00e8re ~ = r\u00e9pertoire de base d'un utilisateur Op\u00e9rations sur les Fichiers \u2693\ufe0e Ces op\u00e9rations se font gr\u00e2ce \u00e0 des appels syst\u00e8mes (fonction disponible dans le noyau) : CREATE (cr\u00e9ation d\u2019un fichier vide) DELETE OPEN CLOSE READ (lecture de n octets \u00e0 partir de la position courante) WRITE APPEND (\u00e9criture en fin de fichier) SEEK (indication de la position des donn\u00e9es \u00e0 lire/\u00e9crire) GET ATTRIBUTES SET ATTRIBUTES RENAME Stockage des fichiers \u2693\ufe0e Comment le SE sauve-t-il le fichier sur le disque ? Allocation contigu\u00eb : \u2693\ufe0e Tous les blocs se suivent m\u00e9thode la plus simple mais co\u00fbteuse en espace disque Allocation \u00abliste cha\u00een\u00e9e\u00bb : \u2693\ufe0e Chaque bloc contient l\u2019adresse du bloc suivant pas d\u2019espace perdu mais acc\u00e8s al\u00e9atoire lent Allocation \u00abliste cha\u00een\u00e9e index\u00e9e\u00bb : \u2693\ufe0e Regroupement des \u00abadresses de bloc\u00bb dans une table (index) en m\u00e9moire [MS-DOS] inconv\u00e9nient : table enti\u00e8rement en m\u00e9moire ...","title":"SGF"},{"location":"02_sgf/#le-systeme-de-gestion-de-fichiers","text":"","title":"Le Syst\u00e8me de Gestion de Fichiers"},{"location":"02_sgf/#pourquoi","text":"On ne peut pas stocker d'informations de mani\u00e8re durable dans la RAM puisqu'elle est volatile, et de taille restreinte. Il faut donc organiser nos donn\u00e9es qui doivent perdurer sur le Disque Dur, afin de pouvoir stocker de gros volumes, de pouvoir les partager etc ... Le SGF d\u00e9finit : organisation coh\u00e9rente de la m\u00e9moire secondaire Notion de fichiers et de r\u00e9pertoires Les sous-r\u00e9pertoires sont des enfants d\u2019un r\u00e9pertoire racine On a donc un hi\u00e9rarchie , o\u00f9 un r\u00e9pertoire peut en contenir d\u2019autres. comment nommer les fichiers (caract\u00e8res interdits, r\u00e9serv\u00e9s, extensions etc ...)? comment les structurer ? comment les utiliser, les prot\u00e9ger ? Important ! Sur un syst\u00e8me UNIX : l'OS g\u00e8re un fichier et un dossier de la m\u00eame mani\u00e8re ! Un dossier est un fichier qui peut en contenir d'autres. Un fichier simple est un fichier qui ne peut pas en contenir d'autres. La distinction ne tient qu'\u00e0 un attribut qui indique que le fichier en question est en fait un dossier.","title":"Pourquoi ?"},{"location":"02_sgf/#inodes","text":"Le SGF conserve une liste de tous les fichiers : la table des inodes. Un inode est un n\u0153ud d\u2019information qui contient les attributs d'un fichier (jusqu'\u00e0 40+ sur certains OS !) : type de fichier (fichier simple, r\u00e9pertoire, socket ...) propri\u00e9taire (user, group) permissions compteur de lien : nb de r\u00e9pertoires contenant une entr\u00e9e avec ce num\u00e9ro d\u2019inode marques temporelles (date/heure cr\u00e9ation, date/heure modification) liste de blocs (liste des n\u00b0 de blocs contenant le 1er segment du fichier) ... Important ! Un inode ne contient PAS le nom du fichier. Un fichier simple \u00e9tant forc\u00e9ment dans un fichier de type r\u00e9pertoire, c'est le fichier r\u00e9pertoire qui contient les noms des fichiers qu'il contient ! Cela permet d'avoir une table d'inodes de petites dimension, qui se parcourt rapidement !","title":"Inodes"},{"location":"02_sgf/#types-des-fichiers","text":"Tip On peut facilement voir le type d'un fichier en faisant la commande ls -l qui affiche le nom du fichier pr\u00e9c\u00e9d\u00e9 de son type et droits d'acc\u00e8s : 1 2 3 4 5 ls -l l rw-r--r-- 1 jberger 1049089 309 Oct 29 10 :06 monLien -> SE/TP2/src/bonjour.c - rw-r--r-- 1 jberger 1049089 16 Oct 29 10 :36 testRegexp d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP1/ d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP2/","title":"Types des fichiers"},{"location":"02_sgf/#fichiers-normaux","text":"Utilis\u00e9s par les users Fichiers ASCII : lignes de texte (caract\u00e8re \u00ab fin de ligne \u00bb variable selon les SE) avantage = facilement lisibles et modifiables Fichiers binaires : structur\u00e9s pour que l \u2019on puisse retrouver ses informations.","title":"Fichiers normaux :"},{"location":"02_sgf/#repertoires","text":"Utilis\u00e9s par les users Fichiers de type particulier qui contiennent une liste d\u2019autres fichiers","title":"R\u00e9pertoires :"},{"location":"02_sgf/#lien-permanent","text":"Entr\u00e9e de r\u00e9pertoire normale qui au lieu de pointer vers un fichier unique, pointe sur un fichier d\u00e9j\u00e0 existant. Permets de donner plusieurs noms \u00e0 un fichier, dans des r\u00e9pertoires diff\u00e9rents. Donc de le partager ! Ce fichier ne sera effac\u00e9 que lorsque son dernier nom est supprim\u00e9 (pas d\u2019inode suppl\u00e9mentaire).","title":"Lien permanent :"},{"location":"02_sgf/#lien-symbolique","text":"Ne pointe pas vers un autre inode comme un lien permanent mais vers un autre nom de fichier (inode suppl\u00e9mentaire). Lors d'un parcours automatique de disque, on passera plusieurs fois au m\u00eame endroit de la m\u00e9moire vu qu'il y a une nouvelle inode ... Peut perf ! Diff\u00e9rence en image :","title":"Lien symbolique :"},{"location":"02_sgf/#socket","text":"Moyen de communication avec d\u2019autres machines via le r\u00e9seau.","title":"Socket :"},{"location":"02_sgf/#pipes-nommes","text":"Moyen de communication entre processus d'une m\u00eame machine.","title":"Pipes nomm\u00e9s :"},{"location":"02_sgf/#fichiers-speciaux-caracteres","text":"Offre un m\u00e9canisme de communication avec les pilotes de p\u00e9riph\u00e9riques \u00e0 raison d\u2019un caract\u00e8re \u00e0 la fois. Mod\u00e9lisation d\u2019E/S (terminaux,imprimante ...) (Contenu non gard\u00e9 en m\u00e9moire).","title":"Fichiers sp\u00e9ciaux caract\u00e8res :"},{"location":"02_sgf/#fichiers-speciaux-bloc","text":"Offre un m\u00e9canisme de communication avec les pilotes de p\u00e9riph\u00e9riques, similitude avec les fichiers sp\u00e9ciaux \u00e0 caract\u00e8re, mais avec une quantit\u00e9 de donn\u00e9es plus importante. Mod\u00e9lisation des disques (Contenu gard\u00e9 en m\u00e9moire).","title":"Fichiers sp\u00e9ciaux bloc :"},{"location":"02_sgf/#permissions-sur-les-fichiers","text":"","title":"Permissions sur les Fichiers"},{"location":"02_sgf/#definition-des-droits","text":"Un fichier peut appartenir \u00e0 un utilisateur qui lui-m\u00eame fait partie d'un ensemble d'utilisateur ( groupe ) qui ont tous les m\u00eames droits sur une m\u00eame machine. Par exemple, il peut y avoir un groupe \u00e9l\u00e8ves et profs sur une m\u00eame machine et les \u00e9l\u00e8ves connect\u00e9s n'ont pas acc\u00e8s aux fichiers de correction ! On va donc g\u00e9rer les acc\u00e8s pour : Un User Un Groupe d'Users Les Autres Tip On peut facilement voir les droits d'acc\u00e8s \u00e0 un fichier en faisant la commande ls -l 1 2 3 4 5 ls -l l rw-r--r-- 1 jberger 1049089 309 Oct 29 10 :06 monLien -> SE/TP2/src/bonjour.c - rw-r--r-- 1 jberger 1049089 16 Oct 29 10 :36 testRegexp d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP1/ d rwxr-xr-x 1 jberger 1049089 0 Oct 28 17 :03 TP2/ Ici, l'utilisateur jberger en particulier peut lire et \u00e9crire le fichier testRegexp . Les utilisateurs appartenant au groupe 1049089 peuvent uniquement le lire. Idem pour tous les autres utilisateurs.","title":"D\u00e9finition des Droits"},{"location":"02_sgf/#modification-des-droits","text":"Le codage des droits est fait sous forme binaire (en puissances de 2), pour chaque bloc de permissions (user/group/others). Ainsi le codage des droits rwxr-x--- donne 750 : - Droits User : \\(2^2 + 2^1 + 2^0 = 7\\) - Droits Groupe : \\(2^2 + 0 + 2^0 = 5\\) - Droits Autres : \\(0 + 0 + 0 = 0\\) Tip Pour modifier les droits, il existe la commande chmod . Elle permet de modifier avec la notation binaire, mais aussi en changent juste certains bits sur un set de droits : chmod 750 toto.txt chmod u+rwx,g+rx,o-rwx toto.txt Avec la deuxi\u00e8me notation, les bits non mentionn\u00e9s ne sont pas chang\u00e9s !!","title":"Modification des Droits"},{"location":"02_sgf/#hierarchie","text":"On a un syst\u00e8me de catalogues : m\u00e9morisation des noms, attributs et adresses des fichiers. La structure courante est une arborescence de catalogues . Un chemin d\u2019acc\u00e8s est le moyen d'arriver \u00e0 un fichier situ\u00e9 dans cet arbre. Chemin absolu = \u00e0 partir de la racine de l\u2019arbre (ROOT) Chemin relatif = \u00e0 partir de la position courante dans l\u2019arbre Chemin non lin\u00e9aire = permet de couper l'arborescence en suivant un lien Dans les SE UNIX Based : . = catalogue courant .. = catalogue p\u00e8re ~ = r\u00e9pertoire de base d'un utilisateur","title":"Hi\u00e9rarchie"},{"location":"02_sgf/#operations-sur-les-fichiers","text":"Ces op\u00e9rations se font gr\u00e2ce \u00e0 des appels syst\u00e8mes (fonction disponible dans le noyau) : CREATE (cr\u00e9ation d\u2019un fichier vide) DELETE OPEN CLOSE READ (lecture de n octets \u00e0 partir de la position courante) WRITE APPEND (\u00e9criture en fin de fichier) SEEK (indication de la position des donn\u00e9es \u00e0 lire/\u00e9crire) GET ATTRIBUTES SET ATTRIBUTES RENAME","title":"Op\u00e9rations sur les Fichiers"},{"location":"02_sgf/#stockage-des-fichiers","text":"Comment le SE sauve-t-il le fichier sur le disque ?","title":"Stockage des fichiers"},{"location":"02_sgf/#allocation-contigue","text":"Tous les blocs se suivent m\u00e9thode la plus simple mais co\u00fbteuse en espace disque","title":"Allocation contigu\u00eb :"},{"location":"02_sgf/#allocation-liste-chainee","text":"Chaque bloc contient l\u2019adresse du bloc suivant pas d\u2019espace perdu mais acc\u00e8s al\u00e9atoire lent","title":"Allocation \u00abliste cha\u00een\u00e9e\u00bb :"},{"location":"02_sgf/#allocation-liste-chainee-indexee","text":"Regroupement des \u00abadresses de bloc\u00bb dans une table (index) en m\u00e9moire [MS-DOS] inconv\u00e9nient : table enti\u00e8rement en m\u00e9moire ...","title":"Allocation \u00abliste cha\u00een\u00e9e index\u00e9e\u00bb :"},{"location":"03_processus/","text":"Processus \u2693\ufe0e D\u00e9finition \u2693\ufe0e Un processus : Est un programme en cours d'execution. C'est donc une entit\u00e9 dynamique ! Cela implique qu'il a un cycle de vie avec une naissance et une mort, mais aussi qu'il peut interagir avec d'autres processus ! Interagit par communication En utilisant le syst\u00e8me de communication inter-processus (m\u00e9moire partag\u00e9e, tuyaux/pipes, files de messages, etc.) du SE. Utilise des ressources Ces ressources sont des : fichiers, m\u00e9moire, s\u00e9maphores p\u00e9riph\u00e9riques d\u2019E/S, etc. Ces ressources sont contr\u00f4l\u00e9es par le S.E. Poss\u00e8de un context qui lui est propre Un environnement processeur & un environnement m\u00e9moire. Est toujours lanc\u00e9 par un processus parent existant. Poss\u00e8de un num\u00e9ro unique (PID) Cycle de vie \u2693\ufe0e Tip A la place de \"En Execution\" on parlera aussi de processus \"Elu\" A un instant donn\u00e9, un processus peut \u00eatre dans l\u2019un des \u00e9tats suivants : Actif/Elu : le processus s\u2019ex\u00e9cute sur un processeur (il n\u2019y a donc qu\u2019un seul processus actif en m\u00eame temps sur une machine monoprocesseur) Pr\u00eat : le processus peut devenir actif d\u00e8s que le processeur lui sera attribu\u00e9 par le syst\u00e8me Bloqu\u00e9 : le processus a besoin d\u2019une ressource pour continuer (attente d\u2019entr\u00e9e/sortie par exemple). Le blocage ne peut avoir lieu qu\u2019\u00e0 la suite d\u2019un appel syst\u00e8me. Un processus bloqu\u00e9 ne consomme pas de temps processeur. Il peut y en avoir beaucoup sans p\u00e9naliser les performances du syst\u00e8me. Warning Si un processus ne respecte pas son cycle de vie, il terminera dans un \u00e9tat \" ZOMBIE \", tr\u00e8s n\u00e9faste pour la machine h\u00f4te ... Cycle de vie simplifi\u00e9 \u2693\ufe0e Communication Inter Processus \u2693\ufe0e La communication inter-process est essentielle car elle permet : Le transfert des donn\u00e9es entre processus Via des \"pipes\", \"memory sharing\", \"message queue\" ou des \"signaux\" Nous nous int\u00e9resserons particuli\u00e8rement aux Pipes : Structure de donn\u00e9es FIFO dont les acc\u00e8s sont g\u00e9r\u00e9s par le S.E La coordination des processus M\u00e9thodes qui \u00e9vitent les erreurs dans l\u2019acc\u00e8s des donn\u00e9es et leurs traitements La synchronisation des processus Appels de syst\u00e8me permettant l'ordonnancement des processus Nous nous int\u00e9resserons particuli\u00e8rement aux fonction signal() et wait() dans la partie programmation syst\u00e8me de ce cours Les deux derniers points sont essentiels car ils permettent d'\u00e9viter : L'impasse Interd\u00e9pendance (de donn\u00e9es) des processus qui emp\u00eache la progression de tous les processus impliqu\u00e9s Analogie : arr\u00eat toutes directions \u00e0 l\u2019intersection des chemins crois\u00e9s La famine Interd\u00e9pendance (de donn\u00e9es) des processus qui emp\u00eache la progression d\u2019un sous-ensemble de processus impliqu\u00e9s Analogie : devant un tourniquet \u00e0 l\u2019entr\u00e9e d\u2019un m\u00e9tro \u00e0 l\u2019heure de pointe Table des Processus \u2693\ufe0e Elle est form\u00e9e d\u2019un tableau de structures d\u00e9crivant les processus, dont le noyau se sert pour g\u00e9rer leur ex\u00e9cution. Chaque entr\u00e9e dans la table d\u00e9finit un processus cr\u00e9\u00e9 par le noyau. Elle r\u00e9side en m\u00e9moire , le noyau l\u2019interroge et la met \u00e0 jour en permanence lorsqu\u2019il alloue et d\u00e9salloue du temps CPU aux processus. Les informations d\u2019ordonnancement de processus de cette table sont aussi mises \u00e0 jour pour les processus qui ne sont pas en cours d\u2019ex\u00e9cution. Important On parle de table ... ce qui implique que chaque processus poss\u00e8de un identifiant unique appel\u00e9 PID (Process ID). Tip Les structures des processus sont d\u00e9finies dans /usr/include/sys/proc.h Context d'\u00e9xecution \u2693\ufe0e Pour pouvoir stopper et reprendre un processus o\u00f9 il en \u00e9tait, le SE doit g\u00e9rer et conserver/restaurer le context d'\u00e9xecution de chaque processus. Hierarchie \u2693\ufe0e Comme tout bon syst\u00e8me UNIX, et comme pour le SGF, la gestion des processus repose sur un concept arborescent . Modes d'\u00e9xecution \u2693\ufe0e Interactif (foreground) \u2693\ufe0e Le plus fr\u00e9quent (on tape une cmd, on attend un r\u00e9sultat) Interruption de la commande par CTRL^C Suspension de la commande par CTRL^Z Arri\u00e8re plan (background) \u2693\ufe0e La cmd est lanc\u00e9e, mais on rend le contr\u00f4le \u00e0 l\u2019utilisateur Pas d\u2019interaction avec l\u2019utilisateur. Conclusion \u2693\ufe0e Success Maintenant, votre point de vue de programmeur sur les OS doit ressembler \u00e0 ceci :","title":"Processus"},{"location":"03_processus/#processus","text":"","title":"Processus"},{"location":"03_processus/#definition","text":"Un processus : Est un programme en cours d'execution. C'est donc une entit\u00e9 dynamique ! Cela implique qu'il a un cycle de vie avec une naissance et une mort, mais aussi qu'il peut interagir avec d'autres processus ! Interagit par communication En utilisant le syst\u00e8me de communication inter-processus (m\u00e9moire partag\u00e9e, tuyaux/pipes, files de messages, etc.) du SE. Utilise des ressources Ces ressources sont des : fichiers, m\u00e9moire, s\u00e9maphores p\u00e9riph\u00e9riques d\u2019E/S, etc. Ces ressources sont contr\u00f4l\u00e9es par le S.E. Poss\u00e8de un context qui lui est propre Un environnement processeur & un environnement m\u00e9moire. Est toujours lanc\u00e9 par un processus parent existant. Poss\u00e8de un num\u00e9ro unique (PID)","title":"D\u00e9finition"},{"location":"03_processus/#cycle-de-vie","text":"Tip A la place de \"En Execution\" on parlera aussi de processus \"Elu\" A un instant donn\u00e9, un processus peut \u00eatre dans l\u2019un des \u00e9tats suivants : Actif/Elu : le processus s\u2019ex\u00e9cute sur un processeur (il n\u2019y a donc qu\u2019un seul processus actif en m\u00eame temps sur une machine monoprocesseur) Pr\u00eat : le processus peut devenir actif d\u00e8s que le processeur lui sera attribu\u00e9 par le syst\u00e8me Bloqu\u00e9 : le processus a besoin d\u2019une ressource pour continuer (attente d\u2019entr\u00e9e/sortie par exemple). Le blocage ne peut avoir lieu qu\u2019\u00e0 la suite d\u2019un appel syst\u00e8me. Un processus bloqu\u00e9 ne consomme pas de temps processeur. Il peut y en avoir beaucoup sans p\u00e9naliser les performances du syst\u00e8me. Warning Si un processus ne respecte pas son cycle de vie, il terminera dans un \u00e9tat \" ZOMBIE \", tr\u00e8s n\u00e9faste pour la machine h\u00f4te ...","title":"Cycle de vie"},{"location":"03_processus/#cycle-de-vie-simplifie","text":"","title":"Cycle de vie simplifi\u00e9"},{"location":"03_processus/#communication-inter-processus","text":"La communication inter-process est essentielle car elle permet : Le transfert des donn\u00e9es entre processus Via des \"pipes\", \"memory sharing\", \"message queue\" ou des \"signaux\" Nous nous int\u00e9resserons particuli\u00e8rement aux Pipes : Structure de donn\u00e9es FIFO dont les acc\u00e8s sont g\u00e9r\u00e9s par le S.E La coordination des processus M\u00e9thodes qui \u00e9vitent les erreurs dans l\u2019acc\u00e8s des donn\u00e9es et leurs traitements La synchronisation des processus Appels de syst\u00e8me permettant l'ordonnancement des processus Nous nous int\u00e9resserons particuli\u00e8rement aux fonction signal() et wait() dans la partie programmation syst\u00e8me de ce cours Les deux derniers points sont essentiels car ils permettent d'\u00e9viter : L'impasse Interd\u00e9pendance (de donn\u00e9es) des processus qui emp\u00eache la progression de tous les processus impliqu\u00e9s Analogie : arr\u00eat toutes directions \u00e0 l\u2019intersection des chemins crois\u00e9s La famine Interd\u00e9pendance (de donn\u00e9es) des processus qui emp\u00eache la progression d\u2019un sous-ensemble de processus impliqu\u00e9s Analogie : devant un tourniquet \u00e0 l\u2019entr\u00e9e d\u2019un m\u00e9tro \u00e0 l\u2019heure de pointe","title":"Communication Inter Processus"},{"location":"03_processus/#table-des-processus","text":"Elle est form\u00e9e d\u2019un tableau de structures d\u00e9crivant les processus, dont le noyau se sert pour g\u00e9rer leur ex\u00e9cution. Chaque entr\u00e9e dans la table d\u00e9finit un processus cr\u00e9\u00e9 par le noyau. Elle r\u00e9side en m\u00e9moire , le noyau l\u2019interroge et la met \u00e0 jour en permanence lorsqu\u2019il alloue et d\u00e9salloue du temps CPU aux processus. Les informations d\u2019ordonnancement de processus de cette table sont aussi mises \u00e0 jour pour les processus qui ne sont pas en cours d\u2019ex\u00e9cution. Important On parle de table ... ce qui implique que chaque processus poss\u00e8de un identifiant unique appel\u00e9 PID (Process ID). Tip Les structures des processus sont d\u00e9finies dans /usr/include/sys/proc.h","title":"Table des Processus"},{"location":"03_processus/#context-dexecution","text":"Pour pouvoir stopper et reprendre un processus o\u00f9 il en \u00e9tait, le SE doit g\u00e9rer et conserver/restaurer le context d'\u00e9xecution de chaque processus.","title":"Context d'\u00e9xecution"},{"location":"03_processus/#hierarchie","text":"Comme tout bon syst\u00e8me UNIX, et comme pour le SGF, la gestion des processus repose sur un concept arborescent .","title":"Hierarchie"},{"location":"03_processus/#modes-dexecution","text":"","title":"Modes d'\u00e9xecution"},{"location":"03_processus/#interactif-foreground","text":"Le plus fr\u00e9quent (on tape une cmd, on attend un r\u00e9sultat) Interruption de la commande par CTRL^C Suspension de la commande par CTRL^Z","title":"Interactif (foreground)"},{"location":"03_processus/#arriere-plan-background","text":"La cmd est lanc\u00e9e, mais on rend le contr\u00f4le \u00e0 l\u2019utilisateur Pas d\u2019interaction avec l\u2019utilisateur.","title":"Arri\u00e8re plan (background)"},{"location":"03_processus/#conclusion","text":"Success Maintenant, votre point de vue de programmeur sur les OS doit ressembler \u00e0 ceci :","title":"Conclusion"},{"location":"04_ordonnancement/","text":"Ordonnancement \u2693\ufe0e G\u00e9n\u00e9ralit\u00e9s \u2693\ufe0e Dans la vraie vie, plusieurs processus cohabitent et peuvent \u00eatre pr\u00eats \u00e0 \u00eatre ex\u00e9cut\u00e9s en m\u00eame temps. Le SE doit faire un choix (selon un algorithme d'ordonnancement) : \u00e9quit\u00e9 : chaque processus doit avoir du temps processeur efficacit\u00e9 : le processeur doit \u00eatre utilis\u00e9 \u00e0 100% temps de r\u00e9ponse : l 'utilisateur devant sa machine ne doit pas trop attendre temps d'attente : les processus doivent d\u00e9marrer le plus vite possible temps d'ex\u00e9cution : une s\u00e9quence d'instructions ne doit pas trop durer rendement : il faut faire le plus de choses en une heure R\u00e9quisition \u2693\ufe0e Il existe deux grandes familles d'ordonnacement : Ordonnancement sans r\u00e9quisition (ou non pr\u00e9emptif) \u2693\ufe0e Un processus est ex\u00e9cut\u00e9 jusqu'\u00e0 la fin (sauf si il se bloque lui-m\u00eame). inefficace et dangereux (ex: ex\u00e9cution d'une boucle sans fin...) Ordonnancement avec r\u00e9quisition (ou pr\u00e9emptif) \u2693\ufe0e A chaque signal d'horloge, le SE reprend la main, d\u00e9cide si le processus courant doit c\u00e9der sa place, et \u00e9ventuellement donne le processeur \u00e0 un autre processus. Un processus perd le processeur s'il se bloque lui-m\u00eame. Il existe de nombreux algorithmes d'ordonnancement avec r\u00e9quisition. C'est le noyau qui d\u00e9clenche le passage de l'\u00e9tat Elu \u00e0 l'\u00e9tat Pr\u00eat lors d'une r\u00e9quisition. FIFO \u2693\ufe0e Warning On remarque que l'ordre de passage change la donne ... Priorit\u00e9s \u2693\ufe0e Chaque processus re\u00e7oit une priorit\u00e9, le processus de plus forte priorit\u00e9 est \u00e9lu avec ou sans r\u00e9quisition. Round Robin (RR) ou \"tourniquet\" \u2693\ufe0e D\u00e9finition d'un quantum = tranche de temps. Un processus \u00e9lu s'ex\u00e9cute au plus durant un quantum. A la fin du quantum, pr\u00e9emption et r\u00e9insertion en fin de file d'attente des processus pr\u00eats. Files de priorit\u00e9s \u2693\ufe0e On d\u00e9finit des priorit\u00e9s constantes multi niveaux avec ou sans extinction de priorit\u00e9. Chaque file est associ\u00e9e \u00e0 un quantum \u00e9ventuellement diff\u00e9rent. Sans extinction : \u2693\ufe0e Un processus garde toujours la m\u00eame priorit\u00e9. Avec extinction : \u2693\ufe0e La priorit\u00e9 d'un processus d\u00e9cro\u00eet en fonction de son utilisation de la CPU. SJF : Shortest Job First \u2693\ufe0e Le plus court d'abord.","title":"Ordonnancement"},{"location":"04_ordonnancement/#ordonnancement","text":"","title":"Ordonnancement"},{"location":"04_ordonnancement/#generalites","text":"Dans la vraie vie, plusieurs processus cohabitent et peuvent \u00eatre pr\u00eats \u00e0 \u00eatre ex\u00e9cut\u00e9s en m\u00eame temps. Le SE doit faire un choix (selon un algorithme d'ordonnancement) : \u00e9quit\u00e9 : chaque processus doit avoir du temps processeur efficacit\u00e9 : le processeur doit \u00eatre utilis\u00e9 \u00e0 100% temps de r\u00e9ponse : l 'utilisateur devant sa machine ne doit pas trop attendre temps d'attente : les processus doivent d\u00e9marrer le plus vite possible temps d'ex\u00e9cution : une s\u00e9quence d'instructions ne doit pas trop durer rendement : il faut faire le plus de choses en une heure","title":"G\u00e9n\u00e9ralit\u00e9s"},{"location":"04_ordonnancement/#requisition","text":"Il existe deux grandes familles d'ordonnacement :","title":"R\u00e9quisition"},{"location":"04_ordonnancement/#ordonnancement-sans-requisition-ou-non-preemptif","text":"Un processus est ex\u00e9cut\u00e9 jusqu'\u00e0 la fin (sauf si il se bloque lui-m\u00eame). inefficace et dangereux (ex: ex\u00e9cution d'une boucle sans fin...)","title":"Ordonnancement sans r\u00e9quisition (ou non pr\u00e9emptif)"},{"location":"04_ordonnancement/#ordonnancement-avec-requisition-ou-preemptif","text":"A chaque signal d'horloge, le SE reprend la main, d\u00e9cide si le processus courant doit c\u00e9der sa place, et \u00e9ventuellement donne le processeur \u00e0 un autre processus. Un processus perd le processeur s'il se bloque lui-m\u00eame. Il existe de nombreux algorithmes d'ordonnancement avec r\u00e9quisition. C'est le noyau qui d\u00e9clenche le passage de l'\u00e9tat Elu \u00e0 l'\u00e9tat Pr\u00eat lors d'une r\u00e9quisition.","title":"Ordonnancement avec r\u00e9quisition (ou pr\u00e9emptif)"},{"location":"04_ordonnancement/#fifo","text":"Warning On remarque que l'ordre de passage change la donne ...","title":"FIFO"},{"location":"04_ordonnancement/#priorites","text":"Chaque processus re\u00e7oit une priorit\u00e9, le processus de plus forte priorit\u00e9 est \u00e9lu avec ou sans r\u00e9quisition.","title":"Priorit\u00e9s"},{"location":"04_ordonnancement/#round-robin-rr-ou-tourniquet","text":"D\u00e9finition d'un quantum = tranche de temps. Un processus \u00e9lu s'ex\u00e9cute au plus durant un quantum. A la fin du quantum, pr\u00e9emption et r\u00e9insertion en fin de file d'attente des processus pr\u00eats.","title":"Round Robin (RR) ou \"tourniquet\""},{"location":"04_ordonnancement/#files-de-priorites","text":"On d\u00e9finit des priorit\u00e9s constantes multi niveaux avec ou sans extinction de priorit\u00e9. Chaque file est associ\u00e9e \u00e0 un quantum \u00e9ventuellement diff\u00e9rent.","title":"Files de priorit\u00e9s"},{"location":"04_ordonnancement/#sans-extinction","text":"Un processus garde toujours la m\u00eame priorit\u00e9.","title":"Sans extinction :"},{"location":"04_ordonnancement/#avec-extinction","text":"La priorit\u00e9 d'un processus d\u00e9cro\u00eet en fonction de son utilisation de la CPU.","title":"Avec extinction :"},{"location":"04_ordonnancement/#sjf-shortest-job-first","text":"Le plus court d'abord.","title":"SJF : Shortest Job First"},{"location":"05_tdOrdo/","text":"TD Ordonnancement \u2693\ufe0e Objectifs \u2693\ufe0e Comparaison basique de deux syst\u00e8mes d'exploitation (Windows et Linux). Se rendre compte du travail effectu\u00e9 par le CPU : Ordonnancement manuel de processus. Pr\u00e9requis \u2693\ufe0e T\u00e9l\u00e9charger ce fichier BlankTables.xls pour noter vos r\u00e9sultats des exos 2 & 3 Exercice 1 : Comparatif rapide \u2693\ufe0e Un syst\u00e8me d'exploitation peut \u00eatre vu comme un ensemble de logiciels organis\u00e9s en couches, entre l'utilisateur et la partie mat\u00e9rielle de l'ordinateur. Vous avez a disposition des machine sous Windows et sous Linux ou Mac (la votre, une VM, WSL, chez votre voisin ...). Vous allez donc essayer de reconna\u00eetre les diff\u00e9rentes composantes de ces deux syst\u00e8mes d'exploitation. Pour vous aider, voici une liste (non exhaustive) de points \u00e0 regarder : O\u00f9 est le noyau du SE ? est-il prot\u00e9g\u00e9 ? Quel est l'interpr\u00e9teur de commande par d\u00e9faut du SE ? Quelles en sont ses fonctionnalit\u00e9s ? En existe-t-il d'autres (interpreteurs) ? Un SE digne de ce nom doit fournir de nombreux utilitaires de programmation (\u00e9diteurs, compilateurs, interpr\u00e9teurs, d\u00e9bogueurs) : quels sont ceux pr\u00e9sents par d\u00e9faut avec le SE ? \u2026 Warning Si vous observez que le noyaux n'est pas prot\u00e9g\u00e9 sur windows ... Ne le supprimez PAS !! Vous rendrier votre machine inutilisable ... Tip Pour toutes ces recherches, google est votre ami A la place de \"noyau\" on parle souvent historiquement de \"Kernel\" ! Exercice 2 : Ordonnancement simple \u2693\ufe0e Soit 5 processus A, B, C, D et E qui sont soumis \u00e0 un CPU dans cet ordre, mais quasi simultan\u00e9ment. Ces travaux ne font pas d'entr\u00e9es-sorties. Leurs dur\u00e9es respectives sont : Processus dur\u00e9e(s) A 10s B 6s C 2s D 4s E 8s Question 1 \u2693\ufe0e D\u00e9terminer les temps de r\u00e9ponse de chacun des processus, ainsi que le temps de r\u00e9ponse moyen , pour les disciplines : Pour le moment, on est en algos non pr\u00e9emptifs . FIFO (First In First Out) SJF (Shortest Job First) Priorit\u00e9s, avec le plus petit chiffre \u00e9gal \u00e0 la priorit\u00e9 la plus forte et : Processus dur\u00e9e(s) Priorit\u00e9 A 10s 3 B 6s 5 C 2s 2 D 4s 1 E 8s 4 PS (Proc. Sharing ou Tourniquet/Round Robin) et un quantum de 2s . Question 2 \u2693\ufe0e On consid\u00e8re ces 5 processus ordonnanc\u00e9s par la politique \u00e0 priorit\u00e9 pr\u00e9c\u00e9dente. A pr\u00e9sent, les 5 processus ne sont pas soumis en m\u00eame temps . Les dates d\u2019arriv\u00e9e des processus sont respectivement : Processus dur\u00e9e(s) Priorit\u00e9 Soumis \u00e0 (s) A 10s 3 2s B 6s 5 0s C 2s 2 5s D 4s 1 5s E 8s 4 3s Tracez le sch\u00e9ma d\u2019ex\u00e9cution des processus en consid\u00e9rant que : L\u2019ordonnancement est non pr\u00e9emptif comme pr\u00e9c\u00e9demment. Puis qu\u2019il est pr\u00e9emptif . Exercice 3 : Ordonnancement plus complexe \u2693\ufe0e On consid\u00e8re un syst\u00e8me monoprocesseur (avec capacit\u00e9 de pr\u00e9emption), de type Linux dans lequel les processus partagent un disque comme seule ressource autre que le processeur . Cette ressource (le HDD ) n\u2019est accessible qu\u2019en acc\u00e8s exclusif et non requ\u00e9rable , c\u2019est-\u00e0-dire qu\u2019une commande disque lanc\u00e9e pour le compte d\u2019un processus se termine normalement avant de pouvoir en lancer une autre. Un processus peut \u00eatre en ex\u00e9cution , en attente d\u2019entr\u00e9es-sorties , en entr\u00e9es-sorties ou en attente du processeur . Les demandes d\u2019entr\u00e9es-sorties sont g\u00e9r\u00e9es \u00e0 l\u2019 anciennet\u00e9 . Dans ce syst\u00e8me, on consid\u00e8re 4 processus soumis \u00e0 t=0 dans l'ordre P1, P2, P3, P4, pour lesquels on sait que: P1 et P2 sont des processus appartenant \u00e0 la classe SCHED_PRIO . Dans cette classe, le processeur est donn\u00e9 au processus de plus haute priorit\u00e9. Ce processus peut \u00eatre pr\u00e9empt\u00e9 par un processus de la m\u00eame classe ayant une priorit\u00e9 sup\u00e9rieure P3 et P4 sont des processus appartenant \u00e0 la classe SCHED_RR . Dans cette classe, le processeur est donn\u00e9 au processus de plus haute priorit\u00e9 pour un quantum de temps \u00e9gal \u00e0 10 ms . La politique appliqu\u00e9e est celle du tourniquet. Les processus de la classe SCHED_PRIO sont toujours plus prioritaires que les processus de la classe SCHED_RR . Les priorit\u00e9s des processus sont \u00e9gales \u00e0 50 pour le processus P1, 49 pour le processus P2, P3 et P4. La plus grande valeur correspond \u00e0 la priorit\u00e9 la plus forte. P1 P2 P3 P4 P1 Calcul pendant 40 ms P2 Calcul pendant 30 ms P3 Calcul pendant 40 ms P4 Calcul pendant 100 ms Lecture disque pendant 50 ms Lecture disque pendant 80 ms Lecture disque pendant 40 ms Calcul pendant 30 ms Calcul pendant 70 ms Calcul pendant 10 ms Lecture disque pendant 40 ms Lecture disque pendant 20 ms Calcul pendant 10 ms Calcul pendant 10 ms \u00c9tablissez le chronogramme d\u2019ex\u00e9cution des 4 processus en figurant les \u00e9tats pr\u00eat (attente du processeur) , ex\u00e9cution , attente I/O (attente du HDD) , I/O (lecture/ecriture HDD) .","title":"TD - Les Bases"},{"location":"05_tdOrdo/#td-ordonnancement","text":"","title":"TD Ordonnancement"},{"location":"05_tdOrdo/#objectifs","text":"Comparaison basique de deux syst\u00e8mes d'exploitation (Windows et Linux). Se rendre compte du travail effectu\u00e9 par le CPU : Ordonnancement manuel de processus.","title":"Objectifs"},{"location":"05_tdOrdo/#prerequis","text":"T\u00e9l\u00e9charger ce fichier BlankTables.xls pour noter vos r\u00e9sultats des exos 2 & 3","title":"Pr\u00e9requis"},{"location":"05_tdOrdo/#exercice-1-comparatif-rapide","text":"Un syst\u00e8me d'exploitation peut \u00eatre vu comme un ensemble de logiciels organis\u00e9s en couches, entre l'utilisateur et la partie mat\u00e9rielle de l'ordinateur. Vous avez a disposition des machine sous Windows et sous Linux ou Mac (la votre, une VM, WSL, chez votre voisin ...). Vous allez donc essayer de reconna\u00eetre les diff\u00e9rentes composantes de ces deux syst\u00e8mes d'exploitation. Pour vous aider, voici une liste (non exhaustive) de points \u00e0 regarder : O\u00f9 est le noyau du SE ? est-il prot\u00e9g\u00e9 ? Quel est l'interpr\u00e9teur de commande par d\u00e9faut du SE ? Quelles en sont ses fonctionnalit\u00e9s ? En existe-t-il d'autres (interpreteurs) ? Un SE digne de ce nom doit fournir de nombreux utilitaires de programmation (\u00e9diteurs, compilateurs, interpr\u00e9teurs, d\u00e9bogueurs) : quels sont ceux pr\u00e9sents par d\u00e9faut avec le SE ? \u2026 Warning Si vous observez que le noyaux n'est pas prot\u00e9g\u00e9 sur windows ... Ne le supprimez PAS !! Vous rendrier votre machine inutilisable ... Tip Pour toutes ces recherches, google est votre ami A la place de \"noyau\" on parle souvent historiquement de \"Kernel\" !","title":"Exercice 1 : Comparatif rapide"},{"location":"05_tdOrdo/#exercice-2-ordonnancement-simple","text":"Soit 5 processus A, B, C, D et E qui sont soumis \u00e0 un CPU dans cet ordre, mais quasi simultan\u00e9ment. Ces travaux ne font pas d'entr\u00e9es-sorties. Leurs dur\u00e9es respectives sont : Processus dur\u00e9e(s) A 10s B 6s C 2s D 4s E 8s","title":"Exercice 2 : Ordonnancement simple"},{"location":"05_tdOrdo/#question-1","text":"D\u00e9terminer les temps de r\u00e9ponse de chacun des processus, ainsi que le temps de r\u00e9ponse moyen , pour les disciplines : Pour le moment, on est en algos non pr\u00e9emptifs . FIFO (First In First Out) SJF (Shortest Job First) Priorit\u00e9s, avec le plus petit chiffre \u00e9gal \u00e0 la priorit\u00e9 la plus forte et : Processus dur\u00e9e(s) Priorit\u00e9 A 10s 3 B 6s 5 C 2s 2 D 4s 1 E 8s 4 PS (Proc. Sharing ou Tourniquet/Round Robin) et un quantum de 2s .","title":"Question 1"},{"location":"05_tdOrdo/#question-2","text":"On consid\u00e8re ces 5 processus ordonnanc\u00e9s par la politique \u00e0 priorit\u00e9 pr\u00e9c\u00e9dente. A pr\u00e9sent, les 5 processus ne sont pas soumis en m\u00eame temps . Les dates d\u2019arriv\u00e9e des processus sont respectivement : Processus dur\u00e9e(s) Priorit\u00e9 Soumis \u00e0 (s) A 10s 3 2s B 6s 5 0s C 2s 2 5s D 4s 1 5s E 8s 4 3s Tracez le sch\u00e9ma d\u2019ex\u00e9cution des processus en consid\u00e9rant que : L\u2019ordonnancement est non pr\u00e9emptif comme pr\u00e9c\u00e9demment. Puis qu\u2019il est pr\u00e9emptif .","title":"Question 2"},{"location":"05_tdOrdo/#exercice-3-ordonnancement-plus-complexe","text":"On consid\u00e8re un syst\u00e8me monoprocesseur (avec capacit\u00e9 de pr\u00e9emption), de type Linux dans lequel les processus partagent un disque comme seule ressource autre que le processeur . Cette ressource (le HDD ) n\u2019est accessible qu\u2019en acc\u00e8s exclusif et non requ\u00e9rable , c\u2019est-\u00e0-dire qu\u2019une commande disque lanc\u00e9e pour le compte d\u2019un processus se termine normalement avant de pouvoir en lancer une autre. Un processus peut \u00eatre en ex\u00e9cution , en attente d\u2019entr\u00e9es-sorties , en entr\u00e9es-sorties ou en attente du processeur . Les demandes d\u2019entr\u00e9es-sorties sont g\u00e9r\u00e9es \u00e0 l\u2019 anciennet\u00e9 . Dans ce syst\u00e8me, on consid\u00e8re 4 processus soumis \u00e0 t=0 dans l'ordre P1, P2, P3, P4, pour lesquels on sait que: P1 et P2 sont des processus appartenant \u00e0 la classe SCHED_PRIO . Dans cette classe, le processeur est donn\u00e9 au processus de plus haute priorit\u00e9. Ce processus peut \u00eatre pr\u00e9empt\u00e9 par un processus de la m\u00eame classe ayant une priorit\u00e9 sup\u00e9rieure P3 et P4 sont des processus appartenant \u00e0 la classe SCHED_RR . Dans cette classe, le processeur est donn\u00e9 au processus de plus haute priorit\u00e9 pour un quantum de temps \u00e9gal \u00e0 10 ms . La politique appliqu\u00e9e est celle du tourniquet. Les processus de la classe SCHED_PRIO sont toujours plus prioritaires que les processus de la classe SCHED_RR . Les priorit\u00e9s des processus sont \u00e9gales \u00e0 50 pour le processus P1, 49 pour le processus P2, P3 et P4. La plus grande valeur correspond \u00e0 la priorit\u00e9 la plus forte. P1 P2 P3 P4 P1 Calcul pendant 40 ms P2 Calcul pendant 30 ms P3 Calcul pendant 40 ms P4 Calcul pendant 100 ms Lecture disque pendant 50 ms Lecture disque pendant 80 ms Lecture disque pendant 40 ms Calcul pendant 30 ms Calcul pendant 70 ms Calcul pendant 10 ms Lecture disque pendant 40 ms Lecture disque pendant 20 ms Calcul pendant 10 ms Calcul pendant 10 ms \u00c9tablissez le chronogramme d\u2019ex\u00e9cution des 4 processus en figurant les \u00e9tats pr\u00eat (attente du processeur) , ex\u00e9cution , attente I/O (attente du HDD) , I/O (lecture/ecriture HDD) .","title":"Exercice 3 : Ordonnancement plus complexe"},{"location":"05_tdOrdo_corr/","text":"TD Ordonnancement Correction \u2693\ufe0e Exercice 1 : Comparatif rapide \u2693\ufe0e Windows Linux Noyau C:\\Windows\\system32\\ntoskrnl.exe /boot/vmlinuz (lanc\u00e9 par Grub, on le voit dans la conf de Grub) Protection NON, n'importe quel utilisateur peut d\u00e9placer, effacer ou modifier ces fichiers OUI, seul le super utilisateur a le droit d'agir sur ces fichiers. Interpr\u00e9teur de commandes cmd /bin/bash Autres IC. PowerShell zsh, tcsh, sh, ksh, mc, \u2026 Fonctionnalit\u00e9s de l'IC. Traitement des fichiers, de r\u00e9pertoires et d\u00e9marrage d'applications. Tr\u00e8s peu d'applications peuvent \u00eatre lanc\u00e9es en tache de fond Traitement de fichiers, de r\u00e9pertoires et d\u00e9marrage des applications. Le lancement d'application en fond de tache est possible Utilitaires syst\u00e8mes Editeurs de texte, NOTEPAD, WORDPAD, edit sous MSDOS. Utilitaire de dessin (paint),navigateur Internet,lecture d'un CD audio,visionneuse d'images,calculatrice\u2026 Editeurs de texte (vi, ed, pico), utilitaire de dessin, navigateur Internet,lecture d'un CD audio,visionneuse d'images,calculatrice\u2026 Utilitaires de programmation Aucun compilateurs (gcc, java \u2026), \u00e9diteur de liensn outils de d\u00e9veloppement : d\u00e9bogueur (gdb) Exercice 2 : Ordonnancement simple \u2693\ufe0e Processus dur\u00e9e(s) Priorit\u00e9 Soumis \u00e0 (s) A 10s 3 2s B 6s 5 0s C 2s 2 5s D 4s 1 5s E 8s 4 3s Question 1 \u2693\ufe0e Question 2 \u2693\ufe0e Exercice 3 : Ordonnancement plus complexe \u2693\ufe0e P1 P2 P3 P4 P1 Calcul pendant 40 ms P2 Calcul pendant 30 ms P3 Calcul pendant 40 ms P4 Calcul pendant 100 ms Lecture disque pendant 50 ms Lecture disque pendant 80 ms Lecture disque pendant 40 ms Calcul pendant 30 ms Calcul pendant 70 ms Calcul pendant 10 ms Lecture disque pendant 40 ms Lecture disque pendant 20 ms Calcul pendant 10 ms Calcul pendant 10 ms","title":""},{"location":"05_tdOrdo_corr/#td-ordonnancement-correction","text":"","title":"TD Ordonnancement Correction"},{"location":"05_tdOrdo_corr/#exercice-1-comparatif-rapide","text":"Windows Linux Noyau C:\\Windows\\system32\\ntoskrnl.exe /boot/vmlinuz (lanc\u00e9 par Grub, on le voit dans la conf de Grub) Protection NON, n'importe quel utilisateur peut d\u00e9placer, effacer ou modifier ces fichiers OUI, seul le super utilisateur a le droit d'agir sur ces fichiers. Interpr\u00e9teur de commandes cmd /bin/bash Autres IC. PowerShell zsh, tcsh, sh, ksh, mc, \u2026 Fonctionnalit\u00e9s de l'IC. Traitement des fichiers, de r\u00e9pertoires et d\u00e9marrage d'applications. Tr\u00e8s peu d'applications peuvent \u00eatre lanc\u00e9es en tache de fond Traitement de fichiers, de r\u00e9pertoires et d\u00e9marrage des applications. Le lancement d'application en fond de tache est possible Utilitaires syst\u00e8mes Editeurs de texte, NOTEPAD, WORDPAD, edit sous MSDOS. Utilitaire de dessin (paint),navigateur Internet,lecture d'un CD audio,visionneuse d'images,calculatrice\u2026 Editeurs de texte (vi, ed, pico), utilitaire de dessin, navigateur Internet,lecture d'un CD audio,visionneuse d'images,calculatrice\u2026 Utilitaires de programmation Aucun compilateurs (gcc, java \u2026), \u00e9diteur de liensn outils de d\u00e9veloppement : d\u00e9bogueur (gdb)","title":"Exercice 1 : Comparatif rapide"},{"location":"05_tdOrdo_corr/#exercice-2-ordonnancement-simple","text":"Processus dur\u00e9e(s) Priorit\u00e9 Soumis \u00e0 (s) A 10s 3 2s B 6s 5 0s C 2s 2 5s D 4s 1 5s E 8s 4 3s","title":"Exercice 2 : Ordonnancement simple"},{"location":"05_tdOrdo_corr/#question-1","text":"","title":"Question 1"},{"location":"05_tdOrdo_corr/#question-2","text":"","title":"Question 2"},{"location":"05_tdOrdo_corr/#exercice-3-ordonnancement-plus-complexe","text":"P1 P2 P3 P4 P1 Calcul pendant 40 ms P2 Calcul pendant 30 ms P3 Calcul pendant 40 ms P4 Calcul pendant 100 ms Lecture disque pendant 50 ms Lecture disque pendant 80 ms Lecture disque pendant 40 ms Calcul pendant 30 ms Calcul pendant 70 ms Calcul pendant 10 ms Lecture disque pendant 40 ms Lecture disque pendant 20 ms Calcul pendant 10 ms Calcul pendant 10 ms","title":"Exercice 3 : Ordonnancement plus complexe"},{"location":"06_kernel/","text":"Noyau (Kernel) \u2693\ufe0e C'est le Programme qui assure : La gestion de la m\u00e9moire Le partage du processeur entre les diff\u00e9rentes t\u00e2ches \u00e0 ex\u00e9cuter et les entr\u00e9es/sorties de bas niveau. Une bonne r\u00e9partition des ressources de l\u2019ordinateur (m\u00e9moire, processeur(s), espace disque, imprimante(s), acc\u00e8s r\u00e9seaux) sans intervention des utilisateurs Il est lanc\u00e9 au d\u00e9marrage du syst\u00e8me (le boot) et s\u2019ex\u00e9cute jusqu\u2019\u00e0 son arr\u00eat. C\u2019est un programme relativement petit, qui est charg\u00e9 en m\u00e9moire principale. Il s\u2019ex\u00e9cute en mode superviseur , c\u2019est-\u00e0-dire qu\u2019il a acc\u00e8s \u00e0 toutes les fonctionnalit\u00e9s de la machine : acc\u00e8s \u00e0 toute la m\u00e9moire \u00e0 tous les disques connect\u00e9s manipulations des interruptions, etc... Tous les autres programmes qui s\u2019ex\u00e9cutent sur la machine fonctionnent en mode utilisateur. Ils leur est interdit d\u2019acc\u00e9der directement au mat\u00e9riel et d\u2019utiliser certaines instructions . Chaque programme utilisateur n\u2019a ainsi acc\u00e8s qu\u2019\u00e0 une certaine partie de la m\u00e9moire principale, et il lui est impossible de lire ou \u00e9crire les zones m\u00e9moires attribu\u00e9es aux autres programmes. Lorsque l\u2019un de ces programmes d\u00e9sire acc\u00e9der \u00e0 une ressource g\u00e9r\u00e9e par le noyau, par exemple pour effectuer une op\u00e9ration d\u2019entr\u00e9e/sortie, il ex\u00e9cute un appel syst\u00e8me . Le noyau ex\u00e9cute alors la fonction correspondante, apr\u00e8s avoir v\u00e9rifi\u00e9 que le programme appelant est autoris\u00e9 \u00e0 la r\u00e9aliser .","title":"Noyau"},{"location":"06_kernel/#noyau-kernel","text":"C'est le Programme qui assure : La gestion de la m\u00e9moire Le partage du processeur entre les diff\u00e9rentes t\u00e2ches \u00e0 ex\u00e9cuter et les entr\u00e9es/sorties de bas niveau. Une bonne r\u00e9partition des ressources de l\u2019ordinateur (m\u00e9moire, processeur(s), espace disque, imprimante(s), acc\u00e8s r\u00e9seaux) sans intervention des utilisateurs Il est lanc\u00e9 au d\u00e9marrage du syst\u00e8me (le boot) et s\u2019ex\u00e9cute jusqu\u2019\u00e0 son arr\u00eat. C\u2019est un programme relativement petit, qui est charg\u00e9 en m\u00e9moire principale. Il s\u2019ex\u00e9cute en mode superviseur , c\u2019est-\u00e0-dire qu\u2019il a acc\u00e8s \u00e0 toutes les fonctionnalit\u00e9s de la machine : acc\u00e8s \u00e0 toute la m\u00e9moire \u00e0 tous les disques connect\u00e9s manipulations des interruptions, etc... Tous les autres programmes qui s\u2019ex\u00e9cutent sur la machine fonctionnent en mode utilisateur. Ils leur est interdit d\u2019acc\u00e9der directement au mat\u00e9riel et d\u2019utiliser certaines instructions . Chaque programme utilisateur n\u2019a ainsi acc\u00e8s qu\u2019\u00e0 une certaine partie de la m\u00e9moire principale, et il lui est impossible de lire ou \u00e9crire les zones m\u00e9moires attribu\u00e9es aux autres programmes. Lorsque l\u2019un de ces programmes d\u00e9sire acc\u00e9der \u00e0 une ressource g\u00e9r\u00e9e par le noyau, par exemple pour effectuer une op\u00e9ration d\u2019entr\u00e9e/sortie, il ex\u00e9cute un appel syst\u00e8me . Le noyau ex\u00e9cute alors la fonction correspondante, apr\u00e8s avoir v\u00e9rifi\u00e9 que le programme appelant est autoris\u00e9 \u00e0 la r\u00e9aliser .","title":"Noyau (Kernel)"},{"location":"100_projets/","text":"Mini Projets : Partie Commune \u2693\ufe0e Organisation \u2693\ufe0e On va utiliser une fa\u00e7on agile de travailler, insprir\u00e9e de SCRUM, mais adapt\u00e9e \u00e0 nos besoins. Groupes \u2693\ufe0e Vous formerez des groupes de 4 . Tout le monde est DEV avec des sp\u00e9cialit\u00e9s : - Chef de projet / SCRUM Master qui g\u00e8re l\u2019\u00e9quipe + lien avec le client - Archi Soft : Respo design produit - Commercial : Respo Pitch / Vente - Admin Sys : Respo machine (Rpi si dispo) / RZO / S\u00e9cu etc \u2026 Dailys \u2693\ufe0e Ce sera des \u00ab Courlys Meetings \u00bb par mail : julien.berger1421@gmail.com . Iterations \u2693\ufe0e Chaque 8h : Le groupe doit \u00eatre capable de fournir un Incr\u00e9ment Fonctionnel . Note finale \u2693\ufe0e Livrable (Commun) (75%) + Note de R\u00f4le (25%) R\u00e8gles de bases \u2693\ufe0e On privil\u00e9giera toujours la performance On privil\u00e9giera l\u2019\u00e9conomie de ressources mat\u00e9rielles Si on est bloqu\u00e9, on trouve une solution de contournement Si l\u2019on ne parvient pas techniquement au r\u00e9sultat escompt\u00e9, on n\u00e9gocie avec le client (le prof !) On se divise les taches efficacement Tout le monde doit \u00e0 la fin, conna\u00eetre toutes les parties du projet On parle d'incr\u00e9ments fonctionnels : il vaut donc mieux rendre un programme fonctionel et sans bug, mais auquel il manque une feature, plut\u00f4t que de rendre toutes les features, mais bugg\u00e9es !! Partie commune \u2693\ufe0e Pour tous les sujets : Ajouter un user \u00ab isen \u00bb avec un groupe associ\u00e9 , un home directory , un shell etc \u2026 Cr\u00e9er un r\u00e9pertoire de travail dans le home directory de l\u2019utilisateur \u00ab isen \u00bb Le code sera fait dans ce r\u00e9pertoire en tant qu\u2019utilisateur \u00ab isen \u00bb Le code sera heberg\u00e9 sur github Le repo github sera accompagn\u00e9 d'une documention au format md A l'issue du jour 1 , vous \u00eates engag\u00e9 sur votre scope avec le client (le prof). Un document sera \u00e9crit et approuv\u00e9 des deux parties. A vous de \"rassurer\" le client tout au long du projet grace au daylies Bonus 1) Si vous avez un Raspberry Pi \u00e0 dispo : Installer Raspbian Faire toute les mises \u00e0 jours Configurer le RPi pour s\u2019y connecter en SSH en Wifi Direct (Sans passer par un r\u00e9seau Wifi tel qu\u2019une box internet ou un tel en AP) Utiliser le RPI pour hoster votre programme, tel un server en acces WIFI Direct (donc pas sur internet). 2) Documentation : Doc en ligne via github pages Bonus ++ : utiliser mkdocs material pour le theme de la doc, dans ce cas la doc sera mise \u00e0 jour on push en utilisant des github actions. Vous pouvez vous inspirer du gihtub du cours ... 3) Mise en place d'un Framework de Tests : Au choix ... 4) Surprenez moi avec des killer features !","title":"Commun"},{"location":"100_projets/#mini-projets-partie-commune","text":"","title":"Mini Projets : Partie Commune"},{"location":"100_projets/#organisation","text":"On va utiliser une fa\u00e7on agile de travailler, insprir\u00e9e de SCRUM, mais adapt\u00e9e \u00e0 nos besoins.","title":"Organisation"},{"location":"100_projets/#groupes","text":"Vous formerez des groupes de 4 . Tout le monde est DEV avec des sp\u00e9cialit\u00e9s : - Chef de projet / SCRUM Master qui g\u00e8re l\u2019\u00e9quipe + lien avec le client - Archi Soft : Respo design produit - Commercial : Respo Pitch / Vente - Admin Sys : Respo machine (Rpi si dispo) / RZO / S\u00e9cu etc \u2026","title":"Groupes"},{"location":"100_projets/#dailys","text":"Ce sera des \u00ab Courlys Meetings \u00bb par mail : julien.berger1421@gmail.com .","title":"Dailys"},{"location":"100_projets/#iterations","text":"Chaque 8h : Le groupe doit \u00eatre capable de fournir un Incr\u00e9ment Fonctionnel .","title":"Iterations"},{"location":"100_projets/#note-finale","text":"Livrable (Commun) (75%) + Note de R\u00f4le (25%)","title":"Note finale"},{"location":"100_projets/#regles-de-bases","text":"On privil\u00e9giera toujours la performance On privil\u00e9giera l\u2019\u00e9conomie de ressources mat\u00e9rielles Si on est bloqu\u00e9, on trouve une solution de contournement Si l\u2019on ne parvient pas techniquement au r\u00e9sultat escompt\u00e9, on n\u00e9gocie avec le client (le prof !) On se divise les taches efficacement Tout le monde doit \u00e0 la fin, conna\u00eetre toutes les parties du projet On parle d'incr\u00e9ments fonctionnels : il vaut donc mieux rendre un programme fonctionel et sans bug, mais auquel il manque une feature, plut\u00f4t que de rendre toutes les features, mais bugg\u00e9es !!","title":"R\u00e8gles de bases"},{"location":"100_projets/#partie-commune","text":"Pour tous les sujets : Ajouter un user \u00ab isen \u00bb avec un groupe associ\u00e9 , un home directory , un shell etc \u2026 Cr\u00e9er un r\u00e9pertoire de travail dans le home directory de l\u2019utilisateur \u00ab isen \u00bb Le code sera fait dans ce r\u00e9pertoire en tant qu\u2019utilisateur \u00ab isen \u00bb Le code sera heberg\u00e9 sur github Le repo github sera accompagn\u00e9 d'une documention au format md A l'issue du jour 1 , vous \u00eates engag\u00e9 sur votre scope avec le client (le prof). Un document sera \u00e9crit et approuv\u00e9 des deux parties. A vous de \"rassurer\" le client tout au long du projet grace au daylies Bonus 1) Si vous avez un Raspberry Pi \u00e0 dispo : Installer Raspbian Faire toute les mises \u00e0 jours Configurer le RPi pour s\u2019y connecter en SSH en Wifi Direct (Sans passer par un r\u00e9seau Wifi tel qu\u2019une box internet ou un tel en AP) Utiliser le RPI pour hoster votre programme, tel un server en acces WIFI Direct (donc pas sur internet). 2) Documentation : Doc en ligne via github pages Bonus ++ : utiliser mkdocs material pour le theme de la doc, dans ce cas la doc sera mise \u00e0 jour on push en utilisant des github actions. Vous pouvez vous inspirer du gihtub du cours ... 3) Mise en place d'un Framework de Tests : Au choix ... 4) Surprenez moi avec des killer features !","title":"Partie commune"},{"location":"100_projets_sujet1/","text":"Mini Projets : Sujet 1 - Reveil \u2693\ufe0e Sujet 1 - R\u00e9veil \u2693\ufe0e C'est le sujet le plus facile ... les notations seront donc tr\u00e8s exigentes ! On veut cr\u00e9er un Logiciel sur plusieurs programmes Un programme (processus) principal qui attends les commandes de l\u2019utilisateur Un processus fils (toujours pr\u00e9sent) compte le temps d\u2019ex\u00e9cution du logiciel depuis son lancement et le stock dans un fichier quand on quitte le programme Selon les commandes re\u00e7ue dans le processus principal , on lance N processus fils en parall\u00e8le - R\u00e9veil : qui sonne \u00e0 l\u2019heure donn\u00e9e en param\u00e8tre (surprenez moi) - Chronom\u00e8tre : qui peut stocker trois temps interm\u00e9diaires sur \u00e9v\u00e9nement clavier - Compte \u00e0 rebours : avec 2 temps de sonneries interm\u00e9diaires configurables - Statistiques d\u2019utilisation du logiciel (libre) - Monitoring des processus du logiciel (statique (--) / dynamique (++)) Le processus principal n\u2019est jamais bloqu\u00e9 Les processus fils sont lanc\u00e9s dans des terminaux distincts Le programme final doit pouvoir \u00eatre utilis\u00e9 n\u2019importe ou, sur n\u2019importe quelle machine. Automatisez le r\u00e9veil pour qu\u2019il sonne tous les matins \u00e0 heure fixe Iterations \u2693\ufe0e Il est de la responsabilit\u00e9 de l'\u00e9quipe de se committer sur une RoadMap des it\u00e9rations avec le prof lors du premier cours !","title":"Sujet 1 - Reveil"},{"location":"100_projets_sujet1/#mini-projets-sujet-1-reveil","text":"","title":"Mini Projets : Sujet 1 - Reveil"},{"location":"100_projets_sujet1/#sujet-1-reveil","text":"C'est le sujet le plus facile ... les notations seront donc tr\u00e8s exigentes ! On veut cr\u00e9er un Logiciel sur plusieurs programmes Un programme (processus) principal qui attends les commandes de l\u2019utilisateur Un processus fils (toujours pr\u00e9sent) compte le temps d\u2019ex\u00e9cution du logiciel depuis son lancement et le stock dans un fichier quand on quitte le programme Selon les commandes re\u00e7ue dans le processus principal , on lance N processus fils en parall\u00e8le - R\u00e9veil : qui sonne \u00e0 l\u2019heure donn\u00e9e en param\u00e8tre (surprenez moi) - Chronom\u00e8tre : qui peut stocker trois temps interm\u00e9diaires sur \u00e9v\u00e9nement clavier - Compte \u00e0 rebours : avec 2 temps de sonneries interm\u00e9diaires configurables - Statistiques d\u2019utilisation du logiciel (libre) - Monitoring des processus du logiciel (statique (--) / dynamique (++)) Le processus principal n\u2019est jamais bloqu\u00e9 Les processus fils sont lanc\u00e9s dans des terminaux distincts Le programme final doit pouvoir \u00eatre utilis\u00e9 n\u2019importe ou, sur n\u2019importe quelle machine. Automatisez le r\u00e9veil pour qu\u2019il sonne tous les matins \u00e0 heure fixe","title":"Sujet 1 - R\u00e9veil"},{"location":"100_projets_sujet1/#iterations","text":"Il est de la responsabilit\u00e9 de l'\u00e9quipe de se committer sur une RoadMap des it\u00e9rations avec le prof lors du premier cours !","title":"Iterations"},{"location":"100_projets_sujet2/","text":"Mini Projets : Sujet 2 - Server Q&A \u2693\ufe0e Sujet 2 \u2013 Serveur Q&A \u2693\ufe0e Ce sujet est un peu plus complexe, c'est pourquoi un template d'it\u00e9ration (qui force un peu l'archi) est d\u00e9j\u00e0 \u00e9tabli. Charge \u00e0 l'\u00e9quipe de les ajuster \u00e0 leur comp\u00e9tences afin d'arriver \u00e0 un accord avec son client (le prof). It\u00e9ration 1 \u2693\ufe0e Un processus server active un client sur une autre console Les 2 processus se parlent via un pipe nomm\u00e9 dont le nom est pass\u00e9 en param\u00e8tre au fils Le processus serveur est en \u00e9coute sur le pipe Le processus client lit des caract\u00e8res tap\u00e9s au clavier et les \u00e9crit dans le pipe Quand le combo control + D ( EOF ) est tap\u00e9 au clavier , le client se termine Le processus serveur ne se termine pas , il est toujours en attente d\u2019un client \u00e9ventuel On peut relancer un client manuellement en lui donnant le nom du pipe et le logiciel fonctionne de nouveau. Le processus serveur affiche les donn\u00e9es re\u00e7ues pr\u00e9c\u00e9d\u00e9es du PID du client. It\u00e9ration 2 \u2693\ufe0e Le programme server prends maintenant 2 param\u00e8tres Le nom du pipe Le nombre N de clients Au d\u00e9marrage il instancie N clients qui peuvent lui parler ( 1 client = 1 shell ) Des clients peuvent \u00eatre cr\u00e9es manuellement en plus par la suite On prot\u00e8ge la mort du server par CTRL+C Le serveur sait r\u00e9pondre \u00e0 des questions basiques des clients (fix\u00e9es) : - Q : Qui suis-je ? -> R : Ecrit le PID du demandeur - Q : Qui es tu ? -> R : Je suis le serveur de PID 12234 - Q : Qui est la ? -> R : liste des clients - \u2026. It\u00e9ration 3 \u2693\ufe0e Imaginez un serveur multiprocessus / multi thread\u00e9 o\u00f9 le serveur, d\u00e8s qu\u2019il re\u00e7oit une demande, la passe \u00e0 un processus qui la g\u00e8re. Comme cela il peut boucler et g\u00e9rer d\u2019autres demandes entrantes.","title":"Sujet 2 - Server Q&A"},{"location":"100_projets_sujet2/#mini-projets-sujet-2-server-qa","text":"","title":"Mini Projets : Sujet 2 - Server Q&amp;A"},{"location":"100_projets_sujet2/#sujet-2-serveur-qa","text":"Ce sujet est un peu plus complexe, c'est pourquoi un template d'it\u00e9ration (qui force un peu l'archi) est d\u00e9j\u00e0 \u00e9tabli. Charge \u00e0 l'\u00e9quipe de les ajuster \u00e0 leur comp\u00e9tences afin d'arriver \u00e0 un accord avec son client (le prof).","title":"Sujet 2 \u2013 Serveur Q&amp;A"},{"location":"100_projets_sujet2/#iteration-1","text":"Un processus server active un client sur une autre console Les 2 processus se parlent via un pipe nomm\u00e9 dont le nom est pass\u00e9 en param\u00e8tre au fils Le processus serveur est en \u00e9coute sur le pipe Le processus client lit des caract\u00e8res tap\u00e9s au clavier et les \u00e9crit dans le pipe Quand le combo control + D ( EOF ) est tap\u00e9 au clavier , le client se termine Le processus serveur ne se termine pas , il est toujours en attente d\u2019un client \u00e9ventuel On peut relancer un client manuellement en lui donnant le nom du pipe et le logiciel fonctionne de nouveau. Le processus serveur affiche les donn\u00e9es re\u00e7ues pr\u00e9c\u00e9d\u00e9es du PID du client.","title":"It\u00e9ration 1"},{"location":"100_projets_sujet2/#iteration-2","text":"Le programme server prends maintenant 2 param\u00e8tres Le nom du pipe Le nombre N de clients Au d\u00e9marrage il instancie N clients qui peuvent lui parler ( 1 client = 1 shell ) Des clients peuvent \u00eatre cr\u00e9es manuellement en plus par la suite On prot\u00e8ge la mort du server par CTRL+C Le serveur sait r\u00e9pondre \u00e0 des questions basiques des clients (fix\u00e9es) : - Q : Qui suis-je ? -> R : Ecrit le PID du demandeur - Q : Qui es tu ? -> R : Je suis le serveur de PID 12234 - Q : Qui est la ? -> R : liste des clients - \u2026.","title":"It\u00e9ration 2"},{"location":"100_projets_sujet2/#iteration-3","text":"Imaginez un serveur multiprocessus / multi thread\u00e9 o\u00f9 le serveur, d\u00e8s qu\u2019il re\u00e7oit une demande, la passe \u00e0 un processus qui la g\u00e8re. Comme cela il peut boucler et g\u00e9rer d\u2019autres demandes entrantes.","title":"It\u00e9ration 3"},{"location":"100_projets_sujet3/","text":"Mini Projets : Sujet 3 - Equipes de Processus \u2693\ufe0e C'est le sujet le plus difficile ... mais aussi le plus interessant ! A vous de cr\u00e9er les iterations selon l'architecture choisie, et de s'engager sur la RoadMap avec votre client (le prof). Sujet 3 : Equipes de processus \u2693\ufe0e L'objectif est de cr\u00e9er 2 \u00e9quipes de processus , chacune compos\u00e9e d'un processus p\u00e8re et de 5 sous processus . Chaque sous-processus doit \u00e9crire dans un fichier son PID en binaire, et son PPID. Les fichiers sont num\u00e9rot\u00e9s de 0000 \u00e0 9999. Le processus p\u00e8re envoie \u00e0 ses sous-processus le num\u00e9ro de fichier \u00e0 conqu\u00e9rir. Le processus p\u00e8re est soumis \u00e0 une tempo de 20s. En outre, si un processus de l'autre equipe ouvre un fichier deja conquis par l'autre equipe, il recup\u00e8re le pid de l'adversaire et le tue via SIG_QUIT . La partie s'arr\u00eate quand tous les processus d'une \u00e9quipe sont morts. Enfin, un programme qui compte les points par equipe devra \u00eatre mis \u00e0 disposition.... Ce comptage de point est persistant, est est recharg\u00e9 \u00e0 chaque d\u00e9marrage du programme. Un programme ou plusieurs programmes distincts : archi libre ! A vous de justifier vos choix. Iterations \u2693\ufe0e Il est de la responsabilit\u00e9 de l'\u00e9quipe de se committer sur une RoadMap des it\u00e9rations avec le prof lors du premier cours !","title":"Sujet 3 - Equipes de Processus"},{"location":"100_projets_sujet3/#mini-projets-sujet-3-equipes-de-processus","text":"C'est le sujet le plus difficile ... mais aussi le plus interessant ! A vous de cr\u00e9er les iterations selon l'architecture choisie, et de s'engager sur la RoadMap avec votre client (le prof).","title":"Mini Projets : Sujet 3 - Equipes de Processus"},{"location":"100_projets_sujet3/#sujet-3-equipes-de-processus","text":"L'objectif est de cr\u00e9er 2 \u00e9quipes de processus , chacune compos\u00e9e d'un processus p\u00e8re et de 5 sous processus . Chaque sous-processus doit \u00e9crire dans un fichier son PID en binaire, et son PPID. Les fichiers sont num\u00e9rot\u00e9s de 0000 \u00e0 9999. Le processus p\u00e8re envoie \u00e0 ses sous-processus le num\u00e9ro de fichier \u00e0 conqu\u00e9rir. Le processus p\u00e8re est soumis \u00e0 une tempo de 20s. En outre, si un processus de l'autre equipe ouvre un fichier deja conquis par l'autre equipe, il recup\u00e8re le pid de l'adversaire et le tue via SIG_QUIT . La partie s'arr\u00eate quand tous les processus d'une \u00e9quipe sont morts. Enfin, un programme qui compte les points par equipe devra \u00eatre mis \u00e0 disposition.... Ce comptage de point est persistant, est est recharg\u00e9 \u00e0 chaque d\u00e9marrage du programme. Un programme ou plusieurs programmes distincts : archi libre ! A vous de justifier vos choix.","title":"Sujet 3 : Equipes de processus"},{"location":"100_projets_sujet3/#iterations","text":"Il est de la responsabilit\u00e9 de l'\u00e9quipe de se committer sur une RoadMap des it\u00e9rations avec le prof lors du premier cours !","title":"Iterations"},{"location":"100_projets_sujet_custom/","text":"Mini Projets - Sujets Customs \u2693\ufe0e Sujets Custom \u2693\ufe0e Chat RZO via des sockets : la premi\u00e8re it\u00e9ration peut \u00eatre local only et utiliser des pipes \u00e0 la place des socket . Cr\u00e9er une interface utilisateur (GUI) permettant de contr\u00f4ler un programme en ligne de commande (qui utilise donc stdin, stdout et stderr pour communiquer avec l'ext\u00e9rieur). En effet, si on peut contr\u00f4ler l'entr\u00e9e (stdin) et la sortie (stdout, stderr) d'un programme en l'encapsulant dans un autre programme p\u00e8re, on peut tout faire avec ! Par exemple un wrapper graphique de commande bash complexes ?","title":"Sujets Custom"},{"location":"100_projets_sujet_custom/#mini-projets-sujets-customs","text":"","title":"Mini Projets - Sujets Customs"},{"location":"100_projets_sujet_custom/#sujets-custom","text":"Chat RZO via des sockets : la premi\u00e8re it\u00e9ration peut \u00eatre local only et utiliser des pipes \u00e0 la place des socket . Cr\u00e9er une interface utilisateur (GUI) permettant de contr\u00f4ler un programme en ligne de commande (qui utilise donc stdin, stdout et stderr pour communiquer avec l'ext\u00e9rieur). En effet, si on peut contr\u00f4ler l'entr\u00e9e (stdin) et la sortie (stdout, stderr) d'un programme en l'encapsulant dans un autre programme p\u00e8re, on peut tout faire avec ! Par exemple un wrapper graphique de commande bash complexes ?","title":"Sujets Custom"},{"location":"20_linuxshell/","text":"Pourquoi UNIX ? \u2693\ufe0e Bonnes raisons \u2693\ufe0e De plus en plus r\u00e9pandu en entreprise Incontournable sur le syst\u00e8mes TR Certaines utilisations n\u00e9cessitent des contraintes de production fortes telles que : la disponibilit\u00e9 (pas de reboot, pas d'arr\u00eat) la performance en charge (nombre d'utilisateurs, de processus) la p\u00e9rennit\u00e9 (car Unix est bas\u00e9 sur des standards) la stabilit\u00e9 / s\u00e9curit\u00e9 (peu de bugs syst\u00e8me) Difficult\u00e9s \u2693\ufe0e Une des principales difficult\u00e9s d'Unix est son c\u00f4t\u00e9 ligne de commande un peu d\u00e9mod\u00e9 demandant un minimum d'investissement avant de pouvoir s'en servir efficacement. Ce type d'interface reste pourtant in\u00e9gal\u00e9 depuis 30 ans ! Il existe depuis plus de dix ans des interfaces graphiques comparables au syst\u00e8me Windows. Maintenant, les environnements graphiques sous Linux n'ont rien \u00e0 envier aux syst\u00e8mes de Microsoft. Caract\u00e9ristiques \u2693\ufe0e Syst\u00e8me ouvert (pas de code propri\u00e9taire ; seules certaines impl\u00e9mentations sont propri\u00e9taires). Multi-t\u00e2ches (plusieurs programmes peuvent s'ex\u00e9cuter en m\u00eame temps, sans blocage). Multi-utilisateurs (plusieurs utilisateurs travaillent sur la m\u00eame machine en m\u00eame temps), gestion des droits. M\u00e9moire prot\u00e9g\u00e9e (pas d'interaction entre les programmes) et virtuelle (le syst\u00e8me peut utiliser plus de m\u00e9moire que la m\u00e9moire physique disponible). Interface graphique et shell (interpr\u00e9teur de commande). Plusieurs centaines d'outils (manipulation de texte, d\u00e9veloppement de logiciels, communication etc...). R\u00e9sum\u00e9 en vid\u00e9o \u2693\ufe0e Le Shell \u2693\ufe0e Comme tout syst\u00e8me d'exploitation, UNIX poss\u00e8de un Interpr\u00e9teur de Commandes (I.C.) . C'est un processus utilisateur comme les autres. Il permet : l\u2019ex\u00e9cution des programmes la manipulation des fichiers l'acc\u00e8s aux p\u00e9riph\u00e9riques de l\u2019ordinateur l'automatisation des proc\u00e9dures par fichiers de commandes (scripts en langage Shell) ... Ce \"logiciel d'interface\" fournit \u00e0 l'utilisateur un ensemble de commandes qui lui permettent de \"dialoguer\" avec le syst\u00e8me lui-m\u00eame, le noyau (kernel). Tip UNIX propose en standard plusieurs shell possibles : SH BASH ... Chaque shell peut \u00eatre lanc\u00e9 (activ\u00e9) par sa commande \u00e9quivalente (bsh, ksh, csh). Par d\u00e9faut l'utilisateur lorsqu'il se connecte se retrouve automatiquement dans l'un de ces shell, il a donc un login -shell, configur\u00e9 dans le fichier /etc/passwd Le shell est donc un pseudo langage qui : interpr\u00e8te vos commandes d\u00e9termine les fichiers responsables de la mise en place de votre environnement Warning En BASH, le fichier de configuration du terminal est ~/.bashrc ou ~/.bash_profile Tip Il se nomme ainsi (coquille) car il enveloppe le noyau Unix, toutes les commandes sont pass\u00e9es au noyau \u00e0 travers votre shell. Le Home Directory : ~ \u2693\ufe0e Vous \u00eates sous votre HOME quand vous \u00eates sous /home/ your_login C'est un espace disque qui vous appartient, \u00e0 vous et \u00e0 vous seul (voir \"droits\"). Normalement vous pouvez \u00e9crire et lire tous les fichiers qui s'y trouvent. Vous \u00eates responsable de tout ce qui s'y passe (piratage, saturation des espaces disques, etc...). Notion de comptes utilisateur \u2693\ufe0e Pour chaque compte vous avez : un login (uid) un mot de passe associ\u00e9 un groupe (gid) un home directory (r\u00e9pertoire de travail) un langage de commandes (shell) Tip Dans un syst\u00e8me UNIX, ces infos sont regroup\u00e9es dans deux fichiers : 1 2 3 cat /etc/passwd cat /etc/group Connexions \u2693\ufe0e Locale \u2693\ufe0e D\u00e8s que vous \u00eates en local, vous pouvez saisir votre login puis votre password sur l'\u00e9cran (attention unix est \u00ab case sensitive \u00bb). Deux cas peuvent arriver : Soit un \u00e9cran noir avec un simple prompt \">\" Soit un environnement graphique avec une gestion de la souris et des fen\u00eatres suffisamment explicites pour d\u00e9marrer. Warning Pour sortir d'une session, il est imp\u00e9ratif d'utiliser les proc\u00e9dures de d\u00e9connexion. En effet, Unix (comme d'autres syst\u00e8mes) a besoin de sauvegarder certaines donn\u00e9es (flush des buffers lors de la fermeture des fichiers), d\u00e9montage des disques pour forcer une mise \u00e0 jour des fichiers syst\u00e8mes, etc. Aussi si vous faites un \"power off\" d'une machine Unix, vous risquez d'endommager les fichiers sur les disques. Vous devez faire un exit pour revenir \u00e0 la fen\u00eatre primaire, puis \u00e9ventuellement un halt pour arr\u00eater le syst\u00e8me (si vous \u00eates autoris\u00e9 \u00e0 le faire). Distante \u2693\ufe0e Pour la connexion \u00e0 distance, vous avez bien s\u00fbr besoin d'\u00eatre d\u00e9j\u00e0 sur un ordinateur Unix/Windows ou autre et d'\u00e9tablir un lien vers la machine Unix cible. Chaque type de connexion d\u00e9pend de la plate-forme d'origine. La plus r\u00e9pandue est SSH , mais on trouve encore du telnet . Tip Les outils le splus connus de SSH sont \"PuTTY\" et \"MobaXterm\".","title":"UNIX"},{"location":"20_linuxshell/#pourquoi-unix","text":"","title":"Pourquoi UNIX ?"},{"location":"20_linuxshell/#bonnes-raisons","text":"De plus en plus r\u00e9pandu en entreprise Incontournable sur le syst\u00e8mes TR Certaines utilisations n\u00e9cessitent des contraintes de production fortes telles que : la disponibilit\u00e9 (pas de reboot, pas d'arr\u00eat) la performance en charge (nombre d'utilisateurs, de processus) la p\u00e9rennit\u00e9 (car Unix est bas\u00e9 sur des standards) la stabilit\u00e9 / s\u00e9curit\u00e9 (peu de bugs syst\u00e8me)","title":"Bonnes raisons"},{"location":"20_linuxshell/#difficultes","text":"Une des principales difficult\u00e9s d'Unix est son c\u00f4t\u00e9 ligne de commande un peu d\u00e9mod\u00e9 demandant un minimum d'investissement avant de pouvoir s'en servir efficacement. Ce type d'interface reste pourtant in\u00e9gal\u00e9 depuis 30 ans ! Il existe depuis plus de dix ans des interfaces graphiques comparables au syst\u00e8me Windows. Maintenant, les environnements graphiques sous Linux n'ont rien \u00e0 envier aux syst\u00e8mes de Microsoft.","title":"Difficult\u00e9s"},{"location":"20_linuxshell/#caracteristiques","text":"Syst\u00e8me ouvert (pas de code propri\u00e9taire ; seules certaines impl\u00e9mentations sont propri\u00e9taires). Multi-t\u00e2ches (plusieurs programmes peuvent s'ex\u00e9cuter en m\u00eame temps, sans blocage). Multi-utilisateurs (plusieurs utilisateurs travaillent sur la m\u00eame machine en m\u00eame temps), gestion des droits. M\u00e9moire prot\u00e9g\u00e9e (pas d'interaction entre les programmes) et virtuelle (le syst\u00e8me peut utiliser plus de m\u00e9moire que la m\u00e9moire physique disponible). Interface graphique et shell (interpr\u00e9teur de commande). Plusieurs centaines d'outils (manipulation de texte, d\u00e9veloppement de logiciels, communication etc...).","title":"Caract\u00e9ristiques"},{"location":"20_linuxshell/#resume-en-video","text":"","title":"R\u00e9sum\u00e9 en vid\u00e9o"},{"location":"20_linuxshell/#le-shell","text":"Comme tout syst\u00e8me d'exploitation, UNIX poss\u00e8de un Interpr\u00e9teur de Commandes (I.C.) . C'est un processus utilisateur comme les autres. Il permet : l\u2019ex\u00e9cution des programmes la manipulation des fichiers l'acc\u00e8s aux p\u00e9riph\u00e9riques de l\u2019ordinateur l'automatisation des proc\u00e9dures par fichiers de commandes (scripts en langage Shell) ... Ce \"logiciel d'interface\" fournit \u00e0 l'utilisateur un ensemble de commandes qui lui permettent de \"dialoguer\" avec le syst\u00e8me lui-m\u00eame, le noyau (kernel). Tip UNIX propose en standard plusieurs shell possibles : SH BASH ... Chaque shell peut \u00eatre lanc\u00e9 (activ\u00e9) par sa commande \u00e9quivalente (bsh, ksh, csh). Par d\u00e9faut l'utilisateur lorsqu'il se connecte se retrouve automatiquement dans l'un de ces shell, il a donc un login -shell, configur\u00e9 dans le fichier /etc/passwd Le shell est donc un pseudo langage qui : interpr\u00e8te vos commandes d\u00e9termine les fichiers responsables de la mise en place de votre environnement Warning En BASH, le fichier de configuration du terminal est ~/.bashrc ou ~/.bash_profile Tip Il se nomme ainsi (coquille) car il enveloppe le noyau Unix, toutes les commandes sont pass\u00e9es au noyau \u00e0 travers votre shell.","title":"Le Shell"},{"location":"20_linuxshell/#le-home-directory","text":"Vous \u00eates sous votre HOME quand vous \u00eates sous /home/ your_login C'est un espace disque qui vous appartient, \u00e0 vous et \u00e0 vous seul (voir \"droits\"). Normalement vous pouvez \u00e9crire et lire tous les fichiers qui s'y trouvent. Vous \u00eates responsable de tout ce qui s'y passe (piratage, saturation des espaces disques, etc...).","title":"Le Home Directory : ~"},{"location":"20_linuxshell/#notion-de-comptes-utilisateur","text":"Pour chaque compte vous avez : un login (uid) un mot de passe associ\u00e9 un groupe (gid) un home directory (r\u00e9pertoire de travail) un langage de commandes (shell) Tip Dans un syst\u00e8me UNIX, ces infos sont regroup\u00e9es dans deux fichiers : 1 2 3 cat /etc/passwd cat /etc/group","title":"Notion de comptes utilisateur"},{"location":"20_linuxshell/#connexions","text":"","title":"Connexions"},{"location":"20_linuxshell/#locale","text":"D\u00e8s que vous \u00eates en local, vous pouvez saisir votre login puis votre password sur l'\u00e9cran (attention unix est \u00ab case sensitive \u00bb). Deux cas peuvent arriver : Soit un \u00e9cran noir avec un simple prompt \">\" Soit un environnement graphique avec une gestion de la souris et des fen\u00eatres suffisamment explicites pour d\u00e9marrer. Warning Pour sortir d'une session, il est imp\u00e9ratif d'utiliser les proc\u00e9dures de d\u00e9connexion. En effet, Unix (comme d'autres syst\u00e8mes) a besoin de sauvegarder certaines donn\u00e9es (flush des buffers lors de la fermeture des fichiers), d\u00e9montage des disques pour forcer une mise \u00e0 jour des fichiers syst\u00e8mes, etc. Aussi si vous faites un \"power off\" d'une machine Unix, vous risquez d'endommager les fichiers sur les disques. Vous devez faire un exit pour revenir \u00e0 la fen\u00eatre primaire, puis \u00e9ventuellement un halt pour arr\u00eater le syst\u00e8me (si vous \u00eates autoris\u00e9 \u00e0 le faire).","title":"Locale"},{"location":"20_linuxshell/#distante","text":"Pour la connexion \u00e0 distance, vous avez bien s\u00fbr besoin d'\u00eatre d\u00e9j\u00e0 sur un ordinateur Unix/Windows ou autre et d'\u00e9tablir un lien vers la machine Unix cible. Chaque type de connexion d\u00e9pend de la plate-forme d'origine. La plus r\u00e9pandue est SSH , mais on trouve encore du telnet . Tip Les outils le splus connus de SSH sont \"PuTTY\" et \"MobaXterm\".","title":"Distante"},{"location":"21_cmdshell/","text":"Th\u00e9orie des commandes \u2693\ufe0e Structure \u2693\ufe0e Un commande est en fait un programme compil\u00e9 , souvent en C, accessible partout dans l'OS. Comme tout programme classique, il peut recevoir des param\u00e8tres de l'ext\u00e9rieur. Dans l'IC, on a cette structure 1 nom_de_la_commande param1 param2 param3 ... Tip La commande est chacun de ses param\u00e8tres sont s\u00e9par\u00e9es par des ESPACES Gestion des Flux \u2693\ufe0e Th\u00e9orie \u2693\ufe0e Exemples \u2693\ufe0e 1 2 3 4 5 6 7 8 9 10 11 cat < toto ls > dir.txt ls >> dir.txt rm * 2 > erreur.log rm * 2 >> erreur.log ps \u2013ef | grep toto R\u00e9sum\u00e9 \u2693\ufe0e O\u00f9 trouver l'information ? \u2693\ufe0e Quand on a acc\u00e8s \u00e0 internet, la meilleure source et la plus rapide : Google ! Sinon, n'hesitez pas \u00e0 utiliser la commande man nom_de_la_commande qui d\u00e9crit pr\u00e9cisement toutes les possibilit\u00e9s d'une commande. Tip Les pages manquantes d'un manuel peuvent \u00eatre ajout\u00e9es... On peut aussi traduire le man en fran\u00e7ais","title":"Commandes Shell"},{"location":"21_cmdshell/#theorie-des-commandes","text":"","title":"Th\u00e9orie des commandes"},{"location":"21_cmdshell/#structure","text":"Un commande est en fait un programme compil\u00e9 , souvent en C, accessible partout dans l'OS. Comme tout programme classique, il peut recevoir des param\u00e8tres de l'ext\u00e9rieur. Dans l'IC, on a cette structure 1 nom_de_la_commande param1 param2 param3 ... Tip La commande est chacun de ses param\u00e8tres sont s\u00e9par\u00e9es par des ESPACES","title":"Structure"},{"location":"21_cmdshell/#gestion-des-flux","text":"","title":"Gestion des Flux"},{"location":"21_cmdshell/#theorie","text":"","title":"Th\u00e9orie"},{"location":"21_cmdshell/#exemples","text":"1 2 3 4 5 6 7 8 9 10 11 cat < toto ls > dir.txt ls >> dir.txt rm * 2 > erreur.log rm * 2 >> erreur.log ps \u2013ef | grep toto","title":"Exemples"},{"location":"21_cmdshell/#resume","text":"","title":"R\u00e9sum\u00e9"},{"location":"21_cmdshell/#ou-trouver-linformation","text":"Quand on a acc\u00e8s \u00e0 internet, la meilleure source et la plus rapide : Google ! Sinon, n'hesitez pas \u00e0 utiliser la commande man nom_de_la_commande qui d\u00e9crit pr\u00e9cisement toutes les possibilit\u00e9s d'une commande. Tip Les pages manquantes d'un manuel peuvent \u00eatre ajout\u00e9es... On peut aussi traduire le man en fran\u00e7ais","title":"O\u00f9 trouver l'information ?"},{"location":"22_tpShell/","text":"TP Commandes Linux \u2693\ufe0e Objectifs \u2693\ufe0e Le second objectif du cours est de maitriser les bases du Shell Unix , via un TP. Exercice 1 : Variables d\u2019environnements \u2693\ufe0e Afficher l\u2019ensemble de vos variables d\u2019environnement. Afficher le contenu de la variable PATH. Donner la signification de PATH, PS1, HOME, et TERM Exercice 2 : Initiation aux commandes de base d'Unix \u2693\ufe0e Tip Ne pas oublier que le descriptif des commandes est disponible en utilisant le manuel (commande man). Pour savoir o\u00f9 se trouve un fichier ou commande = whereis, which, apropos Utilisation des commandes : alias et unalias \u2693\ufe0e Quels sont les alias pr\u00e9sents sur votre machine ? Cr\u00e9er un alias lu qui r\u00e9alise la commande ls -lrt Utiliser cet alias Supprimer cet alias Utilisation des commandes : mkdir, rm, cd, cp, mv, touch, chmod, pwd \u2693\ufe0e Cr\u00e9er, dans votre environnement de travail ( /home/ username ), l\u2019arborescence de dossiers suivante : (Bonus : en une seule commande !) 1 2 3 4 5 6 7 8 9 10 11 . ` -- SE | -- TP1 | | -- delivery | | -- dpc | ` -- script ` -- TP2 | -- bin | -- inc | -- obj ` -- src Installer la commande tree qui permet d'afficher l'arborescence ci-dessus Tip Pour afficher les droits, users et groups avec tree : tree -ugp Afficher son r\u00e9pertoire courant Cr\u00e9er le fichier bonjour.c sous SE/TP2/src contenant les lignes suivantes : (En utilisant un editeur en ligne de commande ou graphique, au choix) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // directive du pr\u00e9processeur #include <stdio.h> /* prototype des fonctions */ /* programme principal */ int main () { printf ( \"Bonjour \\n \" ) ; /* 0100123456123 0100123457123 0100123458123 0100123459123 0100123450123 0100123451123 0100123451123 */ } D\u00e9placer vous sous votre home directory et cr\u00e9er le fichier vide config.txt D\u00e9placer vous par un d\u00e9placement absolu sous le r\u00e9pertoire src et compiler le programme bonjour.c en un programme ex\u00e9cutable bonjour . Le r\u00e9sultat de la compilation est d\u00e9plac\u00e9 sous bin . Afficher les types des fichiers bonjour et bonjour.c D\u00e9placez vous par un d\u00e9placement relatif sous TP2/bin Modifier les droits du fichier bonjour afin qu\u2019il soit : en lecture, \u00e9criture, ex\u00e9cution pour le owner en lecture, ex\u00e9cution pour le groupe et non accessible pour les autres. D\u00e9placez vous sous votre home directory et modifiez de fa\u00e7on r\u00e9cursive l\u2019ensemble des droits (directories + fichiers) de TP2 selon les conditions de la question pr\u00e9c\u00e9dente. Tip Vous pouvez v\u00e9rifier avec la commande tree -p Copier le fichier bonjour.c en salut.c en local. Tip Pour faire une copie locale il faut etre dans le repertoire concern\u00e9, et copier au m\u00eame endroit. Copier le r\u00e9pertoire TP2 en TP3 avec l\u2019ensemble de ses fichiers D\u00e9placer le fichier salut.c de TP3 dans SE/TP2/src en l\u2019appelant salut1.c Effacer le fichier bonjour.c de TP3 Effacer TP3 Utilisation des commandes : chmod, chown, chgrp, ls, ln \u2693\ufe0e Changer le owner du fichier TP2/src/salut.c par n'importe quel autre utilisateur pr\u00e9sent sur votre machine, monitorer le r\u00e9sultat Tip Pour connaitre les users disponible, allez voir le contenu du fichier /etc/passwd avec la command cat Filtrer les users qui possedent un home directory dans /home cat /etc/passwd | grep home Changer le groupe de ce fichier par un groupe connu sur la machine Tip Pour connaitre les groupes disponible, allez voir le contenu du fichier /etc/group avec la command cat cat /etc/group Changer en une seule commande le owner et goupe de TP2 et des fichiers qu\u2019il contient pour vous les redonner Tip Utilisez la commande id pour connaitre votre user:groupe Se positionner sur son home directory et cr\u00e9er un lien symbolique vers le fichier salut.c de TP2 Editer ce lien. Expliquer la diff\u00e9rence entre un lien permanent et un lien symbolique. Monitoring disques \u2693\ufe0e Quel est l\u2019espace disponible sur votre disque ? Quelles sont les partitions disques pr\u00e9sentent sur votre syst\u00e8me ? Utilisation de la commande export \u2693\ufe0e Modifier le contenu de la variable d\u2019environnement PATH afin d\u2019y ajouter le chemin absolu vers le r\u00e9pertoire TP2/bin . Warning Attention \u00e0 ne pas \u00e9craser totalement la variable PATH ! V\u00e9rifier que depuis n'importe quel folder, vous pouvez lancer bonjour de la fa\u00e7on suivante : bonjour \u21b5 V\u00e9rifiez que bonjour execute bien votre binaire avec which bonjour Modifier votre profil utilisateur afin de modifier PATH comme pr\u00e9c\u00e9demment, de mani\u00e8re permanente. Script \u2693\ufe0e D\u00e9placez vous sous SE/TP1/script et cr\u00e9er, en 1 seule commande, un fichier essai.bash contenant #!/bin/bash Ajouter \u00e0 la fin de essai.bash la ligne \u00ab ls \u2013lrt \u00bb (en une seule commande) Ex\u00e9cutez essai.bash Warning Pensez \u00e0 vous donner les droits d'execution avant ... chmod u+x essai.bash Utilisation de grep, ps, netstat,wc \u2693\ufe0e Rechercher l\u2019occurrence \u00ab include \u00bb dans le fichier bonjour.c Afficher l\u2019ensemble des processus en cours Afficher l\u2019ensemble des sockets en \u00e9tat \u2018ESTABLISHED\u2019 sur votre machine et comptez les. Utilisation de la commande find \u2693\ufe0e Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des occurrences de \u00ab printf \u00bb dans l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires Utilisation de la commande xargs \u2693\ufe0e Cr\u00e9er une sauvegarde de l\u2019ensemble des fichiers c se trouvant sous SE/TP2/src en le copiant en nom_du_fichier.c_backup Tip bonjour.c est copi\u00e9 en bonjour.c_backup Machine/user/syst\u00e8me/terminal \u2693\ufe0e Afficher qui est logg\u00e9 sur votre machine ? Afficher quel est le nom de votre machine ? Afficher quel est le nom de votre syst\u00e8me ? Afficher quel votre num\u00e9ro utilisateur et groupe ? Les Process : utilisation des commandes ps, top, jobs, CTRL^Z, fg, bg, kill \u2693\ufe0e Monitorer de mani\u00e8re dynamique l\u2019ensemble des process en cours Dans un autre terminal, lancer un process long en background, par example firefox , ou ajouter une boucle infinie au programme bonjour et utiliser `bonjour . bonjour.c 1 2 3 4 5 6 7 8 9 10 11 // directive du pr\u00e9processeur #include <stdio.h> #include <unistd.h> /* programme principal */ int main () { while ( 1 ){ printf ( \"Bonjour \\n \" ) ; sleep ( 2 ); } } Monitorer le de fa\u00e7on statique Tuer le violemment Lancer un process, l\u2019interrompre et le mettre en ex\u00e9cution en background Monitorer le Basculer ce process en foreground Stopper le par un signal d\u2019interruption Exercice 3 : Executer un script \u2693\ufe0e T\u00e9l\u00e9chargez ce script : install_env_student.sh . Verifier que vous possedez les droits d'execution sur le script. Sinon utilisez chmod ! Executez le script Verifier qu'aucune erreur ne s'est produite. Votre environnement est pret pour faire du C dans la suite du cours :)","title":"TP Linux Commands"},{"location":"22_tpShell/#tp-commandes-linux","text":"","title":"TP Commandes Linux"},{"location":"22_tpShell/#objectifs","text":"Le second objectif du cours est de maitriser les bases du Shell Unix , via un TP.","title":"Objectifs"},{"location":"22_tpShell/#exercice-1-variables-denvironnements","text":"Afficher l\u2019ensemble de vos variables d\u2019environnement. Afficher le contenu de la variable PATH. Donner la signification de PATH, PS1, HOME, et TERM","title":"Exercice 1 : Variables d\u2019environnements"},{"location":"22_tpShell/#exercice-2-initiation-aux-commandes-de-base-dunix","text":"Tip Ne pas oublier que le descriptif des commandes est disponible en utilisant le manuel (commande man). Pour savoir o\u00f9 se trouve un fichier ou commande = whereis, which, apropos","title":"Exercice 2 : Initiation aux commandes de base d'Unix"},{"location":"22_tpShell/#utilisation-des-commandes-alias-et-unalias","text":"Quels sont les alias pr\u00e9sents sur votre machine ? Cr\u00e9er un alias lu qui r\u00e9alise la commande ls -lrt Utiliser cet alias Supprimer cet alias","title":"Utilisation des commandes : alias et unalias"},{"location":"22_tpShell/#utilisation-des-commandes-mkdir-rm-cd-cp-mv-touch-chmod-pwd","text":"Cr\u00e9er, dans votre environnement de travail ( /home/ username ), l\u2019arborescence de dossiers suivante : (Bonus : en une seule commande !) 1 2 3 4 5 6 7 8 9 10 11 . ` -- SE | -- TP1 | | -- delivery | | -- dpc | ` -- script ` -- TP2 | -- bin | -- inc | -- obj ` -- src Installer la commande tree qui permet d'afficher l'arborescence ci-dessus Tip Pour afficher les droits, users et groups avec tree : tree -ugp Afficher son r\u00e9pertoire courant Cr\u00e9er le fichier bonjour.c sous SE/TP2/src contenant les lignes suivantes : (En utilisant un editeur en ligne de commande ou graphique, au choix) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // directive du pr\u00e9processeur #include <stdio.h> /* prototype des fonctions */ /* programme principal */ int main () { printf ( \"Bonjour \\n \" ) ; /* 0100123456123 0100123457123 0100123458123 0100123459123 0100123450123 0100123451123 0100123451123 */ } D\u00e9placer vous sous votre home directory et cr\u00e9er le fichier vide config.txt D\u00e9placer vous par un d\u00e9placement absolu sous le r\u00e9pertoire src et compiler le programme bonjour.c en un programme ex\u00e9cutable bonjour . Le r\u00e9sultat de la compilation est d\u00e9plac\u00e9 sous bin . Afficher les types des fichiers bonjour et bonjour.c D\u00e9placez vous par un d\u00e9placement relatif sous TP2/bin Modifier les droits du fichier bonjour afin qu\u2019il soit : en lecture, \u00e9criture, ex\u00e9cution pour le owner en lecture, ex\u00e9cution pour le groupe et non accessible pour les autres. D\u00e9placez vous sous votre home directory et modifiez de fa\u00e7on r\u00e9cursive l\u2019ensemble des droits (directories + fichiers) de TP2 selon les conditions de la question pr\u00e9c\u00e9dente. Tip Vous pouvez v\u00e9rifier avec la commande tree -p Copier le fichier bonjour.c en salut.c en local. Tip Pour faire une copie locale il faut etre dans le repertoire concern\u00e9, et copier au m\u00eame endroit. Copier le r\u00e9pertoire TP2 en TP3 avec l\u2019ensemble de ses fichiers D\u00e9placer le fichier salut.c de TP3 dans SE/TP2/src en l\u2019appelant salut1.c Effacer le fichier bonjour.c de TP3 Effacer TP3","title":"Utilisation des commandes : mkdir, rm, cd, cp, mv, touch, chmod, pwd"},{"location":"22_tpShell/#utilisation-des-commandes-chmod-chown-chgrp-ls-ln","text":"Changer le owner du fichier TP2/src/salut.c par n'importe quel autre utilisateur pr\u00e9sent sur votre machine, monitorer le r\u00e9sultat Tip Pour connaitre les users disponible, allez voir le contenu du fichier /etc/passwd avec la command cat Filtrer les users qui possedent un home directory dans /home cat /etc/passwd | grep home Changer le groupe de ce fichier par un groupe connu sur la machine Tip Pour connaitre les groupes disponible, allez voir le contenu du fichier /etc/group avec la command cat cat /etc/group Changer en une seule commande le owner et goupe de TP2 et des fichiers qu\u2019il contient pour vous les redonner Tip Utilisez la commande id pour connaitre votre user:groupe Se positionner sur son home directory et cr\u00e9er un lien symbolique vers le fichier salut.c de TP2 Editer ce lien. Expliquer la diff\u00e9rence entre un lien permanent et un lien symbolique.","title":"Utilisation des commandes : chmod, chown, chgrp, ls, ln"},{"location":"22_tpShell/#monitoring-disques","text":"Quel est l\u2019espace disponible sur votre disque ? Quelles sont les partitions disques pr\u00e9sentent sur votre syst\u00e8me ?","title":"Monitoring disques"},{"location":"22_tpShell/#utilisation-de-la-commande-export","text":"Modifier le contenu de la variable d\u2019environnement PATH afin d\u2019y ajouter le chemin absolu vers le r\u00e9pertoire TP2/bin . Warning Attention \u00e0 ne pas \u00e9craser totalement la variable PATH ! V\u00e9rifier que depuis n'importe quel folder, vous pouvez lancer bonjour de la fa\u00e7on suivante : bonjour \u21b5 V\u00e9rifiez que bonjour execute bien votre binaire avec which bonjour Modifier votre profil utilisateur afin de modifier PATH comme pr\u00e9c\u00e9demment, de mani\u00e8re permanente.","title":"Utilisation de la commande export"},{"location":"22_tpShell/#script","text":"D\u00e9placez vous sous SE/TP1/script et cr\u00e9er, en 1 seule commande, un fichier essai.bash contenant #!/bin/bash Ajouter \u00e0 la fin de essai.bash la ligne \u00ab ls \u2013lrt \u00bb (en une seule commande) Ex\u00e9cutez essai.bash Warning Pensez \u00e0 vous donner les droits d'execution avant ... chmod u+x essai.bash","title":"Script"},{"location":"22_tpShell/#utilisation-de-grep-ps-netstatwc","text":"Rechercher l\u2019occurrence \u00ab include \u00bb dans le fichier bonjour.c Afficher l\u2019ensemble des processus en cours Afficher l\u2019ensemble des sockets en \u00e9tat \u2018ESTABLISHED\u2019 sur votre machine et comptez les.","title":"Utilisation de grep, ps, netstat,wc"},{"location":"22_tpShell/#utilisation-de-la-commande-find","text":"Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des occurrences de \u00ab printf \u00bb dans l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires","title":"Utilisation de la commande find"},{"location":"22_tpShell/#utilisation-de-la-commande-xargs","text":"Cr\u00e9er une sauvegarde de l\u2019ensemble des fichiers c se trouvant sous SE/TP2/src en le copiant en nom_du_fichier.c_backup Tip bonjour.c est copi\u00e9 en bonjour.c_backup","title":"Utilisation de la commande xargs"},{"location":"22_tpShell/#machineusersystemeterminal","text":"Afficher qui est logg\u00e9 sur votre machine ? Afficher quel est le nom de votre machine ? Afficher quel est le nom de votre syst\u00e8me ? Afficher quel votre num\u00e9ro utilisateur et groupe ?","title":"Machine/user/syst\u00e8me/terminal"},{"location":"22_tpShell/#les-process-utilisation-des-commandes-ps-top-jobs-ctrlz-fg-bg-kill","text":"Monitorer de mani\u00e8re dynamique l\u2019ensemble des process en cours Dans un autre terminal, lancer un process long en background, par example firefox , ou ajouter une boucle infinie au programme bonjour et utiliser `bonjour . bonjour.c 1 2 3 4 5 6 7 8 9 10 11 // directive du pr\u00e9processeur #include <stdio.h> #include <unistd.h> /* programme principal */ int main () { while ( 1 ){ printf ( \"Bonjour \\n \" ) ; sleep ( 2 ); } } Monitorer le de fa\u00e7on statique Tuer le violemment Lancer un process, l\u2019interrompre et le mettre en ex\u00e9cution en background Monitorer le Basculer ce process en foreground Stopper le par un signal d\u2019interruption","title":"Les Process : utilisation des commandes ps, top, jobs, CTRL^Z, fg, bg, kill"},{"location":"22_tpShell/#exercice-3-executer-un-script","text":"T\u00e9l\u00e9chargez ce script : install_env_student.sh . Verifier que vous possedez les droits d'execution sur le script. Sinon utilisez chmod ! Executez le script Verifier qu'aucune erreur ne s'est produite. Votre environnement est pret pour faire du C dans la suite du cours :)","title":"Exercice 3 : Executer un script"},{"location":"22_tpShell_corr/","text":"TP Commandes Linux \u2693\ufe0e Objectifs \u2693\ufe0e Le second objectif du cours est de maitriser les bases du Shell Unix , via un TP. Exercice 1 : Variables d\u2019environnements \u2693\ufe0e Afficher l\u2019ensemble de vos variables d\u2019environnement. Solution 1 env Afficher le contenu de la variable PATH. Solution 1 echo $PATH Donner la signification de PATH, PS1, HOME, et TERM Solution PATH : Liste des chemins (absolus) des dossiers contenant des binaires (executables). PS1 : Aspect du Prompt principal. HOME : Chemin du Home Directory de l'utilisateur courant. TERM : Type de terminal en cours d'usage pour l'utilisateur courant. Exercice 2 : Initiation aux commandes de base d'Unix \u2693\ufe0e Tip Ne pas oublier que le descriptif des commandes est disponible en utilisant le manuel (commande man). Pour savoir o\u00f9 se trouve un fichier ou commande = whereis, which, apropos Utilisation des commandes : alias et unalias \u2693\ufe0e Quels sont les alias pr\u00e9sents sur votre machine ? Solution 1 alias Cr\u00e9er un alias lu qui r\u00e9alise la commande ls -lrt Solution 1 alias lu = 'ls -lrt' Utiliser cet alias Solution 1 lu Supprimer cet alias Solution 1 unalias lu Utilisation des commandes : mkdir, rm, cd, cp, mv, touch, chmod, pwd \u2693\ufe0e Cr\u00e9er, dans votre environnement de travail ( /home/ username ), l\u2019arborescence de dossiers suivante : (Bonus : en une seule commande !) 1 2 3 4 5 6 7 8 9 10 11 . ` -- SE | -- TP1 | | -- delivery | | -- dpc | ` -- script ` -- TP2 | -- bin | -- inc | -- obj ` -- src Solution 1 mkdir -p SE/ { TP1/ { dpc,script,delivery } ,TP2/ { bin,obj,src,inc }} Installer la commande tree qui permet d'afficher l'arborescence ci-dessus Tip Pour afficher les droits, users et groups avec tree : tree -ugp Solution 1 2 sudo apt-get install tree tree Afficher son r\u00e9pertoire courant Solution 1 pwd Cr\u00e9er le fichier bonjour.c sous SE/TP2/src contenant les lignes suivantes : (En utilisant un editeur en ligne de commande ou graphique, au choix) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // directive du pr\u00e9processeur #include <stdio.h> /* prototype des fonctions */ /* programme principal */ int main () { printf ( \"Bonjour \\n \" ) ; /* 0100123456123 0100123457123 0100123458123 0100123459123 0100123450123 0100123451123 0100123451123 */ } D\u00e9placer vous sous votre home directory et cr\u00e9er le fichier vide config.txt Solution 1 2 cd touch config.txt D\u00e9placer vous par un d\u00e9placement absolu sous le r\u00e9pertoire src et compiler le programme bonjour.c en un programme ex\u00e9cutable bonjour . Le r\u00e9sultat de la compilation est d\u00e9plac\u00e9 sous bin . Solution 1 2 cd /home/my_user/SE/TP2/src gcc bonjour.c -o ../bin/bonjour Afficher les types des fichiers bonjour et bonjour.c Solution 1 2 file bonjour.c file ../bin/bonjour D\u00e9placez vous par un d\u00e9placement relatif sous TP2/bin Solution 1 cd ../bin Modifier les droits du fichier bonjour afin qu\u2019il soit : en lecture, \u00e9criture, ex\u00e9cution pour le owner en lecture, ex\u00e9cution pour le groupe et non accessible pour les autres. Solution 1 chmod 750 bonjour D\u00e9placez vous sous votre home directory et modifiez de fa\u00e7on r\u00e9cursive l\u2019ensemble des droits (directories + fichiers) de TP2 selon les conditions de la question pr\u00e9c\u00e9dente. Solution 1 2 cd chmod -R 750 SE/TP2/ Tip Vous pouvez v\u00e9rifier avec la commande tree -p Copier le fichier bonjour.c en salut.c en local. Tip Pour faire une copie locale il faut etre dans le repertoire concern\u00e9, et copier au m\u00eame endroit. Solution 1 2 cd SE/TP2/src/ cp bonjour.c salut.c Copier le r\u00e9pertoire TP2 en TP3 avec l\u2019ensemble de ses fichiers Solution 1 2 cd ../../ cp -R TP2 TP3 D\u00e9placer le fichier salut.c de TP3 dans SE/TP2/src en l\u2019appelant salut1.c Solution 1 mv TP3/src/salut.c TP2/src/salut1.c Effacer le fichier bonjour.c de TP3 Solution 1 rm TP3/src/bonjour.c Effacer TP3 Solution 1 rm -R TP3/ Utilisation des commandes : chmod, chown, chgrp, ls, ln \u2693\ufe0e Changer le owner du fichier TP2/src/salut.c par n'importe quel autre utilisateur pr\u00e9sent sur votre machine, monitorer le r\u00e9sultat Tip Pour connaitre les users disponible, allez voir le contenu du fichier /etc/passwd avec la command cat Filtrer les users qui possedent un home directory dans /home cat /etc/passwd | grep home Solution 1 2 chown new_owner TP2/src/salut.c ls -la Changer le groupe de ce fichier par un groupe connu sur la machine Tip Pour connaitre les groupes disponible, allez voir le contenu du fichier /etc/group avec la command cat cat /etc/group Solution 1 2 chgrp new_group TP2/src/salut.c ls -la Changer en une seule commande le owner et goupe de TP2 et des fichiers qu\u2019il contient pour vous les redonner Tip Utilisez la commande id pour connaitre votre user:groupe Solution 1 chown -R mon_user:mon_groupe TP2/ Se positionner sur son home directory et cr\u00e9er un lien symbolique vers le fichier salut.c de TP2 Solution 1 2 3 cd ln -s SE/TP2/src/salut.c monLien ls -la Editer ce lien. Expliquer la diff\u00e9rence entre un lien permanent et un lien symbolique. Solution 1 cat monLien Note Un lien symbolique pointe vers le nom d'un fichier existant. Un lieu permanent (ou physique) pointe vers l'esapace m\u00e9moire o\u00f9 se siture le fichier. Monitoring disques \u2693\ufe0e Quel est l\u2019espace disponible sur votre disque ? Solution 1 df -h Quelles sont les partitions disques pr\u00e9sentent sur votre syst\u00e8me ? Solution 1 sudo fdisk -l Utilisation de la commande export \u2693\ufe0e Modifier le contenu de la variable d\u2019environnement PATH afin d\u2019y ajouter le chemin absolu vers le r\u00e9pertoire TP2/bin . Warning Attention \u00e0 ne pas \u00e9craser totalement la variable PATH ! Solution 1 export PATH = $PATH :/home/user/SE/TP2/bin V\u00e9rifier que depuis n'importe quel folder, vous pouvez lancer bonjour de la fa\u00e7on suivante : bonjour \u21b5 V\u00e9rifiez que bonjour execute bien votre binaire avec which bonjour Modifier votre profil utilisateur afin de modifier PATH comme pr\u00e9c\u00e9demment, de mani\u00e8re permanente. Solution Il suffit de copier coller l'export export PATH=$PATH:/home/user/SE/TP2/bin dans le fichier ~/.bashrc Script \u2693\ufe0e D\u00e9placez vous sous SE/TP1/script et cr\u00e9er, en 1 seule commande, un fichier essai.bash contenant #!/bin/bash Solution 1 2 cd ~/SE/TP1/script echo '#!/bin/bash' > essai.bash Ajouter \u00e0 la fin de essai.bash la ligne \u00ab ls \u2013lrt \u00bb (en une seule commande) Solution 1 echo 'ls -lrt' >> essai.bash Ex\u00e9cutez essai.bash Warning Pensez \u00e0 vous donner les droits d'execution avant ... chmod u+x essai.bash Solution 1 ./essai.bash Utilisation de grep, ps, netstat,wc \u2693\ufe0e Rechercher l\u2019occurrence \u00ab include \u00bb dans le fichier bonjour.c Solution 1 2 cd ~/SE/TP2/src grep \"include\" bonjour.c Afficher l\u2019ensemble des processus en cours Solution 1 ps -edf Afficher l\u2019ensemble des sockets en \u00e9tat \u2018ESTABLISHED\u2019 sur votre machine et comptez les. Solution 1 netstat \u2013a | grep ESTABLISHED | wc -l Utilisation de la commande find \u2693\ufe0e Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires Solution 1 find ~/SE -name \"*.c\" Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des occurrences de \u00ab printf \u00bb dans l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires Solution 1 find ~/SE -name \"*.c\" -exec grep \"printf\" {} \\; -print Utilisation de la commande xargs \u2693\ufe0e Cr\u00e9er une sauvegarde de l\u2019ensemble des fichiers c se trouvant sous SE/TP2/src en le copiant en nom_du_fichier.c_backup Tip bonjour.c est copi\u00e9 en bonjour.c_backup Solution 1 ls *.c | xargs -t -i cp {} {} _backup Machine/user/syst\u00e8me/terminal \u2693\ufe0e Afficher qui est logg\u00e9 sur votre machine ? Afficher quel est le nom de votre machine ? Afficher quel est le nom de votre syst\u00e8me ? Afficher quel votre num\u00e9ro utilisateur et groupe ? Solution 1 2 3 4 who hostname uname -a id -u Les Process : utilisation des commandes ps, top, jobs, CTRL^Z, fg, bg, kill \u2693\ufe0e Monitorer de mani\u00e8re dynamique l\u2019ensemble des process en cours Solution 1 top Dans un autre terminal, lancer un process long en background, par example firefox , ou ajouter une boucle infinie au programme bonjour et utiliser `bonjour . bonjour.c 1 2 3 4 5 6 7 8 9 10 11 // directive du pr\u00e9processeur #include <stdio.h> #include <unistd.h> /* programme principal */ int main () { while ( 1 ){ printf ( \"Bonjour \\n \" ) ; sleep ( 2 ); } } Solution 1 bonjour & Monitorer le de fa\u00e7on statique Solution 1 2 3 ps | grep bonjour 9034 ttys000 0 :00.00 bonjour Tuer le violemment Solution 1 kill -9 9034 Lancer un process, l\u2019interrompre et le mettre en ex\u00e9cution en background Solution 1 2 3 bonjour ctrl + z bg Monitorer le Solution 1 ps | grep bonjour Basculer ce process en foreground Solution 1 fg Stopper le par un signal d\u2019interruption Solution 1 ctrl + c","title":""},{"location":"22_tpShell_corr/#tp-commandes-linux","text":"","title":"TP Commandes Linux"},{"location":"22_tpShell_corr/#objectifs","text":"Le second objectif du cours est de maitriser les bases du Shell Unix , via un TP.","title":"Objectifs"},{"location":"22_tpShell_corr/#exercice-1-variables-denvironnements","text":"Afficher l\u2019ensemble de vos variables d\u2019environnement. Solution 1 env Afficher le contenu de la variable PATH. Solution 1 echo $PATH Donner la signification de PATH, PS1, HOME, et TERM Solution PATH : Liste des chemins (absolus) des dossiers contenant des binaires (executables). PS1 : Aspect du Prompt principal. HOME : Chemin du Home Directory de l'utilisateur courant. TERM : Type de terminal en cours d'usage pour l'utilisateur courant.","title":"Exercice 1 : Variables d\u2019environnements"},{"location":"22_tpShell_corr/#exercice-2-initiation-aux-commandes-de-base-dunix","text":"Tip Ne pas oublier que le descriptif des commandes est disponible en utilisant le manuel (commande man). Pour savoir o\u00f9 se trouve un fichier ou commande = whereis, which, apropos","title":"Exercice 2 : Initiation aux commandes de base d'Unix"},{"location":"22_tpShell_corr/#utilisation-des-commandes-alias-et-unalias","text":"Quels sont les alias pr\u00e9sents sur votre machine ? Solution 1 alias Cr\u00e9er un alias lu qui r\u00e9alise la commande ls -lrt Solution 1 alias lu = 'ls -lrt' Utiliser cet alias Solution 1 lu Supprimer cet alias Solution 1 unalias lu","title":"Utilisation des commandes : alias et unalias"},{"location":"22_tpShell_corr/#utilisation-des-commandes-mkdir-rm-cd-cp-mv-touch-chmod-pwd","text":"Cr\u00e9er, dans votre environnement de travail ( /home/ username ), l\u2019arborescence de dossiers suivante : (Bonus : en une seule commande !) 1 2 3 4 5 6 7 8 9 10 11 . ` -- SE | -- TP1 | | -- delivery | | -- dpc | ` -- script ` -- TP2 | -- bin | -- inc | -- obj ` -- src Solution 1 mkdir -p SE/ { TP1/ { dpc,script,delivery } ,TP2/ { bin,obj,src,inc }} Installer la commande tree qui permet d'afficher l'arborescence ci-dessus Tip Pour afficher les droits, users et groups avec tree : tree -ugp Solution 1 2 sudo apt-get install tree tree Afficher son r\u00e9pertoire courant Solution 1 pwd Cr\u00e9er le fichier bonjour.c sous SE/TP2/src contenant les lignes suivantes : (En utilisant un editeur en ligne de commande ou graphique, au choix) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // directive du pr\u00e9processeur #include <stdio.h> /* prototype des fonctions */ /* programme principal */ int main () { printf ( \"Bonjour \\n \" ) ; /* 0100123456123 0100123457123 0100123458123 0100123459123 0100123450123 0100123451123 0100123451123 */ } D\u00e9placer vous sous votre home directory et cr\u00e9er le fichier vide config.txt Solution 1 2 cd touch config.txt D\u00e9placer vous par un d\u00e9placement absolu sous le r\u00e9pertoire src et compiler le programme bonjour.c en un programme ex\u00e9cutable bonjour . Le r\u00e9sultat de la compilation est d\u00e9plac\u00e9 sous bin . Solution 1 2 cd /home/my_user/SE/TP2/src gcc bonjour.c -o ../bin/bonjour Afficher les types des fichiers bonjour et bonjour.c Solution 1 2 file bonjour.c file ../bin/bonjour D\u00e9placez vous par un d\u00e9placement relatif sous TP2/bin Solution 1 cd ../bin Modifier les droits du fichier bonjour afin qu\u2019il soit : en lecture, \u00e9criture, ex\u00e9cution pour le owner en lecture, ex\u00e9cution pour le groupe et non accessible pour les autres. Solution 1 chmod 750 bonjour D\u00e9placez vous sous votre home directory et modifiez de fa\u00e7on r\u00e9cursive l\u2019ensemble des droits (directories + fichiers) de TP2 selon les conditions de la question pr\u00e9c\u00e9dente. Solution 1 2 cd chmod -R 750 SE/TP2/ Tip Vous pouvez v\u00e9rifier avec la commande tree -p Copier le fichier bonjour.c en salut.c en local. Tip Pour faire une copie locale il faut etre dans le repertoire concern\u00e9, et copier au m\u00eame endroit. Solution 1 2 cd SE/TP2/src/ cp bonjour.c salut.c Copier le r\u00e9pertoire TP2 en TP3 avec l\u2019ensemble de ses fichiers Solution 1 2 cd ../../ cp -R TP2 TP3 D\u00e9placer le fichier salut.c de TP3 dans SE/TP2/src en l\u2019appelant salut1.c Solution 1 mv TP3/src/salut.c TP2/src/salut1.c Effacer le fichier bonjour.c de TP3 Solution 1 rm TP3/src/bonjour.c Effacer TP3 Solution 1 rm -R TP3/","title":"Utilisation des commandes : mkdir, rm, cd, cp, mv, touch, chmod, pwd"},{"location":"22_tpShell_corr/#utilisation-des-commandes-chmod-chown-chgrp-ls-ln","text":"Changer le owner du fichier TP2/src/salut.c par n'importe quel autre utilisateur pr\u00e9sent sur votre machine, monitorer le r\u00e9sultat Tip Pour connaitre les users disponible, allez voir le contenu du fichier /etc/passwd avec la command cat Filtrer les users qui possedent un home directory dans /home cat /etc/passwd | grep home Solution 1 2 chown new_owner TP2/src/salut.c ls -la Changer le groupe de ce fichier par un groupe connu sur la machine Tip Pour connaitre les groupes disponible, allez voir le contenu du fichier /etc/group avec la command cat cat /etc/group Solution 1 2 chgrp new_group TP2/src/salut.c ls -la Changer en une seule commande le owner et goupe de TP2 et des fichiers qu\u2019il contient pour vous les redonner Tip Utilisez la commande id pour connaitre votre user:groupe Solution 1 chown -R mon_user:mon_groupe TP2/ Se positionner sur son home directory et cr\u00e9er un lien symbolique vers le fichier salut.c de TP2 Solution 1 2 3 cd ln -s SE/TP2/src/salut.c monLien ls -la Editer ce lien. Expliquer la diff\u00e9rence entre un lien permanent et un lien symbolique. Solution 1 cat monLien Note Un lien symbolique pointe vers le nom d'un fichier existant. Un lieu permanent (ou physique) pointe vers l'esapace m\u00e9moire o\u00f9 se siture le fichier.","title":"Utilisation des commandes : chmod, chown, chgrp, ls, ln"},{"location":"22_tpShell_corr/#monitoring-disques","text":"Quel est l\u2019espace disponible sur votre disque ? Solution 1 df -h Quelles sont les partitions disques pr\u00e9sentent sur votre syst\u00e8me ? Solution 1 sudo fdisk -l","title":"Monitoring disques"},{"location":"22_tpShell_corr/#utilisation-de-la-commande-export","text":"Modifier le contenu de la variable d\u2019environnement PATH afin d\u2019y ajouter le chemin absolu vers le r\u00e9pertoire TP2/bin . Warning Attention \u00e0 ne pas \u00e9craser totalement la variable PATH ! Solution 1 export PATH = $PATH :/home/user/SE/TP2/bin V\u00e9rifier que depuis n'importe quel folder, vous pouvez lancer bonjour de la fa\u00e7on suivante : bonjour \u21b5 V\u00e9rifiez que bonjour execute bien votre binaire avec which bonjour Modifier votre profil utilisateur afin de modifier PATH comme pr\u00e9c\u00e9demment, de mani\u00e8re permanente. Solution Il suffit de copier coller l'export export PATH=$PATH:/home/user/SE/TP2/bin dans le fichier ~/.bashrc","title":"Utilisation de la commande export"},{"location":"22_tpShell_corr/#script","text":"D\u00e9placez vous sous SE/TP1/script et cr\u00e9er, en 1 seule commande, un fichier essai.bash contenant #!/bin/bash Solution 1 2 cd ~/SE/TP1/script echo '#!/bin/bash' > essai.bash Ajouter \u00e0 la fin de essai.bash la ligne \u00ab ls \u2013lrt \u00bb (en une seule commande) Solution 1 echo 'ls -lrt' >> essai.bash Ex\u00e9cutez essai.bash Warning Pensez \u00e0 vous donner les droits d'execution avant ... chmod u+x essai.bash Solution 1 ./essai.bash","title":"Script"},{"location":"22_tpShell_corr/#utilisation-de-grep-ps-netstatwc","text":"Rechercher l\u2019occurrence \u00ab include \u00bb dans le fichier bonjour.c Solution 1 2 cd ~/SE/TP2/src grep \"include\" bonjour.c Afficher l\u2019ensemble des processus en cours Solution 1 ps -edf Afficher l\u2019ensemble des sockets en \u00e9tat \u2018ESTABLISHED\u2019 sur votre machine et comptez les. Solution 1 netstat \u2013a | grep ESTABLISHED | wc -l","title":"Utilisation de grep, ps, netstat,wc"},{"location":"22_tpShell_corr/#utilisation-de-la-commande-find","text":"Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires Solution 1 find ~/SE -name \"*.c\" Rechercher \u00e0 partir de votre repertoire SE l\u2019ensemble des occurrences de \u00ab printf \u00bb dans l\u2019ensemble des fichiers .c contenus dans ce r\u00e9pertoire et ses sous r\u00e9pertoires Solution 1 find ~/SE -name \"*.c\" -exec grep \"printf\" {} \\; -print","title":"Utilisation de la commande find"},{"location":"22_tpShell_corr/#utilisation-de-la-commande-xargs","text":"Cr\u00e9er une sauvegarde de l\u2019ensemble des fichiers c se trouvant sous SE/TP2/src en le copiant en nom_du_fichier.c_backup Tip bonjour.c est copi\u00e9 en bonjour.c_backup Solution 1 ls *.c | xargs -t -i cp {} {} _backup","title":"Utilisation de la commande xargs"},{"location":"22_tpShell_corr/#machineusersystemeterminal","text":"Afficher qui est logg\u00e9 sur votre machine ? Afficher quel est le nom de votre machine ? Afficher quel est le nom de votre syst\u00e8me ? Afficher quel votre num\u00e9ro utilisateur et groupe ? Solution 1 2 3 4 who hostname uname -a id -u","title":"Machine/user/syst\u00e8me/terminal"},{"location":"22_tpShell_corr/#les-process-utilisation-des-commandes-ps-top-jobs-ctrlz-fg-bg-kill","text":"Monitorer de mani\u00e8re dynamique l\u2019ensemble des process en cours Solution 1 top Dans un autre terminal, lancer un process long en background, par example firefox , ou ajouter une boucle infinie au programme bonjour et utiliser `bonjour . bonjour.c 1 2 3 4 5 6 7 8 9 10 11 // directive du pr\u00e9processeur #include <stdio.h> #include <unistd.h> /* programme principal */ int main () { while ( 1 ){ printf ( \"Bonjour \\n \" ) ; sleep ( 2 ); } } Solution 1 bonjour & Monitorer le de fa\u00e7on statique Solution 1 2 3 ps | grep bonjour 9034 ttys000 0 :00.00 bonjour Tuer le violemment Solution 1 kill -9 9034 Lancer un process, l\u2019interrompre et le mettre en ex\u00e9cution en background Solution 1 2 3 bonjour ctrl + z bg Monitorer le Solution 1 ps | grep bonjour Basculer ce process en foreground Solution 1 fg Stopper le par un signal d\u2019interruption Solution 1 ctrl + c","title":"Les Process : utilisation des commandes ps, top, jobs, CTRL^Z, fg, bg, kill"},{"location":"23_regexp/","text":"Expressions R\u00e9guli\u00e8res \u2693\ufe0e G\u00e9n\u00e9ralit\u00e9s \u2693\ufe0e Les expressions r\u00e9guli\u00e8res, combin\u00e9es \u00e0 des fonctions de certains langages (PHP, bash, JavaScript et m\u00eame HTML5 !) permettent de faire des recherches et de la reconnaissance sur des chaines de caract\u00e8res. Extraire des num\u00e9ros de t\u00e9l\u00e9phone d\u2019une page web, ou v\u00e9rifier que l\u2019email que rentr\u00e9 dans un formulaire, ressemble bien \u00e0 un email\u2026 C\u2019est tr\u00e8s puissant ! Anatomie d'une REGEX \u2693\ufe0e Une regex est faite pour effectuer des recherches dans les cha\u00eenes de caract\u00e8res\u2026 et une regex est elle-m\u00eame une cha\u00eene de caract\u00e8re ! Elle poss\u00e8de un d\u00e9limiteur qui en indique le d\u00e9but et la fin ainsi que des caract\u00e8res sp\u00e9ciaux . Les caract\u00e8res sp\u00e9ciaux permettent d\u2019indiquer des comportement pr\u00e9d\u00e9finis. Par exemple d\u00e9signer un sensemble caract\u00e8res, indiquer la longueur d\u2019un mot, une longueur variable, indiquer qu\u2019on ne veut que des majuscules, un mot optionnel etc. Une fois la regex cr\u00e9\u00e9, chaque langage de programmation dispose de ses propres fonctions pour les utiliser. Certaines fonctions permettent de contr\u00f4ler la pr\u00e9sence de certains \u00e9l\u00e9ments dans une cha\u00eene, de la nettoyer en supprimer certains \u00e9l\u00e9ments ou encore d\u2019extraire du texte depuis une cha\u00eene. Lorsqu'on recherche une cha\u00eene de caract\u00e8res \u00e0 l'aide d'une expression r\u00e9guli\u00e8re, la cha\u00eene renvoy\u00e9e est la cha\u00eene la plus grande correspondant \u00e0 l'expression. Pour banaliser un caract\u00e8re, il faut utiliser \\ Exemple : sed -e \"s/RE/cha\u00eene de remplacement/g\" file POSIX et PCRE \u2693\ufe0e Lorsque l\u2019on parle de REGEX, il faut savoir qu\u2019on peut rencontrer diff\u00e9rentes variantes. En effet, certains masques ne fonctionneront pas forc\u00e9ment sur toutes les plate-formes et dans tous les langages. POSIX est un standard qui a cherch\u00e9 \u00e0 uniformiser les syntaxes et les fonctionnalit\u00e9s des expressions r\u00e9guli\u00e8res. Les expressions de type POSIX seront plut\u00f4t bien support\u00e9es dans la console Linux par exemple. Cependant, leur support \u00e9tendu (le reste \u00e9tend commun avec PCRE) est plus restreint. PHP ne supporte par exemple plus la syntaxe POSIX dans ses derni\u00e8res versions. PCRE d\u00e9signe un type de REGEX qui s\u2019appuie sur la syntaxe des REGEX du Perl. C\u2019est la syntaxe la plus largement support\u00e9e aujourd\u2019hui. D\u00e9limiteurs \u2693\ufe0e Ce sont les caract\u00e8res # , % , / etc... Ils servent \u00e0 d\u00e9limiter ce qui fait parti de votre expression, de ce qui n\u2019en fait pas parti. C\u2019est donc en dehors des d\u00e9limiteurs que vous placerez les options PCRE, POSIX n\u2019ayant pas d\u2019options, ni de d\u00e9limiteurs d\u2019ailleurs. Tip Le choix du d\u00e9limiteur est totalement libre (dans la mesure o\u00f9 c\u2019est un caract\u00e8re sp\u00e9cial), cependant, prenez un caract\u00e8re assez rare. Inutile de tenter d\u2019utiliser un slash / si vous pensez travailler sur des URL ou commentaires C ... Les m\u00e9tas-caract\u00e8res \u2693\ufe0e Ces caract\u00e8res ont chacun une signification sp\u00e9ciale dans les expressions r\u00e9guli\u00e8res. C\u2019est notamment eux qui font la force des REGEX. Signe Signification Exemple ^ marque un d\u00e9but chaine /^music/ (commence par music) $ marque une fin de chaine /^music$/ (commence et termine par music) | connecteur logique ou /music | musique/ (music ou musique) . tous les caract\u00e8res sauf les retour charriot \\n (il faut pour \u00e7a utiliser l\u2019option s) /./ (match presque tout) \\ caract\u00e8re d\u2019\u00e9chappement /\\^/ (signifie que le \u201c^\u201d compte ici comme un caract\u00e8re normal) Quantificateurs \u2693\ufe0e Les quantificateurs permettent de pr\u00e9ciser le nombre de fois que l\u2019on autorise un caract\u00e8re ou une suite de caract\u00e8res \u00e0 se r\u00e9p\u00e9ter. Signe Signification Exemple ? 0 ou 1 fois /bue?no/ (buno, ou bueno) + 1 ou plus /bue+no/ (bueno, bueno, bueeeeeeno\u2026) * 0, 1 ou plus /bue*no/ (buno, bueno, bueeeeeeno\u2026) Classes et intervales \u2693\ufe0e Les classes permettent de recherche entre plusieurs caract\u00e8res diff\u00e9rents, elles donnent des alternatives. Les intervales sont des classes un peu sp\u00e9ciales puisqu\u2019elles permettent d\u2019\u00e9num\u00e9rer une certaine palette de chiffre ou de lettres. Par exemple, tous les chiffres de 0 \u00e0 5, ou toutes les lettres de a \u00e0 i, sans les \u00e9num\u00e9rer une par une. Signe Signification Exemple [ ] classe de caract\u00e8res /gr[oai]s/ (gros, gras ou gris) [ - ] intervalle de classe /n\u00b0[0-9]/ (n\u00b01, n\u00b02, [\u2026] n\u00b09) [^ ] classe \u00e0 exclure /h[^3-9]/ (h1 et h2 uniquement) Dans un classe, le tiret \u201c-\u201c sert de d\u00e9limiteur, donc si on veut l\u2019inclure en tant que caract\u00e8re, on doit le placer en fin de classe (ou au d\u00e9but). Par ailleurs, le crochet fermant \u201c]\u201d d\u00e9limite aussi la fin de le classe, il faudra donc l\u2019\u00e9chapper par un antislash. En revanche, les autres m\u00e9tas-caract\u00e8res ne comptent pas dans les classes. On ne les \u00e9chappe pas. Cette classe [0-9a-z?+*{}.] correspond donc \u00e0 un chiffre, une lettre, un point d\u2019interrogation, un point, un plus\u2026 Classes abr\u00e9g\u00e9es \u2693\ufe0e Les classes abr\u00e9g\u00e9es permettent, comme les classes \u201cnormales\u201d, d\u2019avoir de nombreuses possibilit\u00e9s. Elles n\u2019apportent rien de plus en fonctionnalit\u00e9 que les classes normales, mais elles permettent d\u2019\u00e9crire tout \u00e7a bien plus vite, ce sont des raccourcis ! Que diriez vous si vous pouviez taper \\w \u00e0 la place de [0-9a-zA-Z_] ? Raccourci Signification \\d Indique un chiffre. Ca revient exactement \u00e0 taper [0-9] \\D Indique ce qui n\u2019est PAS un chiffre. Ca revient \u00e0 taper [^0-9] \\w Indique un caract\u00e8re alphanum\u00e9rique ou un tiret de soulignement. Cela correspond \u00e0 taper [a-zA-Z0-9_] \\W Indique ce qui n\u2019est PAS un caract\u00e8re alphanum\u00e9rique ou un tiret de soulignement. Ca revient \u00e0 taper [^a-zA-Z0-9_] \\t Indique une tabulation \\n Indique une nouvelle ligne \\r Indique un retour chariot \\s Indique un espace blanc (correspond \u00e0 \\t \\n \\r) \\S Indique ce qui n\u2019est PAS un espace blanc (\\t \\n \\r) . Le point indique n\u2019importe quel caract\u00e8re ! Il autorise donc tout ! Exemples \u2693\ufe0e Exercices \u2693\ufe0e Solution Capture et r\u00e9f\u00e9rences \u2693\ufe0e Les \\( \\) sont capturantes. Qu\u2019est-ce que cela veut dire ? \u00c7a veut dire qu\u2019une expression mise entre parenth\u00e8se est automatiquement plac\u00e9e dans une variable \u00e0 laquelle ont peut faire r\u00e9f\u00e9rence ailleurs. On peut faire r\u00e9f\u00e9rence aux expressions captur\u00e9es \u00e0 deux endroits : Dans la REGEX elle-m\u00eame, cela s\u2019appelle une backreference ou r\u00e9f\u00e9rence arri\u00e8re. On peut ainsi s\u00e9lectionner les palindromes de trois lettres (mots qui se lisent indiff\u00e9remment de gauche \u00e0 droite ou de droite \u00e0 gauche) avec cette expression /\\(\\w\\)\\w\\1/ . Tip Le marqueur (\\w) s\u00e9lectionne tout caract\u00e8re alphanum\u00e9rique et capture ce caract\u00e8re, suivi d\u2019un autre caract\u00e8re puis du caract\u00e8re pr\u00e9c\u00e9demment captur\u00e9 (donc l\u2019expression entre parenth\u00e8ses, soit la premi\u00e8re lettre s\u00e9lectionn\u00e9e) Il peut y avoir plusieurs backreferences dans une m\u00eame expression, la premi\u00e8re est indiqu\u00e9e par \\1 , la seconde \\2 et ainsi de suite. Dans le r\u00e9sultat retourn\u00e9 par la fonction invoqu\u00e9e. Ici, cela d\u00e9pend du langage et de la fonction utilis\u00e9e. Par exemple en Bash : Exercices \u2693\ufe0e Solution Outils \u2693\ufe0e En bash nous utiliserons les commandes vi et sed pour manipuler les regex. Vi \u2693\ufe0e Recherche \u2693\ufe0e On peut rechercher des chaines de caract\u00e8res en utilisant des regexp : :/regexp/ Commande \u2693\ufe0e Substitution \u2693\ufe0e On peut utiliser la commande de substitution : :%s/regexp/chaine de remplacement/options Sed \u2693\ufe0e Sed est un \u00e9diteur non interactif. Cette commande permet d'appliquer un certain nombre de commandes sur un fichier puis d'en afficher le r\u00e9sultat (sans modification du fichier de d\u00e9part) sur la sortie standard. Syntaxe \u2693\ufe0e sed [-n] [-e commande] [-f fichier de commandes] [fichier] -n \u00e9crit seulement les lignes sp\u00e9cifi\u00e9es (par l'option /p) sur la sortie standard -e permet de sp\u00e9cifier les commandes \u00e0 appliquer sur le fichier. -f les commandes sont lu \u00e0 partir d'un fichier. Principe de fonctionnement \u2693\ufe0e Pour chaque ligne , on applique la commande (si cela est possible) puis on affiche sur la sortie standard la ligne modifi\u00e9e ou non. Commandes \u2693\ufe0e Substitution \u2693\ufe0e ad1,ad2s/RE/remplacement/flags -> Remplace les expressions r\u00e9guli\u00e8res RE par la cha\u00eene de remplacement entre les lignes ad1 \u00e0 ad2 N\u00e9gation \u2693\ufe0e ad1,ad2 !fonction argument -> La fonction est appliqu\u00e9e \u00e0 toutes les lignes qui ne correspondent pas \u00e0 la caract\u00e9risation Suppression \u2693\ufe0e ad1,ad2d -> La commande de suppression **d** efface les lignes (au niveau de la sortie, le fichier d'origine n'est pas modifi\u00e9) Exemple : - sed \"1,10d\" fichier : sortie du fichier \u00e0 partir de la onzi\u00e8me ligne - sed \"/^From/!d\" fichier : On efface tout sauf les lignes commen\u00e7ant par From , donc on imprime les lignes commen\u00e7ant par From. Insertions \u2693\ufe0e Exercices \u2693\ufe0e Solution Conclusion \u2693\ufe0e Peu importe votre domaine de programmation et le langage utilis\u00e9, t\u00f4t ou tard les regex sont l\u2019outil qu\u2019il vous faut. Enfin, gardez \u00e0 l\u2019esprit que de la m\u00eame mani\u00e8re que du code, on n\u2019obtient pas forcement la bonne solution du premier coup, alors testez !","title":"Regexp"},{"location":"23_regexp/#expressions-regulieres","text":"","title":"Expressions R\u00e9guli\u00e8res"},{"location":"23_regexp/#generalites","text":"Les expressions r\u00e9guli\u00e8res, combin\u00e9es \u00e0 des fonctions de certains langages (PHP, bash, JavaScript et m\u00eame HTML5 !) permettent de faire des recherches et de la reconnaissance sur des chaines de caract\u00e8res. Extraire des num\u00e9ros de t\u00e9l\u00e9phone d\u2019une page web, ou v\u00e9rifier que l\u2019email que rentr\u00e9 dans un formulaire, ressemble bien \u00e0 un email\u2026 C\u2019est tr\u00e8s puissant !","title":"G\u00e9n\u00e9ralit\u00e9s"},{"location":"23_regexp/#anatomie-dune-regex","text":"Une regex est faite pour effectuer des recherches dans les cha\u00eenes de caract\u00e8res\u2026 et une regex est elle-m\u00eame une cha\u00eene de caract\u00e8re ! Elle poss\u00e8de un d\u00e9limiteur qui en indique le d\u00e9but et la fin ainsi que des caract\u00e8res sp\u00e9ciaux . Les caract\u00e8res sp\u00e9ciaux permettent d\u2019indiquer des comportement pr\u00e9d\u00e9finis. Par exemple d\u00e9signer un sensemble caract\u00e8res, indiquer la longueur d\u2019un mot, une longueur variable, indiquer qu\u2019on ne veut que des majuscules, un mot optionnel etc. Une fois la regex cr\u00e9\u00e9, chaque langage de programmation dispose de ses propres fonctions pour les utiliser. Certaines fonctions permettent de contr\u00f4ler la pr\u00e9sence de certains \u00e9l\u00e9ments dans une cha\u00eene, de la nettoyer en supprimer certains \u00e9l\u00e9ments ou encore d\u2019extraire du texte depuis une cha\u00eene. Lorsqu'on recherche une cha\u00eene de caract\u00e8res \u00e0 l'aide d'une expression r\u00e9guli\u00e8re, la cha\u00eene renvoy\u00e9e est la cha\u00eene la plus grande correspondant \u00e0 l'expression. Pour banaliser un caract\u00e8re, il faut utiliser \\ Exemple : sed -e \"s/RE/cha\u00eene de remplacement/g\" file","title":"Anatomie d'une REGEX"},{"location":"23_regexp/#posix-et-pcre","text":"Lorsque l\u2019on parle de REGEX, il faut savoir qu\u2019on peut rencontrer diff\u00e9rentes variantes. En effet, certains masques ne fonctionneront pas forc\u00e9ment sur toutes les plate-formes et dans tous les langages. POSIX est un standard qui a cherch\u00e9 \u00e0 uniformiser les syntaxes et les fonctionnalit\u00e9s des expressions r\u00e9guli\u00e8res. Les expressions de type POSIX seront plut\u00f4t bien support\u00e9es dans la console Linux par exemple. Cependant, leur support \u00e9tendu (le reste \u00e9tend commun avec PCRE) est plus restreint. PHP ne supporte par exemple plus la syntaxe POSIX dans ses derni\u00e8res versions. PCRE d\u00e9signe un type de REGEX qui s\u2019appuie sur la syntaxe des REGEX du Perl. C\u2019est la syntaxe la plus largement support\u00e9e aujourd\u2019hui.","title":"POSIX et PCRE"},{"location":"23_regexp/#delimiteurs","text":"Ce sont les caract\u00e8res # , % , / etc... Ils servent \u00e0 d\u00e9limiter ce qui fait parti de votre expression, de ce qui n\u2019en fait pas parti. C\u2019est donc en dehors des d\u00e9limiteurs que vous placerez les options PCRE, POSIX n\u2019ayant pas d\u2019options, ni de d\u00e9limiteurs d\u2019ailleurs. Tip Le choix du d\u00e9limiteur est totalement libre (dans la mesure o\u00f9 c\u2019est un caract\u00e8re sp\u00e9cial), cependant, prenez un caract\u00e8re assez rare. Inutile de tenter d\u2019utiliser un slash / si vous pensez travailler sur des URL ou commentaires C ...","title":"D\u00e9limiteurs"},{"location":"23_regexp/#les-metas-caracteres","text":"Ces caract\u00e8res ont chacun une signification sp\u00e9ciale dans les expressions r\u00e9guli\u00e8res. C\u2019est notamment eux qui font la force des REGEX. Signe Signification Exemple ^ marque un d\u00e9but chaine /^music/ (commence par music) $ marque une fin de chaine /^music$/ (commence et termine par music) | connecteur logique ou /music | musique/ (music ou musique) . tous les caract\u00e8res sauf les retour charriot \\n (il faut pour \u00e7a utiliser l\u2019option s) /./ (match presque tout) \\ caract\u00e8re d\u2019\u00e9chappement /\\^/ (signifie que le \u201c^\u201d compte ici comme un caract\u00e8re normal)","title":"Les m\u00e9tas-caract\u00e8res"},{"location":"23_regexp/#quantificateurs","text":"Les quantificateurs permettent de pr\u00e9ciser le nombre de fois que l\u2019on autorise un caract\u00e8re ou une suite de caract\u00e8res \u00e0 se r\u00e9p\u00e9ter. Signe Signification Exemple ? 0 ou 1 fois /bue?no/ (buno, ou bueno) + 1 ou plus /bue+no/ (bueno, bueno, bueeeeeeno\u2026) * 0, 1 ou plus /bue*no/ (buno, bueno, bueeeeeeno\u2026)","title":"Quantificateurs"},{"location":"23_regexp/#classes-et-intervales","text":"Les classes permettent de recherche entre plusieurs caract\u00e8res diff\u00e9rents, elles donnent des alternatives. Les intervales sont des classes un peu sp\u00e9ciales puisqu\u2019elles permettent d\u2019\u00e9num\u00e9rer une certaine palette de chiffre ou de lettres. Par exemple, tous les chiffres de 0 \u00e0 5, ou toutes les lettres de a \u00e0 i, sans les \u00e9num\u00e9rer une par une. Signe Signification Exemple [ ] classe de caract\u00e8res /gr[oai]s/ (gros, gras ou gris) [ - ] intervalle de classe /n\u00b0[0-9]/ (n\u00b01, n\u00b02, [\u2026] n\u00b09) [^ ] classe \u00e0 exclure /h[^3-9]/ (h1 et h2 uniquement) Dans un classe, le tiret \u201c-\u201c sert de d\u00e9limiteur, donc si on veut l\u2019inclure en tant que caract\u00e8re, on doit le placer en fin de classe (ou au d\u00e9but). Par ailleurs, le crochet fermant \u201c]\u201d d\u00e9limite aussi la fin de le classe, il faudra donc l\u2019\u00e9chapper par un antislash. En revanche, les autres m\u00e9tas-caract\u00e8res ne comptent pas dans les classes. On ne les \u00e9chappe pas. Cette classe [0-9a-z?+*{}.] correspond donc \u00e0 un chiffre, une lettre, un point d\u2019interrogation, un point, un plus\u2026","title":"Classes et intervales"},{"location":"23_regexp/#classes-abregees","text":"Les classes abr\u00e9g\u00e9es permettent, comme les classes \u201cnormales\u201d, d\u2019avoir de nombreuses possibilit\u00e9s. Elles n\u2019apportent rien de plus en fonctionnalit\u00e9 que les classes normales, mais elles permettent d\u2019\u00e9crire tout \u00e7a bien plus vite, ce sont des raccourcis ! Que diriez vous si vous pouviez taper \\w \u00e0 la place de [0-9a-zA-Z_] ? Raccourci Signification \\d Indique un chiffre. Ca revient exactement \u00e0 taper [0-9] \\D Indique ce qui n\u2019est PAS un chiffre. Ca revient \u00e0 taper [^0-9] \\w Indique un caract\u00e8re alphanum\u00e9rique ou un tiret de soulignement. Cela correspond \u00e0 taper [a-zA-Z0-9_] \\W Indique ce qui n\u2019est PAS un caract\u00e8re alphanum\u00e9rique ou un tiret de soulignement. Ca revient \u00e0 taper [^a-zA-Z0-9_] \\t Indique une tabulation \\n Indique une nouvelle ligne \\r Indique un retour chariot \\s Indique un espace blanc (correspond \u00e0 \\t \\n \\r) \\S Indique ce qui n\u2019est PAS un espace blanc (\\t \\n \\r) . Le point indique n\u2019importe quel caract\u00e8re ! Il autorise donc tout !","title":"Classes abr\u00e9g\u00e9es"},{"location":"23_regexp/#exemples","text":"","title":"Exemples"},{"location":"23_regexp/#exercices","text":"Solution","title":"Exercices"},{"location":"23_regexp/#capture-et-references","text":"Les \\( \\) sont capturantes. Qu\u2019est-ce que cela veut dire ? \u00c7a veut dire qu\u2019une expression mise entre parenth\u00e8se est automatiquement plac\u00e9e dans une variable \u00e0 laquelle ont peut faire r\u00e9f\u00e9rence ailleurs. On peut faire r\u00e9f\u00e9rence aux expressions captur\u00e9es \u00e0 deux endroits : Dans la REGEX elle-m\u00eame, cela s\u2019appelle une backreference ou r\u00e9f\u00e9rence arri\u00e8re. On peut ainsi s\u00e9lectionner les palindromes de trois lettres (mots qui se lisent indiff\u00e9remment de gauche \u00e0 droite ou de droite \u00e0 gauche) avec cette expression /\\(\\w\\)\\w\\1/ . Tip Le marqueur (\\w) s\u00e9lectionne tout caract\u00e8re alphanum\u00e9rique et capture ce caract\u00e8re, suivi d\u2019un autre caract\u00e8re puis du caract\u00e8re pr\u00e9c\u00e9demment captur\u00e9 (donc l\u2019expression entre parenth\u00e8ses, soit la premi\u00e8re lettre s\u00e9lectionn\u00e9e) Il peut y avoir plusieurs backreferences dans une m\u00eame expression, la premi\u00e8re est indiqu\u00e9e par \\1 , la seconde \\2 et ainsi de suite. Dans le r\u00e9sultat retourn\u00e9 par la fonction invoqu\u00e9e. Ici, cela d\u00e9pend du langage et de la fonction utilis\u00e9e. Par exemple en Bash :","title":"Capture et r\u00e9f\u00e9rences"},{"location":"23_regexp/#exercices_1","text":"Solution","title":"Exercices"},{"location":"23_regexp/#outils","text":"En bash nous utiliserons les commandes vi et sed pour manipuler les regex.","title":"Outils"},{"location":"23_regexp/#vi","text":"","title":"Vi"},{"location":"23_regexp/#recherche","text":"On peut rechercher des chaines de caract\u00e8res en utilisant des regexp : :/regexp/","title":"Recherche"},{"location":"23_regexp/#commande","text":"","title":"Commande"},{"location":"23_regexp/#substitution","text":"On peut utiliser la commande de substitution : :%s/regexp/chaine de remplacement/options","title":"Substitution"},{"location":"23_regexp/#sed","text":"Sed est un \u00e9diteur non interactif. Cette commande permet d'appliquer un certain nombre de commandes sur un fichier puis d'en afficher le r\u00e9sultat (sans modification du fichier de d\u00e9part) sur la sortie standard.","title":"Sed"},{"location":"23_regexp/#syntaxe","text":"sed [-n] [-e commande] [-f fichier de commandes] [fichier] -n \u00e9crit seulement les lignes sp\u00e9cifi\u00e9es (par l'option /p) sur la sortie standard -e permet de sp\u00e9cifier les commandes \u00e0 appliquer sur le fichier. -f les commandes sont lu \u00e0 partir d'un fichier.","title":"Syntaxe"},{"location":"23_regexp/#principe-de-fonctionnement","text":"Pour chaque ligne , on applique la commande (si cela est possible) puis on affiche sur la sortie standard la ligne modifi\u00e9e ou non.","title":"Principe de fonctionnement"},{"location":"23_regexp/#commandes","text":"","title":"Commandes"},{"location":"23_regexp/#substitution_1","text":"ad1,ad2s/RE/remplacement/flags -> Remplace les expressions r\u00e9guli\u00e8res RE par la cha\u00eene de remplacement entre les lignes ad1 \u00e0 ad2","title":"Substitution"},{"location":"23_regexp/#negation","text":"ad1,ad2 !fonction argument -> La fonction est appliqu\u00e9e \u00e0 toutes les lignes qui ne correspondent pas \u00e0 la caract\u00e9risation","title":"N\u00e9gation"},{"location":"23_regexp/#suppression","text":"ad1,ad2d -> La commande de suppression **d** efface les lignes (au niveau de la sortie, le fichier d'origine n'est pas modifi\u00e9) Exemple : - sed \"1,10d\" fichier : sortie du fichier \u00e0 partir de la onzi\u00e8me ligne - sed \"/^From/!d\" fichier : On efface tout sauf les lignes commen\u00e7ant par From , donc on imprime les lignes commen\u00e7ant par From.","title":"Suppression"},{"location":"23_regexp/#insertions","text":"","title":"Insertions"},{"location":"23_regexp/#exercices_2","text":"Solution","title":"Exercices"},{"location":"23_regexp/#conclusion","text":"Peu importe votre domaine de programmation et le langage utilis\u00e9, t\u00f4t ou tard les regex sont l\u2019outil qu\u2019il vous faut. Enfin, gardez \u00e0 l\u2019esprit que de la m\u00eame mani\u00e8re que du code, on n\u2019obtient pas forcement la bonne solution du premier coup, alors testez !","title":"Conclusion"},{"location":"24_awk/","text":"AWK \u2693\ufe0e G\u00e9n\u00e9ralit\u00e9s \u2693\ufe0e Awk est un outil pour la manipulation de fichiers (au format texte). Il a \u00e9t\u00e9 con\u00e7u en 1977 par Alfred **A**ho, Peter **W**einberger et Brian **K**ernighan (Laboratoires Bell) et int\u00e9gr\u00e9 dans Unix V7 en 1979. Awk est aujourd'hui dans la norme POSIX (donc int\u00e9gr\u00e9 dans toutes les distributions Unix, Linux, etc.) Cette commande permet d'appliquer un certain nombre d'actions sur un fichier. Elle est particuli\u00e8rement adapt\u00e9e au fichiers qui sont sous forme de lignes/colonnes , comme le CSV par exemple. La syntaxe est inspir\u00e9e du C. Syntaxe \u2693\ufe0e awk [-Fs] [-v variable] [-f fichier de commandes] '**programme awk**' fichier -F : Sp\u00e9cifie les s\u00e9parateurs de champs -v : D\u00e9finie une variable utilis\u00e9e \u00e0 l'int\u00e9rieur du programme. -f : les commandes sont lu \u00e0 partir d'un fichier. Fonctionnement \u2693\ufe0e Le programme awk est une suite d'action de la forme : motif { action } Vacobulaire Un enregistrement est : une cha\u00eene de caract\u00e8res s\u00e9par\u00e9e par un retour chariot, en g\u00e9n\u00e9ral une ligne . Un champs est : une cha\u00eene de caract\u00e8res s\u00e9par\u00e9e par un espace (ou par le caract\u00e8re sp\u00e9cifi\u00e9 par l'option -F), en g\u00e9n\u00e9ral un mot . Le motif : condition qui permet de d\u00e9terminer sur quels enregistrements est appliqu\u00e9e l'action . Variables pr\u00e9d\u00e9finies \u2693\ufe0e Liste non exhaustive ... Variable Signification Valeur par d\u00e9faut ARGC Nombre d'arguments de la ligne de commande - ARGV Tableau des arguments de la ligne de commande - FNR Nombre d'enregistrements du fichier - NF Nombre de champs dans l'enregistrement courant - NR Nombre d'enregistrement d\u00e9j\u00e0 lus - FS S\u00e9parateur de champs d'entr\u00e9e \" \" RS S\u00e9parateur d'enregistrement en entr\u00e9e \"\\n\" OFS S\u00e9parateur de champs de sortie \" \" ORS S\u00e9parateur d'enregistrement de sortie \"\\n\" ... ... ... Le motif \u2693\ufe0e Si le motif existe dans l'enregistrement, l'action sera appliqu\u00e9e \u00e0 la ligne. Le motif peut \u00eatre : une expression r\u00e9guli\u00e8re : /expression reguli\u00e8re/ $0 ~ /expression reguli\u00e8re/ expression ~ /expression reguli\u00e8re/ expression !~ /expression reguli\u00e8re/ une expression BEGIN ou END une expression de comparaison: <, <=, == , !=, >=, > une combinaison des trois (\u00e0 l'aide des op\u00e9rateurs bool\u00e9ens || ou, && et, ! n\u00e9gation) On acc\u00e8de \u00e0 chaque champs de l'enregistrement courant par la variable $1, $2, ... $NF. $0 correspond \u00e0 l'enregistrement complet. La variable NF contient le nombre de champs de l'enregistrement courant, la variable $NF correspond donc au dernier champs . L'action \u2693\ufe0e Une action transforme ou manipule des donn\u00e9es, par d\u00e9faut on print la ligne. Type des actions : - fonctions pr\u00e9d\u00e9finies , num\u00e9rique ou cha\u00eene de caract\u00e8res - contr\u00f4le de flots - affectation - impression Actions possibles : Les op\u00e9rations arithm\u00e9tiques usuelles : + - * / % (reste division enti\u00e8re) et ^ (puissance). Tous les calculs sont effectu\u00e9s en virgule flottante. Vous pouvez aussi utiliser les op\u00e9rateurs += , -= , *= , /= , %= etc ... Les affectations : var = expression R\u00e9f\u00e9rences aux variables de champs : Les champs de la ligne courant sont : $1, $2, ..., $NF. La ligne enti\u00e8re est $0. Ces variables ont les m\u00eames propri\u00e9t\u00e9s que Les autres variables. Elles peuvent \u00eatre r\u00e9affect\u00e9es. Quand $0 est modifi\u00e9es, les variables $1, $2 ... sont aussi modifi\u00e9es ainsi que NF. Inversement si une des variables $i est modifi\u00e9es, $0 est mise \u00e0 jour. Les champs peuvent \u00eatre sp\u00e9cifi\u00e9s par des expressions, comme $(NF-1) pour l'avant dernier champs. Impression : print $i par exemple ... If/Else, Boucles if (condition) { ... } else { ... } while (condition) { ... } for (init ;cond ;incr) { ... } Commentaire : # next : passe \u00e0 l'enregistrement suivant. On reprend le script awk \u00e0 son d\u00e9but. exit : ignore le reste de l'entr\u00e9e et execute les actions d\u00e9finie par END Liste non exhaustive de fonction sur chaines de charact\u00e8res : Dans le tableau suivant s et t repr\u00e9sentent des cha\u00eenes de caract\u00e8res, r une expression r\u00e9guli\u00e8re, i et n des entiers. Fonction Signification length(s) Retourne la longueur de la chaine s gsub(r,s,t) Dans la chaine t , remplace toutes les occurences de r par s substr(s,i,n) Retroune la sous cha\u00eene de s commen\u00e7ant en i et de taille n ... ... Concat\u00e9nation de cha\u00eenes de caract\u00e8res dans les actions : Il n'y a pas d'op\u00e9rateur de concat\u00e9nation, il faut simplement lister les cha\u00eenes \u00e0 concat\u00e9ner. Exemples : awk '{ print NR \" : \" $0 }' fichier Exemples \u2693\ufe0e Script Resultat awk -F \":\" '{ $2 = \"\" ; print $0 }' /etc/passwd Imprime chaqe ligne du fichier /etc/passwd apr\u00e8s avoir effac\u00e9 le 2 nd champ awk ' END { print NR }' fichier Imprime le nombre total de lignes du fichier awk '{ print $NF }' fichier Imprime le dernier champ de chaque ligne who | awk '{ print $1,$5 }' Imprime le login et le temps de connexion awk ' length($0) > 75 { print }' fichier Imprime les lignes de plus de 75 caract\u00e8res ( print \u00e9quivaut \u00e0 print $0 Exercices \u2693\ufe0e awk 'BEGIN { print \"Verification des UID et GID dans le fichier /etc/passwd\"; FS=\":\"} $3 !~ /^[0-9][0-9]*$/ {print \"UID erreur ligne \"NR\" :\\n\"$0 } $4 !~ /^[0-9][0-9]*$/ {print \"GID erreur ligne \"NR\" :\\n\"$0 } END { print \"Fin\" }' /etc/passwd Solution V\u00e9rification des UID et GID dans le fichier /etc/passwd UID erreur ligne 14 : clown:*:aaa:b:utilisateur en erreur:/home/clown:/bin:sh GID erreur ligne 14 : clown:*:aaa:b:utilisateur en erreur:/home/clown:/bin/sh Fin awk 'BEGIN { print \"Verification du fichier /etc/passwd pour ...\"; print \"- les utilisateurs avec UID = 0 \" ; print \"- les utilisateurs avec UID >= 60000\" ; FS=\":\"} $3 == 0 { print \"UID 0 ligne \"NR\" :\\n\"$0 } $3 >= 60000 { print \"UID >= 60000 ligne \"NR\" :\\n\"$0 } END { print \"Fin\" }' /etc/passwd Solution Verification du fichier /etc/passwd pour ... - les utilisateurs avec UID = 0 - les utilisateurs avec UID >= 60000 UID 0 ligne 5 : root:*:0:b:administrateur:/:/bin/sh UID >= 60000 ligne 14 : clown:*:61000:b:utilisateur en erreur:/home/clown:/bin/sh Fin awk 'BEGIN { print \"Verification du fichier /etc/group\"; print \"le groupe 20 est t-il bien nomm\u00e9 users ? \" ; FS=\":\"} $1 == \"users\" && $3 ==20 { print \"groupe \"$1\" a le GID \"$3\" !\" } END { print \"Fin\" }' /etc/group Solution Verification du fichier /etc/group le groupe 20 s'appelle t-il bien users ? groupe users a le GID 20 ! Fin awk 'NR == 5 , NR == 10 {print NR\" : \" $0 }' fichier Solution Imprime de la ligne 5 \u00e0 la ligne 10 , chaque ligne pr\u00e9c\u00e9d\u00e9e par son num\u00e9ro awk 'BEGIN { FS=\":\" ; OFS=\":\"} $NF != \"/bin/ksh\" { print $0 } $7 == \"/bin/ksh\" && NF == 7 { $7 = \"/bin/posix/sh\" ; print $0 } ' /etc/passwd > /etc/passwdnew Solution On cr\u00e9e un nouveau fichier de mot de passe /etc/passwd.new en rempla\u00e7ant le shell /bin/ksh par /bin/posix/sh","title":"AWK"},{"location":"24_awk/#awk","text":"","title":"AWK"},{"location":"24_awk/#generalites","text":"Awk est un outil pour la manipulation de fichiers (au format texte). Il a \u00e9t\u00e9 con\u00e7u en 1977 par Alfred **A**ho, Peter **W**einberger et Brian **K**ernighan (Laboratoires Bell) et int\u00e9gr\u00e9 dans Unix V7 en 1979. Awk est aujourd'hui dans la norme POSIX (donc int\u00e9gr\u00e9 dans toutes les distributions Unix, Linux, etc.) Cette commande permet d'appliquer un certain nombre d'actions sur un fichier. Elle est particuli\u00e8rement adapt\u00e9e au fichiers qui sont sous forme de lignes/colonnes , comme le CSV par exemple. La syntaxe est inspir\u00e9e du C.","title":"G\u00e9n\u00e9ralit\u00e9s"},{"location":"24_awk/#syntaxe","text":"awk [-Fs] [-v variable] [-f fichier de commandes] '**programme awk**' fichier -F : Sp\u00e9cifie les s\u00e9parateurs de champs -v : D\u00e9finie une variable utilis\u00e9e \u00e0 l'int\u00e9rieur du programme. -f : les commandes sont lu \u00e0 partir d'un fichier.","title":"Syntaxe"},{"location":"24_awk/#fonctionnement","text":"Le programme awk est une suite d'action de la forme : motif { action } Vacobulaire Un enregistrement est : une cha\u00eene de caract\u00e8res s\u00e9par\u00e9e par un retour chariot, en g\u00e9n\u00e9ral une ligne . Un champs est : une cha\u00eene de caract\u00e8res s\u00e9par\u00e9e par un espace (ou par le caract\u00e8re sp\u00e9cifi\u00e9 par l'option -F), en g\u00e9n\u00e9ral un mot . Le motif : condition qui permet de d\u00e9terminer sur quels enregistrements est appliqu\u00e9e l'action .","title":"Fonctionnement"},{"location":"24_awk/#variables-predefinies","text":"Liste non exhaustive ... Variable Signification Valeur par d\u00e9faut ARGC Nombre d'arguments de la ligne de commande - ARGV Tableau des arguments de la ligne de commande - FNR Nombre d'enregistrements du fichier - NF Nombre de champs dans l'enregistrement courant - NR Nombre d'enregistrement d\u00e9j\u00e0 lus - FS S\u00e9parateur de champs d'entr\u00e9e \" \" RS S\u00e9parateur d'enregistrement en entr\u00e9e \"\\n\" OFS S\u00e9parateur de champs de sortie \" \" ORS S\u00e9parateur d'enregistrement de sortie \"\\n\" ... ... ...","title":"Variables pr\u00e9d\u00e9finies"},{"location":"24_awk/#le-motif","text":"Si le motif existe dans l'enregistrement, l'action sera appliqu\u00e9e \u00e0 la ligne. Le motif peut \u00eatre : une expression r\u00e9guli\u00e8re : /expression reguli\u00e8re/ $0 ~ /expression reguli\u00e8re/ expression ~ /expression reguli\u00e8re/ expression !~ /expression reguli\u00e8re/ une expression BEGIN ou END une expression de comparaison: <, <=, == , !=, >=, > une combinaison des trois (\u00e0 l'aide des op\u00e9rateurs bool\u00e9ens || ou, && et, ! n\u00e9gation) On acc\u00e8de \u00e0 chaque champs de l'enregistrement courant par la variable $1, $2, ... $NF. $0 correspond \u00e0 l'enregistrement complet. La variable NF contient le nombre de champs de l'enregistrement courant, la variable $NF correspond donc au dernier champs .","title":"Le motif"},{"location":"24_awk/#laction","text":"Une action transforme ou manipule des donn\u00e9es, par d\u00e9faut on print la ligne. Type des actions : - fonctions pr\u00e9d\u00e9finies , num\u00e9rique ou cha\u00eene de caract\u00e8res - contr\u00f4le de flots - affectation - impression Actions possibles : Les op\u00e9rations arithm\u00e9tiques usuelles : + - * / % (reste division enti\u00e8re) et ^ (puissance). Tous les calculs sont effectu\u00e9s en virgule flottante. Vous pouvez aussi utiliser les op\u00e9rateurs += , -= , *= , /= , %= etc ... Les affectations : var = expression R\u00e9f\u00e9rences aux variables de champs : Les champs de la ligne courant sont : $1, $2, ..., $NF. La ligne enti\u00e8re est $0. Ces variables ont les m\u00eames propri\u00e9t\u00e9s que Les autres variables. Elles peuvent \u00eatre r\u00e9affect\u00e9es. Quand $0 est modifi\u00e9es, les variables $1, $2 ... sont aussi modifi\u00e9es ainsi que NF. Inversement si une des variables $i est modifi\u00e9es, $0 est mise \u00e0 jour. Les champs peuvent \u00eatre sp\u00e9cifi\u00e9s par des expressions, comme $(NF-1) pour l'avant dernier champs. Impression : print $i par exemple ... If/Else, Boucles if (condition) { ... } else { ... } while (condition) { ... } for (init ;cond ;incr) { ... } Commentaire : # next : passe \u00e0 l'enregistrement suivant. On reprend le script awk \u00e0 son d\u00e9but. exit : ignore le reste de l'entr\u00e9e et execute les actions d\u00e9finie par END Liste non exhaustive de fonction sur chaines de charact\u00e8res : Dans le tableau suivant s et t repr\u00e9sentent des cha\u00eenes de caract\u00e8res, r une expression r\u00e9guli\u00e8re, i et n des entiers. Fonction Signification length(s) Retourne la longueur de la chaine s gsub(r,s,t) Dans la chaine t , remplace toutes les occurences de r par s substr(s,i,n) Retroune la sous cha\u00eene de s commen\u00e7ant en i et de taille n ... ... Concat\u00e9nation de cha\u00eenes de caract\u00e8res dans les actions : Il n'y a pas d'op\u00e9rateur de concat\u00e9nation, il faut simplement lister les cha\u00eenes \u00e0 concat\u00e9ner. Exemples : awk '{ print NR \" : \" $0 }' fichier","title":"L'action"},{"location":"24_awk/#exemples","text":"Script Resultat awk -F \":\" '{ $2 = \"\" ; print $0 }' /etc/passwd Imprime chaqe ligne du fichier /etc/passwd apr\u00e8s avoir effac\u00e9 le 2 nd champ awk ' END { print NR }' fichier Imprime le nombre total de lignes du fichier awk '{ print $NF }' fichier Imprime le dernier champ de chaque ligne who | awk '{ print $1,$5 }' Imprime le login et le temps de connexion awk ' length($0) > 75 { print }' fichier Imprime les lignes de plus de 75 caract\u00e8res ( print \u00e9quivaut \u00e0 print $0","title":"Exemples"},{"location":"24_awk/#exercices","text":"awk 'BEGIN { print \"Verification des UID et GID dans le fichier /etc/passwd\"; FS=\":\"} $3 !~ /^[0-9][0-9]*$/ {print \"UID erreur ligne \"NR\" :\\n\"$0 } $4 !~ /^[0-9][0-9]*$/ {print \"GID erreur ligne \"NR\" :\\n\"$0 } END { print \"Fin\" }' /etc/passwd Solution V\u00e9rification des UID et GID dans le fichier /etc/passwd UID erreur ligne 14 : clown:*:aaa:b:utilisateur en erreur:/home/clown:/bin:sh GID erreur ligne 14 : clown:*:aaa:b:utilisateur en erreur:/home/clown:/bin/sh Fin awk 'BEGIN { print \"Verification du fichier /etc/passwd pour ...\"; print \"- les utilisateurs avec UID = 0 \" ; print \"- les utilisateurs avec UID >= 60000\" ; FS=\":\"} $3 == 0 { print \"UID 0 ligne \"NR\" :\\n\"$0 } $3 >= 60000 { print \"UID >= 60000 ligne \"NR\" :\\n\"$0 } END { print \"Fin\" }' /etc/passwd Solution Verification du fichier /etc/passwd pour ... - les utilisateurs avec UID = 0 - les utilisateurs avec UID >= 60000 UID 0 ligne 5 : root:*:0:b:administrateur:/:/bin/sh UID >= 60000 ligne 14 : clown:*:61000:b:utilisateur en erreur:/home/clown:/bin/sh Fin awk 'BEGIN { print \"Verification du fichier /etc/group\"; print \"le groupe 20 est t-il bien nomm\u00e9 users ? \" ; FS=\":\"} $1 == \"users\" && $3 ==20 { print \"groupe \"$1\" a le GID \"$3\" !\" } END { print \"Fin\" }' /etc/group Solution Verification du fichier /etc/group le groupe 20 s'appelle t-il bien users ? groupe users a le GID 20 ! Fin awk 'NR == 5 , NR == 10 {print NR\" : \" $0 }' fichier Solution Imprime de la ligne 5 \u00e0 la ligne 10 , chaque ligne pr\u00e9c\u00e9d\u00e9e par son num\u00e9ro awk 'BEGIN { FS=\":\" ; OFS=\":\"} $NF != \"/bin/ksh\" { print $0 } $7 == \"/bin/ksh\" && NF == 7 { $7 = \"/bin/posix/sh\" ; print $0 } ' /etc/passwd > /etc/passwdnew Solution On cr\u00e9e un nouveau fichier de mot de passe /etc/passwd.new en rempla\u00e7ant le shell /bin/ksh par /bin/posix/sh","title":"Exercices"},{"location":"30_tpRegexp/","text":"TP Regexp \u2693\ufe0e Dans ce TP, vous apprendrez \u00e0 utiliser les outils d'expression r\u00e9guli\u00e8res. Travail sur les fichiers : sed, awk, diff, cut, sort \u2693\ufe0e Sur le fichier C utilis\u00e9 au TP pr\u00e9c\u00e9dent : Transformer les commentaires // en /* */ \u2013 Affichage stdout Transformer les commentaires /* */ en // \u2013 Affichage dans un fichier bonjour.cpp Comparer les fichiers bonjour.cpp et bonjour.c Sous SE/TP1/script, cr\u00e9er le fichier titi.txt contenant les lignes suivantes : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Alain DERUE Clothilde DERUE Adresse 7 av du President Carter 13000 Marseille cedex 01 TP_OA :MSISDN :KI :IMSI :TP_UD TP_SCTS :TP_DA :TAC :IMEI: :TP_UD 0100123456123 0100123457123 0100123458123 0100123459123 0100123460123 0100123461123 0100123462123 0100123463123 Remplacer le nom de famille DERUE par Christophe \u2013 Affichage stdout Remplacer les lignes pr\u00e9fix\u00e9es par 0100 et suffix\u00e9e par 123, par le contenu situ\u00e9 entre ces deux occurrences \u2013 Affichage stdout. Exemple : 0100123456123 devient 123456 Ne garder que les chiffres du fichier \u2013 Affichage stdout Afficher, sur stdout, les champs 1 et 4 issue du d\u00e9coupage \u00e0 partir du token : du fichier titi.txt Trier les lignes de titi.txt Effacer les lignes vides contenues dans le fichier bonjour.c Ecrivez un script awk qui permet d'afficher chaque groupe disponible sur votre machine, suivit de son num\u00e9ro GID, si et seulement si son GID est > 1. Formattez la sortie comme ceci : Nom du groupe : [groupName] / ID du groupe : [GID] Voici un example de fichier /etc/group si vous n'en avez pas : 1 2 3 4 5 6 wheel:*:0:root daemon:*:1:root kmem:*:5:root jberger:*:200:user user1:*:201:user eleve:*:500:eleves Archiver son travail : tar, gzip \u2693\ufe0e Se positionner sous votre home directory et archiver SE en donnant votre nom \u00e0 l'archive.","title":"TP Regexp"},{"location":"30_tpRegexp/#tp-regexp","text":"Dans ce TP, vous apprendrez \u00e0 utiliser les outils d'expression r\u00e9guli\u00e8res.","title":"TP Regexp"},{"location":"30_tpRegexp/#travail-sur-les-fichiers-sed-awk-diff-cut-sort","text":"Sur le fichier C utilis\u00e9 au TP pr\u00e9c\u00e9dent : Transformer les commentaires // en /* */ \u2013 Affichage stdout Transformer les commentaires /* */ en // \u2013 Affichage dans un fichier bonjour.cpp Comparer les fichiers bonjour.cpp et bonjour.c Sous SE/TP1/script, cr\u00e9er le fichier titi.txt contenant les lignes suivantes : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Alain DERUE Clothilde DERUE Adresse 7 av du President Carter 13000 Marseille cedex 01 TP_OA :MSISDN :KI :IMSI :TP_UD TP_SCTS :TP_DA :TAC :IMEI: :TP_UD 0100123456123 0100123457123 0100123458123 0100123459123 0100123460123 0100123461123 0100123462123 0100123463123 Remplacer le nom de famille DERUE par Christophe \u2013 Affichage stdout Remplacer les lignes pr\u00e9fix\u00e9es par 0100 et suffix\u00e9e par 123, par le contenu situ\u00e9 entre ces deux occurrences \u2013 Affichage stdout. Exemple : 0100123456123 devient 123456 Ne garder que les chiffres du fichier \u2013 Affichage stdout Afficher, sur stdout, les champs 1 et 4 issue du d\u00e9coupage \u00e0 partir du token : du fichier titi.txt Trier les lignes de titi.txt Effacer les lignes vides contenues dans le fichier bonjour.c Ecrivez un script awk qui permet d'afficher chaque groupe disponible sur votre machine, suivit de son num\u00e9ro GID, si et seulement si son GID est > 1. Formattez la sortie comme ceci : Nom du groupe : [groupName] / ID du groupe : [GID] Voici un example de fichier /etc/group si vous n'en avez pas : 1 2 3 4 5 6 wheel:*:0:root daemon:*:1:root kmem:*:5:root jberger:*:200:user user1:*:201:user eleve:*:500:eleves","title":"Travail sur les fichiers : sed, awk, diff, cut, sort"},{"location":"30_tpRegexp/#archiver-son-travail-tar-gzip","text":"Se positionner sous votre home directory et archiver SE en donnant votre nom \u00e0 l'archive.","title":"Archiver son travail : tar, gzip"},{"location":"30_tpRegexp_corr/","text":"TP Regexp \u2693\ufe0e Dans ce TP, vous apprendrez \u00e0 utiliser les outils d'expression r\u00e9guli\u00e8res. Travail sur les fichiers : sed, awk, diff, cut, sort \u2693\ufe0e Sur le fichier C utilis\u00e9 au TP pr\u00e9c\u00e9dent : Transformer les commentaires // en /* */ \u2013 Affichage stdout 1 sed -e 's://\\(.*\\):/*\\1*/:g' bonjour.c Transformer les commentaires /* */ en // \u2013 Affichage dans un fichier bonjour.cpp 1 sed -e 's:/\\*\\(.*\\)\\*/:// \\1:g' bonjour.c > bonjour.cpp Comparer les fichiers bonjour.cpp et bonjour.c 1 diff bonjour.c bonjour.cpp Sous SE/TP1/script, cr\u00e9er le fichier titi.txt contenant les lignes suivantes : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Alain DERUE Clothilde DERUE Adresse 7 av du President Carter 13000 Marseille cedex 01 TP_OA :MSISDN :KI :IMSI :TP_UD TP_SCTS :TP_DA :TAC :IMEI: :TP_UD 0100123456123 0100123457123 0100123458123 0100123459123 0100123460123 0100123461123 0100123462123 0100123463123 Remplacer le nom de famille DERUE par Christophe \u2013 Affichage stdout 1 sed 's/DERUE/Christophe/g' titi.txt Remplacer les lignes pr\u00e9fix\u00e9es par 0100 et suffix\u00e9e par 123, par le contenu situ\u00e9 entre ces deux occurrences \u2013 Affichage stdout. Exemple : 0100123456123 devient 123456 1 sed -e 's:0100\\(.*\\)123:\\1:g' titi.txt Ne garder que les chiffres du fichier \u2013 Affichage stdout 1 2 sed -e 's/[a-zA-Z:_-]//g' titi.txt sed -e 's/[^0-9]//g' -e '/^$/d' titi.txt Afficher, sur stdout, les champs 1 et 4 issue du d\u00e9coupage \u00e0 partir du token : du fichier titi.txt 1 2 cut -d : -f 1 ,4 titi.txt awk -F \":\" 'NF > 1 { OFS=\":\" ; print $1,$4 }' titi.txt Trier les lignes de titi.txt 1 sort titi.txt Effacer les lignes vides contenues dans le fichier bonjour.c 1 2 3 4 sed -e '/^$/d' bonjour.c awk ' NF != 0 {print $0 }' titi.txt ou implicitement : awk 'NF' test Ecrivez un script awk qui permet d'afficher chaque groupe disponible sur votre machine, suivit de son num\u00e9ro GID, si et seulement si son GID est > 1. Formattez la sortie comme ceci : Nom du groupe : [groupName] / ID du groupe : [GID] Voici un example de fichier /etc/group si vous n'en avez pas : 1 2 3 4 5 6 wheel:*:0:root daemon:*:1:root kmem:*:5:root jberger:*:200:user user1:*:201:user eleve:*:500:eleves 1 awk -F \":\" '$3 > 1 { print \"Nom du groupe : \" $1 \" / ID du groupe : \" $3 }' /etc/group Archiver son travail : tar, gzip \u2693\ufe0e Se positionner sous votre home directory et archiver SE en donnant votre nom \u00e0 l'archive. 1 tar -cvzf nom.tar.gz SE/","title":""},{"location":"30_tpRegexp_corr/#tp-regexp","text":"Dans ce TP, vous apprendrez \u00e0 utiliser les outils d'expression r\u00e9guli\u00e8res.","title":"TP Regexp"},{"location":"30_tpRegexp_corr/#travail-sur-les-fichiers-sed-awk-diff-cut-sort","text":"Sur le fichier C utilis\u00e9 au TP pr\u00e9c\u00e9dent : Transformer les commentaires // en /* */ \u2013 Affichage stdout 1 sed -e 's://\\(.*\\):/*\\1*/:g' bonjour.c Transformer les commentaires /* */ en // \u2013 Affichage dans un fichier bonjour.cpp 1 sed -e 's:/\\*\\(.*\\)\\*/:// \\1:g' bonjour.c > bonjour.cpp Comparer les fichiers bonjour.cpp et bonjour.c 1 diff bonjour.c bonjour.cpp Sous SE/TP1/script, cr\u00e9er le fichier titi.txt contenant les lignes suivantes : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Alain DERUE Clothilde DERUE Adresse 7 av du President Carter 13000 Marseille cedex 01 TP_OA :MSISDN :KI :IMSI :TP_UD TP_SCTS :TP_DA :TAC :IMEI: :TP_UD 0100123456123 0100123457123 0100123458123 0100123459123 0100123460123 0100123461123 0100123462123 0100123463123 Remplacer le nom de famille DERUE par Christophe \u2013 Affichage stdout 1 sed 's/DERUE/Christophe/g' titi.txt Remplacer les lignes pr\u00e9fix\u00e9es par 0100 et suffix\u00e9e par 123, par le contenu situ\u00e9 entre ces deux occurrences \u2013 Affichage stdout. Exemple : 0100123456123 devient 123456 1 sed -e 's:0100\\(.*\\)123:\\1:g' titi.txt Ne garder que les chiffres du fichier \u2013 Affichage stdout 1 2 sed -e 's/[a-zA-Z:_-]//g' titi.txt sed -e 's/[^0-9]//g' -e '/^$/d' titi.txt Afficher, sur stdout, les champs 1 et 4 issue du d\u00e9coupage \u00e0 partir du token : du fichier titi.txt 1 2 cut -d : -f 1 ,4 titi.txt awk -F \":\" 'NF > 1 { OFS=\":\" ; print $1,$4 }' titi.txt Trier les lignes de titi.txt 1 sort titi.txt Effacer les lignes vides contenues dans le fichier bonjour.c 1 2 3 4 sed -e '/^$/d' bonjour.c awk ' NF != 0 {print $0 }' titi.txt ou implicitement : awk 'NF' test Ecrivez un script awk qui permet d'afficher chaque groupe disponible sur votre machine, suivit de son num\u00e9ro GID, si et seulement si son GID est > 1. Formattez la sortie comme ceci : Nom du groupe : [groupName] / ID du groupe : [GID] Voici un example de fichier /etc/group si vous n'en avez pas : 1 2 3 4 5 6 wheel:*:0:root daemon:*:1:root kmem:*:5:root jberger:*:200:user user1:*:201:user eleve:*:500:eleves 1 awk -F \":\" '$3 > 1 { print \"Nom du groupe : \" $1 \" / ID du groupe : \" $3 }' /etc/group","title":"Travail sur les fichiers : sed, awk, diff, cut, sort"},{"location":"30_tpRegexp_corr/#archiver-son-travail-tar-gzip","text":"Se positionner sous votre home directory et archiver SE en donnant votre nom \u00e0 l'archive. 1 tar -cvzf nom.tar.gz SE/","title":"Archiver son travail : tar, gzip"},{"location":"40_progsys_execv/","text":"Programmation Syst\u00e8me - Execv \u2693\ufe0e Recouvrement \u2693\ufe0e On va maintenant chercher \u00e0 coder nos deux processus dans deux programmes diff\u00e9rents, afin d'all\u00e9ger la lecture du code ! Primitive de Recouvrement \u2693\ufe0e Execv \u2693\ufe0e 1 int execv ( char * ref , char * argv []); ref : chemin absolu du programme \u00e0 executer argv: tableau de pointeur vers des caract\u00e8res (tableau de chaines de caract\u00e8res) \u2013 argv[0]: nom du nouveau programme \u00e0 ex\u00e9cuter \u2013 argv[1]: le 1er param\u00e8tre \u2013 argv[2]: le 2\u00e8me param\u00e8tre \u2013 \u2026\u2026\u2026\u2026. \u2013 argv[N]: le Ni\u00e8me param\u00e8tre \u2013 argv[N+1]: NULL Permet de lancer l\u2019ex\u00e9cution, par le processus appelant, d\u2019un nouveau programme en son sein : les instructions du nouveau programme recouvrent celles de l \u2019ancien programme retourne -1 en cas d\u2019\u00e9chec Important ! Remarque : pas de cr\u00e9ation de nouveau processus Rien n'est fait au hasard ... Si on regarde bien, on a d\u00e9j\u00e0 manipul\u00e9 un tableau similaire dans la fonction main du programme calculatrice ... Dans ce dernier, les arguments venaient de notre input en CLI, et c'est l'OS qui se chargeait de remplir le tableau pour nous. Ici, nous rempla\u00e7ons l'OS pour instancier manuellement un processus dans un existant. C'est donc \u00e0 nous de remplir ce tableau cette fois ci !! Exemple \u2693\ufe0e Code \u2693\ufe0e Programme principal : Programme fils : /* calcul.c */ int main ( void ) { int pid , status ; char * argv [ 2 ]; pid = fork (); if ( pid == 0 ) { printf ( \"je le fils:pid=%d \" , getpid ()); argv [ 0 ] = \"carre\" ; argv [ 1 ] = NULL ; execv ( \" /home/carre \" , argv ); } printf ( \" je suis le p\u00e8re: pid=%d \" , getpid ()); wait ( & status ); printf ( \" le carre = %d \" , status / 256 ); exit ( 0 ); } /* carre.c*/ int main ( int argc , char * arg []) { int x ; printf ( \" je le fils:pid=%d \" , getpid ()); printf ( \"pid de mon pere=%d \" , getppid ()); printf ( \" x = \" ); scanf ( \" %d \" , & x ); x = x * x : exit ( x ); } Sch\u00e9ma \u2693\ufe0e","title":"Programmation Syst\u00e8me - Execv"},{"location":"40_progsys_execv/#programmation-systeme-execv","text":"","title":"Programmation Syst\u00e8me - Execv"},{"location":"40_progsys_execv/#recouvrement","text":"On va maintenant chercher \u00e0 coder nos deux processus dans deux programmes diff\u00e9rents, afin d'all\u00e9ger la lecture du code !","title":"Recouvrement"},{"location":"40_progsys_execv/#primitive-de-recouvrement","text":"","title":"Primitive de Recouvrement"},{"location":"40_progsys_execv/#execv","text":"1 int execv ( char * ref , char * argv []); ref : chemin absolu du programme \u00e0 executer argv: tableau de pointeur vers des caract\u00e8res (tableau de chaines de caract\u00e8res) \u2013 argv[0]: nom du nouveau programme \u00e0 ex\u00e9cuter \u2013 argv[1]: le 1er param\u00e8tre \u2013 argv[2]: le 2\u00e8me param\u00e8tre \u2013 \u2026\u2026\u2026\u2026. \u2013 argv[N]: le Ni\u00e8me param\u00e8tre \u2013 argv[N+1]: NULL Permet de lancer l\u2019ex\u00e9cution, par le processus appelant, d\u2019un nouveau programme en son sein : les instructions du nouveau programme recouvrent celles de l \u2019ancien programme retourne -1 en cas d\u2019\u00e9chec Important ! Remarque : pas de cr\u00e9ation de nouveau processus Rien n'est fait au hasard ... Si on regarde bien, on a d\u00e9j\u00e0 manipul\u00e9 un tableau similaire dans la fonction main du programme calculatrice ... Dans ce dernier, les arguments venaient de notre input en CLI, et c'est l'OS qui se chargeait de remplir le tableau pour nous. Ici, nous rempla\u00e7ons l'OS pour instancier manuellement un processus dans un existant. C'est donc \u00e0 nous de remplir ce tableau cette fois ci !!","title":"Execv"},{"location":"40_progsys_execv/#exemple","text":"","title":"Exemple"},{"location":"40_progsys_execv/#code","text":"Programme principal : Programme fils : /* calcul.c */ int main ( void ) { int pid , status ; char * argv [ 2 ]; pid = fork (); if ( pid == 0 ) { printf ( \"je le fils:pid=%d \" , getpid ()); argv [ 0 ] = \"carre\" ; argv [ 1 ] = NULL ; execv ( \" /home/carre \" , argv ); } printf ( \" je suis le p\u00e8re: pid=%d \" , getpid ()); wait ( & status ); printf ( \" le carre = %d \" , status / 256 ); exit ( 0 ); } /* carre.c*/ int main ( int argc , char * arg []) { int x ; printf ( \" je le fils:pid=%d \" , getpid ()); printf ( \"pid de mon pere=%d \" , getppid ()); printf ( \" x = \" ); scanf ( \" %d \" , & x ); x = x * x : exit ( x ); }","title":"Code"},{"location":"40_progsys_execv/#schema","text":"","title":"Sch\u00e9ma"},{"location":"40_progsys_files/","text":"Programmation Syst\u00e8me - E/S bas niveau \u2693\ufe0e Manipuler des fichiers \u2693\ufe0e Le but est de savoir manipuler tous les fichiers quels que soient leur type. Ainsi nous sauront aussi bien g\u00e9rer un fichier ASCII ou un Pipe depuis notre code C ! Nous allons nous int\u00e9resser aux fonctions suivantes : - open : ouverture - read : lecture - write : \u00e9criture - close : fermeture - lseek : positionnement Il faudra ajouter les includes suivants : 1 2 #include <fcntl.h> #include <sys/types.h> Descripteurs de fichiers \u2693\ufe0e Ils sont utilis\u00e9s pour d\u00e9signer le fichier dans les op\u00e9rations: open , read , write , close ... C'est le nom local du fichier dans le processus. On dispose de 20 descripteurs seulement pour chaque processus (0 .. 19) dont 3 descripteurs allou\u00e9s automatiquement : \u2013 0 entr\u00e9e standard \u2013 1 sortie standard \u2013 2 sortie erreur De plus, un curseur (pointeur) dans le fichier est associ\u00e9 \u00e0 chaque descripteur. Ce curseur se deplace lors des l\u00e9ctures/\u00e9critures et peut \u00eatre d\u00e9plac\u00e9. Cela permet d'aller lire ou \u00e9crire uniquement certains octets ! Primitives \u2693\ufe0e Open \u2693\ufe0e Permet d'ouvrir un fichier afin de la manipuler. C'est la seule primitive qui utilisera la nom du fichier pour s'y r\u00e9f\u00e9rer, puis lui assignera un descripteur \u00e0 utiliser dans les autres primitives. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int open ( char * path , int mode ); int open ( char * path , int mode , int perm ); \u2013 path : chemin d \u2019 acc\u00e8s au fichier \u2013 mode ; mode d \u2019 ouverture : \u2022 O_RDONLY \u2022 O_WRONLY \u2022 O_RDWR \u2022 O_APPEND \u2022 O_CREAT \u2022 O_TRUNC \u2022 etc ... \u2013 perm : droits d \u2019 acc\u00e8s du fichier en cas de cr\u00e9ation \u2013 r\u00e9sultat : descripteur de fichier Exemple \u2693\ufe0e 1 2 3 4 5 int desc ; desc = open ( \" fichier \" , O_RDONLY ); int desc ; desc = open ( \" fichier \" , O_WRONLY | O_CREAT , 0666 ); Write \u2693\ufe0e Permet d'\u00e9crire des donn\u00e9es dans un fichier, en s'y r\u00e9f\u00e9rant par son descripteur. Chaque \u00e9criture d\u00e9place le curseur dans le fichier (vers le bas). 1 2 3 4 5 6 7 int write ( int desc , void * buf , int nboct ); \u2013 desc : descripteur de fichier \u2013 buf : adresse de tampon des donn\u00e9es \u00e0 \u00e9 crire \u2013 nboct : nombre d \u2019 octets \u00e0 \u00e9 crire \u2013 r\u00e9sultat : nombre d \u2019 octets effectivement \u00e9 crits , -1 en cas d \u2019 erreur Exemple \u2693\ufe0e 1 2 3 4 char ch [ 10 ] = \"exemple\" ; int x = 1 ; write ( desc , ch , sizeof ( ch ); write ( desc , & x , sizeof ( int )); Read \u2693\ufe0e Permet de lire des donn\u00e9es dans un fichier, en s'y r\u00e9f\u00e9rant par son descripteur. Chaque lecture d\u00e9place le curseur dans le fichier (vers le bas). Pour lire une donn\u00e9e, il faut donc que le curseur se situe au d\u00e9but de celle-ci avant de lire ! 1 2 3 4 5 6 7 int read ( int desc , void * buf , int nboct ); \u2013 desc : descripteur de fichier \u2013 buf : adresse de tampon des donn\u00e9es \u00e0 lire \u2013 nboct : nombre d \u2019 octets lus \u2013 r\u00e9sultat : nombre d \u2019 octets effectivement lus , 0 si fin de fichier , -1 en cas d \u2019 erreur Exemple \u2693\ufe0e 1 2 3 4 char ch [ 10 ]; int x , nb ; nb = read ( desc , ch , 10 ); nb = read ( desc , & x , sizeof ( int )); Close \u2693\ufe0e Permet la fermeture du fichier et la lib\u00e9ration de son descripteur. 1 2 3 4 5 int close ( int desc ); \u2013 desc : descripteur de fichier \u2013 r\u00e9sultat : -1 en cas d \u2019 echec , 0 sinon Exemple \u2693\ufe0e 1 close ( desc ); Lseek \u2693\ufe0e Permet de d\u00e9placer manuellement le curseur dans un fichier. On le deplacer d'un offset positif ou n\u00e9gatif (en octets ), \u00e0 partir de trois r\u00e9f\u00e9rences : - SEEK_SET : Le d\u00e9but du fichier - SEEK_END : La fin du fichier - SEEK_CUR : La position courante du curseur 1 2 3 4 5 6 7 int lseek ( int desc , int offset , int whence ); \u2013 desc : descripteur de fichier \u2013 whence : origine du d\u00e9placement -> SEEK_SET , SEEK_CUR , SEEK_END \u2013 offset : valeur du d\u00e9placement en octet \u2013 r\u00e9sultat : nouvelle position ( en octets ) depuis le d\u00e9but du fichier Exemple \u2693\ufe0e 1 int newPos = lseek ( 1 , 4 , SEEK_CUR );","title":"Programmation Syst\u00e8me - E/S Bas Niveau"},{"location":"40_progsys_files/#programmation-systeme-es-bas-niveau","text":"","title":"Programmation Syst\u00e8me - E/S bas niveau"},{"location":"40_progsys_files/#manipuler-des-fichiers","text":"Le but est de savoir manipuler tous les fichiers quels que soient leur type. Ainsi nous sauront aussi bien g\u00e9rer un fichier ASCII ou un Pipe depuis notre code C ! Nous allons nous int\u00e9resser aux fonctions suivantes : - open : ouverture - read : lecture - write : \u00e9criture - close : fermeture - lseek : positionnement Il faudra ajouter les includes suivants : 1 2 #include <fcntl.h> #include <sys/types.h>","title":"Manipuler des fichiers"},{"location":"40_progsys_files/#descripteurs-de-fichiers","text":"Ils sont utilis\u00e9s pour d\u00e9signer le fichier dans les op\u00e9rations: open , read , write , close ... C'est le nom local du fichier dans le processus. On dispose de 20 descripteurs seulement pour chaque processus (0 .. 19) dont 3 descripteurs allou\u00e9s automatiquement : \u2013 0 entr\u00e9e standard \u2013 1 sortie standard \u2013 2 sortie erreur De plus, un curseur (pointeur) dans le fichier est associ\u00e9 \u00e0 chaque descripteur. Ce curseur se deplace lors des l\u00e9ctures/\u00e9critures et peut \u00eatre d\u00e9plac\u00e9. Cela permet d'aller lire ou \u00e9crire uniquement certains octets !","title":"Descripteurs de fichiers"},{"location":"40_progsys_files/#primitives","text":"","title":"Primitives"},{"location":"40_progsys_files/#open","text":"Permet d'ouvrir un fichier afin de la manipuler. C'est la seule primitive qui utilisera la nom du fichier pour s'y r\u00e9f\u00e9rer, puis lui assignera un descripteur \u00e0 utiliser dans les autres primitives. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int open ( char * path , int mode ); int open ( char * path , int mode , int perm ); \u2013 path : chemin d \u2019 acc\u00e8s au fichier \u2013 mode ; mode d \u2019 ouverture : \u2022 O_RDONLY \u2022 O_WRONLY \u2022 O_RDWR \u2022 O_APPEND \u2022 O_CREAT \u2022 O_TRUNC \u2022 etc ... \u2013 perm : droits d \u2019 acc\u00e8s du fichier en cas de cr\u00e9ation \u2013 r\u00e9sultat : descripteur de fichier","title":"Open"},{"location":"40_progsys_files/#exemple","text":"1 2 3 4 5 int desc ; desc = open ( \" fichier \" , O_RDONLY ); int desc ; desc = open ( \" fichier \" , O_WRONLY | O_CREAT , 0666 );","title":"Exemple"},{"location":"40_progsys_files/#write","text":"Permet d'\u00e9crire des donn\u00e9es dans un fichier, en s'y r\u00e9f\u00e9rant par son descripteur. Chaque \u00e9criture d\u00e9place le curseur dans le fichier (vers le bas). 1 2 3 4 5 6 7 int write ( int desc , void * buf , int nboct ); \u2013 desc : descripteur de fichier \u2013 buf : adresse de tampon des donn\u00e9es \u00e0 \u00e9 crire \u2013 nboct : nombre d \u2019 octets \u00e0 \u00e9 crire \u2013 r\u00e9sultat : nombre d \u2019 octets effectivement \u00e9 crits , -1 en cas d \u2019 erreur","title":"Write"},{"location":"40_progsys_files/#exemple_1","text":"1 2 3 4 char ch [ 10 ] = \"exemple\" ; int x = 1 ; write ( desc , ch , sizeof ( ch ); write ( desc , & x , sizeof ( int ));","title":"Exemple"},{"location":"40_progsys_files/#read","text":"Permet de lire des donn\u00e9es dans un fichier, en s'y r\u00e9f\u00e9rant par son descripteur. Chaque lecture d\u00e9place le curseur dans le fichier (vers le bas). Pour lire une donn\u00e9e, il faut donc que le curseur se situe au d\u00e9but de celle-ci avant de lire ! 1 2 3 4 5 6 7 int read ( int desc , void * buf , int nboct ); \u2013 desc : descripteur de fichier \u2013 buf : adresse de tampon des donn\u00e9es \u00e0 lire \u2013 nboct : nombre d \u2019 octets lus \u2013 r\u00e9sultat : nombre d \u2019 octets effectivement lus , 0 si fin de fichier , -1 en cas d \u2019 erreur","title":"Read"},{"location":"40_progsys_files/#exemple_2","text":"1 2 3 4 char ch [ 10 ]; int x , nb ; nb = read ( desc , ch , 10 ); nb = read ( desc , & x , sizeof ( int ));","title":"Exemple"},{"location":"40_progsys_files/#close","text":"Permet la fermeture du fichier et la lib\u00e9ration de son descripteur. 1 2 3 4 5 int close ( int desc ); \u2013 desc : descripteur de fichier \u2013 r\u00e9sultat : -1 en cas d \u2019 echec , 0 sinon","title":"Close"},{"location":"40_progsys_files/#exemple_3","text":"1 close ( desc );","title":"Exemple"},{"location":"40_progsys_files/#lseek","text":"Permet de d\u00e9placer manuellement le curseur dans un fichier. On le deplacer d'un offset positif ou n\u00e9gatif (en octets ), \u00e0 partir de trois r\u00e9f\u00e9rences : - SEEK_SET : Le d\u00e9but du fichier - SEEK_END : La fin du fichier - SEEK_CUR : La position courante du curseur 1 2 3 4 5 6 7 int lseek ( int desc , int offset , int whence ); \u2013 desc : descripteur de fichier \u2013 whence : origine du d\u00e9placement -> SEEK_SET , SEEK_CUR , SEEK_END \u2013 offset : valeur du d\u00e9placement en octet \u2013 r\u00e9sultat : nouvelle position ( en octets ) depuis le d\u00e9but du fichier","title":"Lseek"},{"location":"40_progsys_files/#exemple_4","text":"1 int newPos = lseek ( 1 , 4 , SEEK_CUR );","title":"Exemple"},{"location":"40_progsys_fork/","text":"Programmation Syst\u00e8me - Fork \u2693\ufe0e Rappels : Programme vs. Processus \u2693\ufe0e important Programme : entit\u00e9 statique , une suite d'instructions compil\u00e9es Processus : entit\u00e9 dynamique , poss\u00e8de un PID, c'est l'\u00e9xecution d'un programme. Poss\u00e8de un contexte propre. Cr\u00e9ation d'un Processus \u2693\ufe0e R\u00e8gle d'Or : tout processus UNIX peut cr\u00e9er un ou plusieurs processus. Donc pour cr\u00e9er un processus nouveau, il en faut d\u00e9j\u00e0 un exustant ... qui va \u00eatre clon\u00e9 , puis sp\u00e9cialis\u00e9 . Il y a donc une filiation entre les processus ! Primitives \u2693\ufe0e PID Courant \u2693\ufe0e 1 pid_t getpid ( void ); Retourne le pid du processus courant (appelant) PID du P\u00e8re \u2693\ufe0e 1 pid_t getppid ( void ); Retourne le pid du p\u00e8re du processus courant (appelant) Tip Le pendant en Shell serait la commande : ps Suspension \u2693\ufe0e 1 2 int sleep ( int nb_sec ); int usleep ( int nb_msec ); sleep endort le processus jusqu'\u00e0 ce que nb_sec secondes se soient \u00e9coul\u00e9es, ou jusqu'\u00e0 ce qu'un signal non-ignor\u00e9 soit re\u00e7u. usleep endort le processus jusqu'\u00e0 ce que nb_msec micro-secondes se soient \u00e9coul\u00e9es, ou jusqu'\u00e0 ce qu'un signal non-ignor\u00e9 soit re\u00e7u. Renvoient z\u00e9ro si le temps pr\u00e9vu s'est \u00e9coul\u00e9, ou le nombre de secondes (micro-secondes) restantes si un signal a r\u00e9veill\u00e9 le processus. Cr\u00e9ation de processus \u2693\ufe0e 1 pid_t fork ( void ); Permet la cr\u00e9ation dynamique d\u2019un nouveau processus (fils) . par duplication du processus courant (p\u00e8re) . Le processus fils ne diff\u00e8re du processus p\u00e8re que par les pid et ppid . Les 2 processus ( p\u00e8re et fils ) s\u2019ex\u00e9cutent de mani\u00e8re concurrente ! Tip Biblioth\u00e8ques : #include <sys/types.h> #include <unistd.h> Retourne un entier : En cas de succ\u00e8s: 0 dans le fils pid du fils dans le p\u00e8re En cas d\u2019\u00e9chec -1 dans le p\u00e8re le fils n\u2019est pas cr\u00e9\u00e9 Tr\u00e8s Important ! La valeur retourn\u00e9e par fork permet donc de faire la distinction entre le p\u00e8re et le fils ! Exemple basique \u2693\ufe0e 1 2 3 4 5 6 7 8 9 10 11 12 int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) printf ( \" Je suis le FILS \" ); else printf ( \" Je suis le PERE \" ); return 0 ; } Apr\u00e8s fork : allocation d\u2019une ent\u00e9e dans la table des processus au nouveau processus allocation d \u2019un pid au nouveau processus duplication du contexte du processus p\u00e8re (donn\u00e9es, pile\u2026) retour du pid du processus fils \u00e0 son p\u00e8re et 0 au processus fils Affichons les PID respectifs : Dans le ==p\u00e8re== (PID suppos\u00e9 : 1234) : Dans le ==fils== (PID suppos\u00e9 : 2345): int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); printf ( \" mon pid est = %d \" , getpid ()); } else { printf ( \" Je suis le pere \" ); printf ( \" mon pid est = %d \" , getpid ()); } } int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); printf ( \" mon pid est = %d \" , getpid ()); } else { printf ( \" Je suis le pere \" ); printf ( \" mon pid est = %d \" , getpid ()); } } Affichages : 1 2 Je suis le pere mon pid est = 1234 Je suis le fils mon pid est = 2345 PID diff\u00e9rents: 1234 et 2345 Les 2 processus ex\u00e9cute le m\u00eame programme ! On ne peut pas pr\u00e9dire l'ordre des printf !! Synchronisation \u2693\ufe0e Primitives \u2693\ufe0e Exit \u2693\ufe0e 1 void exit ( int status ); Exit : \u2013 termine le processus appelant. \u2013 transmet la valeur de status (le mot d\u2019\u00e9tat ) au processus p\u00e8re \u2013 ferme les descripteurs de fichiers ouverts \u2013 un signal SIGCHLD est envoy\u00e9 au processus p\u00e8re. Wait \u2693\ufe0e 1 pid_t wait ( int * status ); Wait : \u2013 attend la terminaison ou l'arr\u00eat d'un processus fils (fils quelconque ). \u2013 retourne le PID d'un processus termin\u00e9, -1 en cas d\u2019erreur (si tous sont d\u00e9j\u00e0 termin\u00e9s). \u2013 stocke la valeur transmise par le fils (exit) dans l'entier point\u00e9 par status. Warning Le status est cod\u00e9 sur le 2\u00e8me octet de l'int point\u00e9 : Exemple complet \u2693\ufe0e Dans le ==p\u00e8re== (PID suppos\u00e9 : 1234) : Dans le ==fils== (PID suppos\u00e9 : 2345): int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); exit ( 3 ); } else { printf ( \" Je suis le pere \" ); printf ( \" j \u2019attends la fin de mon fils); wait ( & status ); printf ( \" status = %d \" , status >> 8 ); } return 0 ; } int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); exit ( 3 ); } else { printf ( \" Je suis le pere \" ); printf ( \" j \u2019attends la fin de mon fils); wait ( & status ); printf ( \" status = %d \" , status >> 8 ); } return 0 ; } Affichages : 1 2 3 4 Je suis le fils Je suis le pere j \u2019attends la fin de mon fils status = 3 On ne peut pas pr\u00e9dire l'ordre des 3 premiers printf . Par contre on sait forc\u00e9ment que l'affichage du status se fera en dernier ! Lorsqu\u2019un processus se termine ( exit ), le syst\u00e8me d\u00e9truit son contexte, sauf son entr\u00e9e de la table des processus Le procesus est alors dit dans un \u00e9tat ZOMBI (momentan\u00e9 si bien cod\u00e9) Le processus p\u00e8re r\u00e9cup\u00e8re la mort de son fils ( wait ), et d\u00e9truit son entr\u00e9e de la table des processus. Le fils dispara\u00eet compl\u00e8tement du syst\u00e8me (n\u2019est plus zombi). La communication entre le fils zombi et le p\u00e8re s \u2019effectue par le biais d \u2019un signal transmis du fils vers le p\u00e8re (signal SIGCHLD : la mort du fils). Un processus fils d\u00e9funt reste zombie jusqu\u2019\u00e0 ce que son p\u00e8re ait pris connaissance de sa mort (wait). Danger Une mauvaise synchronisation = saturation table des processus = blocage total du syst\u00e8me ! Adoption \u2693\ufe0e Si le p\u00e8re d\u00e9c\u00e8de avant le fils alors le fils deviendra orphelin et sera adopt\u00e9 par le processus de PID 1 (init). Exemple de Zombi \u2693\ufe0e Warning Ceci est un code faux ... \u00e0 des fins p\u00e9dagogiques ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /*Programme pgmzombi.c */ int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" je suis le FILS pid = %d \\n \" , getpid ()); sleep ( 10 ); printf ( \" je suis le FILS, \u00e0 dieu \\n \" ); } else { printf ( \"je suis le PERE pid = %d \\n \" , getpid ()); printf ( \"je suis le PERE je boucle \u00e0 l\u2019infini \" ); for ( ; ; ); } return 0 ; } On suppose que le pid du p\u00e8re est 1234 et celui du fils est 2345. R\u00e9sultat de l\u2019ex\u00e9cution en arri\u00e8re-plan: > pgmzombi & je suis le pere pid = 1234 je suis le pere je boucle \u00e0 l\u2019infini je suis le fils pid = 2345 je suis le fils, \u00e0 dieu Avant la mort du fils : Apr\u00e8s la mort du fils : # ps 1234 tty3 0 :04 pgmzombi 2345 tty3 0 :03 pgmzombi # ps 1234 tty3 0 :04 pgmzombi 2345 tty3 0 :03 [ defunct ] Exercice - Zombi War \u2693\ufe0e Copiez/Collez ce programme Zombi. Observez vous m\u00eame le Zombi. Enfin, corrigez le code afin de le rendre propre !","title":"Programmation Syst\u00e8me - Fork"},{"location":"40_progsys_fork/#programmation-systeme-fork","text":"","title":"Programmation Syst\u00e8me - Fork"},{"location":"40_progsys_fork/#rappels-programme-vs-processus","text":"important Programme : entit\u00e9 statique , une suite d'instructions compil\u00e9es Processus : entit\u00e9 dynamique , poss\u00e8de un PID, c'est l'\u00e9xecution d'un programme. Poss\u00e8de un contexte propre.","title":"Rappels : Programme vs. Processus"},{"location":"40_progsys_fork/#creation-dun-processus","text":"R\u00e8gle d'Or : tout processus UNIX peut cr\u00e9er un ou plusieurs processus. Donc pour cr\u00e9er un processus nouveau, il en faut d\u00e9j\u00e0 un exustant ... qui va \u00eatre clon\u00e9 , puis sp\u00e9cialis\u00e9 . Il y a donc une filiation entre les processus !","title":"Cr\u00e9ation d'un Processus"},{"location":"40_progsys_fork/#primitives","text":"","title":"Primitives"},{"location":"40_progsys_fork/#pid-courant","text":"1 pid_t getpid ( void ); Retourne le pid du processus courant (appelant)","title":"PID Courant"},{"location":"40_progsys_fork/#pid-du-pere","text":"1 pid_t getppid ( void ); Retourne le pid du p\u00e8re du processus courant (appelant) Tip Le pendant en Shell serait la commande : ps","title":"PID du P\u00e8re"},{"location":"40_progsys_fork/#suspension","text":"1 2 int sleep ( int nb_sec ); int usleep ( int nb_msec ); sleep endort le processus jusqu'\u00e0 ce que nb_sec secondes se soient \u00e9coul\u00e9es, ou jusqu'\u00e0 ce qu'un signal non-ignor\u00e9 soit re\u00e7u. usleep endort le processus jusqu'\u00e0 ce que nb_msec micro-secondes se soient \u00e9coul\u00e9es, ou jusqu'\u00e0 ce qu'un signal non-ignor\u00e9 soit re\u00e7u. Renvoient z\u00e9ro si le temps pr\u00e9vu s'est \u00e9coul\u00e9, ou le nombre de secondes (micro-secondes) restantes si un signal a r\u00e9veill\u00e9 le processus.","title":"Suspension"},{"location":"40_progsys_fork/#creation-de-processus","text":"1 pid_t fork ( void ); Permet la cr\u00e9ation dynamique d\u2019un nouveau processus (fils) . par duplication du processus courant (p\u00e8re) . Le processus fils ne diff\u00e8re du processus p\u00e8re que par les pid et ppid . Les 2 processus ( p\u00e8re et fils ) s\u2019ex\u00e9cutent de mani\u00e8re concurrente ! Tip Biblioth\u00e8ques : #include <sys/types.h> #include <unistd.h> Retourne un entier : En cas de succ\u00e8s: 0 dans le fils pid du fils dans le p\u00e8re En cas d\u2019\u00e9chec -1 dans le p\u00e8re le fils n\u2019est pas cr\u00e9\u00e9 Tr\u00e8s Important ! La valeur retourn\u00e9e par fork permet donc de faire la distinction entre le p\u00e8re et le fils !","title":"Cr\u00e9ation de processus"},{"location":"40_progsys_fork/#exemple-basique","text":"1 2 3 4 5 6 7 8 9 10 11 12 int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) printf ( \" Je suis le FILS \" ); else printf ( \" Je suis le PERE \" ); return 0 ; } Apr\u00e8s fork : allocation d\u2019une ent\u00e9e dans la table des processus au nouveau processus allocation d \u2019un pid au nouveau processus duplication du contexte du processus p\u00e8re (donn\u00e9es, pile\u2026) retour du pid du processus fils \u00e0 son p\u00e8re et 0 au processus fils Affichons les PID respectifs : Dans le ==p\u00e8re== (PID suppos\u00e9 : 1234) : Dans le ==fils== (PID suppos\u00e9 : 2345): int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); printf ( \" mon pid est = %d \" , getpid ()); } else { printf ( \" Je suis le pere \" ); printf ( \" mon pid est = %d \" , getpid ()); } } int main ( void ) { pid_t pid ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); printf ( \" mon pid est = %d \" , getpid ()); } else { printf ( \" Je suis le pere \" ); printf ( \" mon pid est = %d \" , getpid ()); } } Affichages : 1 2 Je suis le pere mon pid est = 1234 Je suis le fils mon pid est = 2345 PID diff\u00e9rents: 1234 et 2345 Les 2 processus ex\u00e9cute le m\u00eame programme ! On ne peut pas pr\u00e9dire l'ordre des printf !!","title":"Exemple basique"},{"location":"40_progsys_fork/#synchronisation","text":"","title":"Synchronisation"},{"location":"40_progsys_fork/#primitives_1","text":"","title":"Primitives"},{"location":"40_progsys_fork/#exit","text":"1 void exit ( int status ); Exit : \u2013 termine le processus appelant. \u2013 transmet la valeur de status (le mot d\u2019\u00e9tat ) au processus p\u00e8re \u2013 ferme les descripteurs de fichiers ouverts \u2013 un signal SIGCHLD est envoy\u00e9 au processus p\u00e8re.","title":"Exit"},{"location":"40_progsys_fork/#wait","text":"1 pid_t wait ( int * status ); Wait : \u2013 attend la terminaison ou l'arr\u00eat d'un processus fils (fils quelconque ). \u2013 retourne le PID d'un processus termin\u00e9, -1 en cas d\u2019erreur (si tous sont d\u00e9j\u00e0 termin\u00e9s). \u2013 stocke la valeur transmise par le fils (exit) dans l'entier point\u00e9 par status. Warning Le status est cod\u00e9 sur le 2\u00e8me octet de l'int point\u00e9 :","title":"Wait"},{"location":"40_progsys_fork/#exemple-complet","text":"Dans le ==p\u00e8re== (PID suppos\u00e9 : 1234) : Dans le ==fils== (PID suppos\u00e9 : 2345): int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); exit ( 3 ); } else { printf ( \" Je suis le pere \" ); printf ( \" j \u2019attends la fin de mon fils); wait ( & status ); printf ( \" status = %d \" , status >> 8 ); } return 0 ; } int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" Je suis le fils\" ); exit ( 3 ); } else { printf ( \" Je suis le pere \" ); printf ( \" j \u2019attends la fin de mon fils); wait ( & status ); printf ( \" status = %d \" , status >> 8 ); } return 0 ; } Affichages : 1 2 3 4 Je suis le fils Je suis le pere j \u2019attends la fin de mon fils status = 3 On ne peut pas pr\u00e9dire l'ordre des 3 premiers printf . Par contre on sait forc\u00e9ment que l'affichage du status se fera en dernier ! Lorsqu\u2019un processus se termine ( exit ), le syst\u00e8me d\u00e9truit son contexte, sauf son entr\u00e9e de la table des processus Le procesus est alors dit dans un \u00e9tat ZOMBI (momentan\u00e9 si bien cod\u00e9) Le processus p\u00e8re r\u00e9cup\u00e8re la mort de son fils ( wait ), et d\u00e9truit son entr\u00e9e de la table des processus. Le fils dispara\u00eet compl\u00e8tement du syst\u00e8me (n\u2019est plus zombi). La communication entre le fils zombi et le p\u00e8re s \u2019effectue par le biais d \u2019un signal transmis du fils vers le p\u00e8re (signal SIGCHLD : la mort du fils). Un processus fils d\u00e9funt reste zombie jusqu\u2019\u00e0 ce que son p\u00e8re ait pris connaissance de sa mort (wait). Danger Une mauvaise synchronisation = saturation table des processus = blocage total du syst\u00e8me !","title":"Exemple complet"},{"location":"40_progsys_fork/#adoption","text":"Si le p\u00e8re d\u00e9c\u00e8de avant le fils alors le fils deviendra orphelin et sera adopt\u00e9 par le processus de PID 1 (init).","title":"Adoption"},{"location":"40_progsys_fork/#exemple-de-zombi","text":"Warning Ceci est un code faux ... \u00e0 des fins p\u00e9dagogiques ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /*Programme pgmzombi.c */ int main ( void ) { int pid , status ; pid = fork (); if ( pid == 0 ) { printf ( \" je suis le FILS pid = %d \\n \" , getpid ()); sleep ( 10 ); printf ( \" je suis le FILS, \u00e0 dieu \\n \" ); } else { printf ( \"je suis le PERE pid = %d \\n \" , getpid ()); printf ( \"je suis le PERE je boucle \u00e0 l\u2019infini \" ); for ( ; ; ); } return 0 ; } On suppose que le pid du p\u00e8re est 1234 et celui du fils est 2345. R\u00e9sultat de l\u2019ex\u00e9cution en arri\u00e8re-plan: > pgmzombi & je suis le pere pid = 1234 je suis le pere je boucle \u00e0 l\u2019infini je suis le fils pid = 2345 je suis le fils, \u00e0 dieu Avant la mort du fils : Apr\u00e8s la mort du fils : # ps 1234 tty3 0 :04 pgmzombi 2345 tty3 0 :03 pgmzombi # ps 1234 tty3 0 :04 pgmzombi 2345 tty3 0 :03 [ defunct ]","title":"Exemple de Zombi"},{"location":"40_progsys_fork/#exercice-zombi-war","text":"Copiez/Collez ce programme Zombi. Observez vous m\u00eame le Zombi. Enfin, corrigez le code afin de le rendre propre !","title":"Exercice - Zombi War"},{"location":"40_progsys_pipes/","text":"Programmation Syst\u00e8me - Pipes \u2693\ufe0e D\u00e9finition \u2693\ufe0e Les pipes sont des objets permettant l\u2019\u00e9change de donn\u00e9es entre processus sur une m\u00eame machine . Les pipes sont bien connus dans le monde d'Unix. En effet, ils permettent de faire communiquer deux processus entre eux. Ils sont repr\u00e9sent\u00e9s par le caract\u00e8re | . On les utilisent courrament dans les terminaux pour rediriger la sortie d'une commande vers l'entr\u00e9 d'une autre commande, par exemple : \"\"ls | wc\"\". Mais nous avons les m\u00eames possibilit\u00e9s dans un programme en langage C, ou ces pipes seront g\u00e9r\u00e9s comme des fichiers. Les lectures/\u00e9critures dans un pipe se font avec les fonctions read() et write() classiques. Il existe deux types de pipes en C : - Anonymes - Nomm\u00e9s Echanges \u2693\ufe0e Chronologiques \u2693\ufe0e Les \u00e9changes se font de mani\u00e8re chronologique , en FIFO : les donn\u00e9es lues sont celles \u00e9crites depuis le plus longtemps. Les lectures sont destructrices ! Atomiques \u2693\ufe0e Les \u00e9changes se font de mani\u00e8re atomique : si 2 t\u00e2ches \u00e9crivent dans un m\u00eame pipe respectivement m et n octets en \"m\u00eame temps\" ces octets restent disjoints. Synchronis\u00e9s \u2693\ufe0e Les \u00e9changes se font de mani\u00e8re synchronis\u00e9s : une t\u00e2che qui veut lire dans un pipe vide est suspendue jusqu\u2019\u00e0 l\u2019\u00e9criture d\u2019octets une t\u00e2che qui veut ouvrir en lecture un pipe qui n\u2019est pas d\u00e9j\u00e0 ouvert en \u00e9criture est suspendue une t\u00e2che qui veut ouvrir en \u00e9criture un pipe qui n\u2019est pas d\u00e9j\u00e0 ouvert en lecture est suspendue une t\u00e2che qui veut lire dans un pipe vide qui n\u2019est plus ouvert en \u00e9criture re\u00e7oit le compte-rendu \"fin de fichier\" Pipe dans un processus unique \u2693\ufe0e Cr\u00e9er un pipe dans un processus unique n'a pas beaucoup d'inter\u00eat mais cela nous permet de comprendre ce qui caract\u00e9rise un pipe : Un pipe poss\u00e8de deux extremit\u00e9s. Il n'est possible de faire passer des informations que dans un sens unique . On peut donc \u00e9crire des informations \u00e0 l'entr\u00e9 et en lire \u00e0 la sortie. Les deux extr\u00e9mit\u00e9s sont r\u00e9f\u00e9renc\u00e9s par des descripteurs de fichiers (des entiers stock\u00e9s dans la variable fd). Pipe entre un processus et son fils \u2693\ufe0e La diff\u00e9rence avec l'exemple pr\u00e9cedent est que, en plus de cr\u00e9er un pipe, notre processus cr\u00e9 un fils. Le pipe est alors automatiquement partag\u00e9 entre le p\u00e8re et le fils. Si l'un \u00e9crit dans le pipe alors on ne sait pas lequel des deux va recevoir l'information. Ceci peut donner des r\u00e9sultats inattendus. Pour \u00eatre certain de qui va \u00e9crire et qui va lire dans le pipe, il faut que les processus ferment les extr\u00e9mit\u00e9s qu'ils n'utilisent pas . De cette fa\u00e7on le processus p\u00e8re peut \u00eatre certain que s'il \u00e9crit dans le pipe ( fd[1] ), le fils va re\u00e7evoir l'information en lecture ( fd[0] ). Si l'on souhaite \u00e9changer des informations dans l'autre sens il faut cr\u00e9er un deuxi\u00e8me pipe et l'initialiser dans l'autre sens. Pipe Anonymes \u2693\ufe0e C'est un objet sans nom , et n'est donc pas un fichier stock\u00e9 sur disque de mani\u00e8re permanente. Il n'est connu que par les processus de m\u00eame filiation. Il poss\u00e8de : - 2 descripteurs: lecture / \u00e9criture stock\u00e9s dans un tableau - 2 pointeurs automatiques: lecture / \u00e9criture Caract\u00e9ristiques : - L\u2019ouverture se fait au moment de la cr\u00e9ation par pipe() et non par open() - Taille limit\u00e9e - Le 1er qui lit r\u00e9cup\u00e8re les donn\u00e9es La fonction lseek() est non utilisable ! Creation \u2693\ufe0e 1 2 3 4 5 6 int pipe ( int desc [ 2 ] ); \u2013 desc [ 0 ] : descripteur de lecture \u2013 desc [ 1 ] : descripteur d \u2019\u00e9 criture \u2013 R\u00e9sultat : 0 si cr\u00e9ation du pipe , -1 sinon Exemple simple \u2693\ufe0e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main ( void ) { int desc [ 2 ]; int pid ; char buf [ 7 ]; pipe ( desc ); // Cr\u00e9ation et ouverture du pipe pid = fork (); if ( pid == 0 ) { close ( desc [ 0 ]); // Fermeture du pipe en lecture write ( desc [ 1 ], \"coucou\" , 7 ); // Ecriture dans le pipe close ( desc [ 1 ]); // Fermeture du pipe en \u00e9criture exit ( 0 ); } else { close ( desc [ 1 ]); // Fermeture du pipe en \u00e9criture read ( desc [ 0 ], buf , 7 ); // Lecture dans le pipe wait ( NULL ); close ( desc [ 0 ]); // Fermeture du pipe en lecture } } Exemple complet \u2693\ufe0e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include <stdio.h> #include <unistd.h> #include <sys/types.h> #include <string.h> #include <stdlib.h> #include <signal.h> #define BUFFER_SIZE 25 #define READ 0 #define WRITE 1 int mypipefd [ 2 ]; void interruptPere ( int sig ){ printf ( \"Interrupt pere : SIGUSR1 fils re\u00e7ut %d \\n \" , sig ); wait ( NULL ); printf ( \"Interrupt pere : le fils est mort par son exit(1) \\n \" ); close ( mypipefd [ WRITE ]); printf ( \"Interrupt pere : fermeture du pipe et fin du p\u00e8re \\n \" ); exit ( 0 ); } void interruptFils ( int sig ){ printf ( \"Interrupt fils : CTRLC Catch\u00e9 ! \\n \" ); close ( mypipefd [ READ ]); printf ( \"Interrupt fils : fermeture du pipe \\n \" ); kill ( getppid (), SIGUSR1 ); printf ( \"Interrupt fils : signal SIGUSR1 envoy\u00e9 au p\u00e8re \\n \" ); exit ( 1 ); } int main ( void ) { pid_t pid ; /* create the pipe */ if ( pipe ( mypipefd ) == -1 ) { fprintf ( stderr , \"Pipe failed\" ); return 1 ; } /* now fork a child process */ pid = fork (); if ( pid < 0 ) { fprintf ( stderr , \"Fork failed\" ); return 1 ; } if ( pid > 0 ) { /* parent process */ signal ( SIGINT , SIG_IGN ); signal ( SIGUSR1 , interruptPere ); int parentVal = 0 ; close ( mypipefd [ READ ]); //close read end, write while ( 1 ) { sleep ( 3 ); parentVal ++ ; write ( mypipefd [ WRITE ], & parentVal , sizeof ( parentVal )); printf ( \"Parent: writes value : %d \\n \" , parentVal ); } } else { /* child process */ signal ( SIGINT , interruptFils ); int childVal = 0 ; close ( mypipefd [ WRITE ]); while ( 1 ) { //sleep(1); read ( mypipefd [ READ ], & childVal , sizeof ( childVal )); printf ( \"child: read value : %d \\n \" , childVal ); } close ( mypipefd [ READ ]); } } Pipe Nomm\u00e9s \u2693\ufe0e Cette fois-ci c'est un fichier sp\u00e9cial de type pipe, r\u00e9f\u00e9renc\u00e9 par un chemin dans l\u2019arborescence (porte un nom et persiste apr\u00e8s la mort des processus). Il permet donc la communication entre deux processus s\u2019ex\u00e9cutant sur la m\u00eame machine sans forc\u00e9ment qu'ils aient une filiation directe. Ils poss\u00e8dent un seul descripteur par ouverture. Pointeurs automatiques: lseek() non utilisable ! Creation \u2693\ufe0e 1 2 3 4 5 6 int mkfifo ( char * ref , int mode ); \u2013 ref : nom du pipe \u2013 mode : droits d \u2019 acc\u00e8s Resultat : 0 si cr\u00e9ation , -1 sinon . Les pipe nomm\u00e9s peuvent \u00eatre cr\u00e9\u00e9s en utilisant la commande unix: mkfifo Ouverture \u2693\ufe0e 1 2 3 4 5 6 7 8 9 int open ( char * path , int mode ); \u2013 path : chemin d \u2019 acc\u00e8s au fichier \u2013 mode : mode d \u2019 ouverture \u2022 O_RDONLY \u2022 O_WRONLY \u2022 O_RDWR R\u00e9sultat : descripteur de fichier du pipe Fermeture \u2693\ufe0e 1 2 3 4 5 int close ( int desc ); \u2013 desc : descripteur de fichier R\u00e9sultat : -1 en cas d \u2019 echec , 0 sinon Destruction \u2693\ufe0e 1 2 3 4 5 int unlink ( char * ref ); \u2013 ref : nom du pipe R\u00e9sultat : -1 en cas d \u2019 echec , 0 sinon Cela correspond \u00e0 rm ref sous unix ! Exemple \u2693\ufe0e Programme principal : Programme fils : #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid , desc , nb ; char buf [ 80 ]; unlink ( \"pipe\" ); mkfifo ( \"pipe\" , 0666 ); pid = fork (); if ( pid == 0 ) execv ( \"fille\" , NULL ); desc = open ( \"pipe\" , O_RDONLY ); nb = read ( desc , buf , 80 ); buf [ nb ] = '\\0' ; printf ( \" message: %s \\n \" , buf ); close ( desc ); wait ( NULL ); exit ( 0 ); } #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int dp ; sleep ( 8 ); dp = open ( \"pipe\" , O_WRONLY ); write ( dp , \"coucou \" , 7 ) ; close ( dp ); exit ( 0 ); }","title":"Programmation Syst\u00e8me - Pipes"},{"location":"40_progsys_pipes/#programmation-systeme-pipes","text":"","title":"Programmation Syst\u00e8me - Pipes"},{"location":"40_progsys_pipes/#definition","text":"Les pipes sont des objets permettant l\u2019\u00e9change de donn\u00e9es entre processus sur une m\u00eame machine . Les pipes sont bien connus dans le monde d'Unix. En effet, ils permettent de faire communiquer deux processus entre eux. Ils sont repr\u00e9sent\u00e9s par le caract\u00e8re | . On les utilisent courrament dans les terminaux pour rediriger la sortie d'une commande vers l'entr\u00e9 d'une autre commande, par exemple : \"\"ls | wc\"\". Mais nous avons les m\u00eames possibilit\u00e9s dans un programme en langage C, ou ces pipes seront g\u00e9r\u00e9s comme des fichiers. Les lectures/\u00e9critures dans un pipe se font avec les fonctions read() et write() classiques. Il existe deux types de pipes en C : - Anonymes - Nomm\u00e9s","title":"D\u00e9finition"},{"location":"40_progsys_pipes/#echanges","text":"","title":"Echanges"},{"location":"40_progsys_pipes/#chronologiques","text":"Les \u00e9changes se font de mani\u00e8re chronologique , en FIFO : les donn\u00e9es lues sont celles \u00e9crites depuis le plus longtemps. Les lectures sont destructrices !","title":"Chronologiques"},{"location":"40_progsys_pipes/#atomiques","text":"Les \u00e9changes se font de mani\u00e8re atomique : si 2 t\u00e2ches \u00e9crivent dans un m\u00eame pipe respectivement m et n octets en \"m\u00eame temps\" ces octets restent disjoints.","title":"Atomiques"},{"location":"40_progsys_pipes/#synchronises","text":"Les \u00e9changes se font de mani\u00e8re synchronis\u00e9s : une t\u00e2che qui veut lire dans un pipe vide est suspendue jusqu\u2019\u00e0 l\u2019\u00e9criture d\u2019octets une t\u00e2che qui veut ouvrir en lecture un pipe qui n\u2019est pas d\u00e9j\u00e0 ouvert en \u00e9criture est suspendue une t\u00e2che qui veut ouvrir en \u00e9criture un pipe qui n\u2019est pas d\u00e9j\u00e0 ouvert en lecture est suspendue une t\u00e2che qui veut lire dans un pipe vide qui n\u2019est plus ouvert en \u00e9criture re\u00e7oit le compte-rendu \"fin de fichier\"","title":"Synchronis\u00e9s"},{"location":"40_progsys_pipes/#pipe-dans-un-processus-unique","text":"Cr\u00e9er un pipe dans un processus unique n'a pas beaucoup d'inter\u00eat mais cela nous permet de comprendre ce qui caract\u00e9rise un pipe : Un pipe poss\u00e8de deux extremit\u00e9s. Il n'est possible de faire passer des informations que dans un sens unique . On peut donc \u00e9crire des informations \u00e0 l'entr\u00e9 et en lire \u00e0 la sortie. Les deux extr\u00e9mit\u00e9s sont r\u00e9f\u00e9renc\u00e9s par des descripteurs de fichiers (des entiers stock\u00e9s dans la variable fd).","title":"Pipe dans un processus unique"},{"location":"40_progsys_pipes/#pipe-entre-un-processus-et-son-fils","text":"La diff\u00e9rence avec l'exemple pr\u00e9cedent est que, en plus de cr\u00e9er un pipe, notre processus cr\u00e9 un fils. Le pipe est alors automatiquement partag\u00e9 entre le p\u00e8re et le fils. Si l'un \u00e9crit dans le pipe alors on ne sait pas lequel des deux va recevoir l'information. Ceci peut donner des r\u00e9sultats inattendus. Pour \u00eatre certain de qui va \u00e9crire et qui va lire dans le pipe, il faut que les processus ferment les extr\u00e9mit\u00e9s qu'ils n'utilisent pas . De cette fa\u00e7on le processus p\u00e8re peut \u00eatre certain que s'il \u00e9crit dans le pipe ( fd[1] ), le fils va re\u00e7evoir l'information en lecture ( fd[0] ). Si l'on souhaite \u00e9changer des informations dans l'autre sens il faut cr\u00e9er un deuxi\u00e8me pipe et l'initialiser dans l'autre sens.","title":"Pipe entre un processus et son fils"},{"location":"40_progsys_pipes/#pipe-anonymes","text":"C'est un objet sans nom , et n'est donc pas un fichier stock\u00e9 sur disque de mani\u00e8re permanente. Il n'est connu que par les processus de m\u00eame filiation. Il poss\u00e8de : - 2 descripteurs: lecture / \u00e9criture stock\u00e9s dans un tableau - 2 pointeurs automatiques: lecture / \u00e9criture Caract\u00e9ristiques : - L\u2019ouverture se fait au moment de la cr\u00e9ation par pipe() et non par open() - Taille limit\u00e9e - Le 1er qui lit r\u00e9cup\u00e8re les donn\u00e9es La fonction lseek() est non utilisable !","title":"Pipe Anonymes"},{"location":"40_progsys_pipes/#creation","text":"1 2 3 4 5 6 int pipe ( int desc [ 2 ] ); \u2013 desc [ 0 ] : descripteur de lecture \u2013 desc [ 1 ] : descripteur d \u2019\u00e9 criture \u2013 R\u00e9sultat : 0 si cr\u00e9ation du pipe , -1 sinon","title":"Creation"},{"location":"40_progsys_pipes/#exemple-simple","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main ( void ) { int desc [ 2 ]; int pid ; char buf [ 7 ]; pipe ( desc ); // Cr\u00e9ation et ouverture du pipe pid = fork (); if ( pid == 0 ) { close ( desc [ 0 ]); // Fermeture du pipe en lecture write ( desc [ 1 ], \"coucou\" , 7 ); // Ecriture dans le pipe close ( desc [ 1 ]); // Fermeture du pipe en \u00e9criture exit ( 0 ); } else { close ( desc [ 1 ]); // Fermeture du pipe en \u00e9criture read ( desc [ 0 ], buf , 7 ); // Lecture dans le pipe wait ( NULL ); close ( desc [ 0 ]); // Fermeture du pipe en lecture } }","title":"Exemple simple"},{"location":"40_progsys_pipes/#exemple-complet","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include <stdio.h> #include <unistd.h> #include <sys/types.h> #include <string.h> #include <stdlib.h> #include <signal.h> #define BUFFER_SIZE 25 #define READ 0 #define WRITE 1 int mypipefd [ 2 ]; void interruptPere ( int sig ){ printf ( \"Interrupt pere : SIGUSR1 fils re\u00e7ut %d \\n \" , sig ); wait ( NULL ); printf ( \"Interrupt pere : le fils est mort par son exit(1) \\n \" ); close ( mypipefd [ WRITE ]); printf ( \"Interrupt pere : fermeture du pipe et fin du p\u00e8re \\n \" ); exit ( 0 ); } void interruptFils ( int sig ){ printf ( \"Interrupt fils : CTRLC Catch\u00e9 ! \\n \" ); close ( mypipefd [ READ ]); printf ( \"Interrupt fils : fermeture du pipe \\n \" ); kill ( getppid (), SIGUSR1 ); printf ( \"Interrupt fils : signal SIGUSR1 envoy\u00e9 au p\u00e8re \\n \" ); exit ( 1 ); } int main ( void ) { pid_t pid ; /* create the pipe */ if ( pipe ( mypipefd ) == -1 ) { fprintf ( stderr , \"Pipe failed\" ); return 1 ; } /* now fork a child process */ pid = fork (); if ( pid < 0 ) { fprintf ( stderr , \"Fork failed\" ); return 1 ; } if ( pid > 0 ) { /* parent process */ signal ( SIGINT , SIG_IGN ); signal ( SIGUSR1 , interruptPere ); int parentVal = 0 ; close ( mypipefd [ READ ]); //close read end, write while ( 1 ) { sleep ( 3 ); parentVal ++ ; write ( mypipefd [ WRITE ], & parentVal , sizeof ( parentVal )); printf ( \"Parent: writes value : %d \\n \" , parentVal ); } } else { /* child process */ signal ( SIGINT , interruptFils ); int childVal = 0 ; close ( mypipefd [ WRITE ]); while ( 1 ) { //sleep(1); read ( mypipefd [ READ ], & childVal , sizeof ( childVal )); printf ( \"child: read value : %d \\n \" , childVal ); } close ( mypipefd [ READ ]); } }","title":"Exemple complet"},{"location":"40_progsys_pipes/#pipe-nommes","text":"Cette fois-ci c'est un fichier sp\u00e9cial de type pipe, r\u00e9f\u00e9renc\u00e9 par un chemin dans l\u2019arborescence (porte un nom et persiste apr\u00e8s la mort des processus). Il permet donc la communication entre deux processus s\u2019ex\u00e9cutant sur la m\u00eame machine sans forc\u00e9ment qu'ils aient une filiation directe. Ils poss\u00e8dent un seul descripteur par ouverture. Pointeurs automatiques: lseek() non utilisable !","title":"Pipe Nomm\u00e9s"},{"location":"40_progsys_pipes/#creation_1","text":"1 2 3 4 5 6 int mkfifo ( char * ref , int mode ); \u2013 ref : nom du pipe \u2013 mode : droits d \u2019 acc\u00e8s Resultat : 0 si cr\u00e9ation , -1 sinon . Les pipe nomm\u00e9s peuvent \u00eatre cr\u00e9\u00e9s en utilisant la commande unix: mkfifo","title":"Creation"},{"location":"40_progsys_pipes/#ouverture","text":"1 2 3 4 5 6 7 8 9 int open ( char * path , int mode ); \u2013 path : chemin d \u2019 acc\u00e8s au fichier \u2013 mode : mode d \u2019 ouverture \u2022 O_RDONLY \u2022 O_WRONLY \u2022 O_RDWR R\u00e9sultat : descripteur de fichier du pipe","title":"Ouverture"},{"location":"40_progsys_pipes/#fermeture","text":"1 2 3 4 5 int close ( int desc ); \u2013 desc : descripteur de fichier R\u00e9sultat : -1 en cas d \u2019 echec , 0 sinon","title":"Fermeture"},{"location":"40_progsys_pipes/#destruction","text":"1 2 3 4 5 int unlink ( char * ref ); \u2013 ref : nom du pipe R\u00e9sultat : -1 en cas d \u2019 echec , 0 sinon Cela correspond \u00e0 rm ref sous unix !","title":"Destruction"},{"location":"40_progsys_pipes/#exemple","text":"Programme principal : Programme fils : #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid , desc , nb ; char buf [ 80 ]; unlink ( \"pipe\" ); mkfifo ( \"pipe\" , 0666 ); pid = fork (); if ( pid == 0 ) execv ( \"fille\" , NULL ); desc = open ( \"pipe\" , O_RDONLY ); nb = read ( desc , buf , 80 ); buf [ nb ] = '\\0' ; printf ( \" message: %s \\n \" , buf ); close ( desc ); wait ( NULL ); exit ( 0 ); } #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int dp ; sleep ( 8 ); dp = open ( \"pipe\" , O_WRONLY ); write ( dp , \"coucou \" , 7 ) ; close ( dp ); exit ( 0 ); }","title":"Exemple"},{"location":"40_progsys_signals/","text":"Programmation Syst\u00e8me - Signaux \u2693\ufe0e D\u00e9finition \u2693\ufe0e Les signaux constituent un m\u00e9canisme de fondamental de communication entre processus : Ils sont utilis\u00e9s par un processus pour signaler \u00e0 un autre processus (ou \u00e0 un groupe de processus) l\u2019arriv\u00e9e d\u2019un \u00e9v\u00e9nement qui peut \u00eatre : \u2013 mat\u00e9riel \u2013 li\u00e9 au fonctionnement multit\u00e2che \u2013 li\u00e9 \u00e0 une application sp\u00e9cifique Ce sont des interruptions logicielles ! Exemples de Signaux \u2693\ufe0e Liste non exhaustive ... Nom N\u00b0 Fonction SIGHUP 1 d\u00e9connection du terminal SIGINT 2 interruption ^C SIGQUIT 3 abandon ^\\ (core) SIGKILL 9 destruction (ne peut \u00eatre ignor\u00e9) SIGUSR1 10 r\u00e9serv\u00e9 \u00e0 l\u2019utilisateur (communication inter-processus) SIGUSR2 12 r\u00e9serv\u00e9 \u00e0 l\u2019utilisateur (communication inter-processus) SIGPIPE 13 essai d\u2019\u00e9criture dans un pipe non ouvert SIGALRM 14 horloge (arr\u00eat de l\u2019horloge d\u2019un processus: alarm() ) SIGTERM 15 terminaison normale d\u2019un processus SIGCHLD 17 mort d\u2019un fils (envoy\u00e9 au p\u00e8re) ... ... ... Tout ces signaux se trouvent dans le fichier header : signal.h Le comportement par d\u00e9faut des signaux SIGUSR1 et SIGUSR2 est : SIGKILL ! Si non red\u00e9finis, leur reception entrainera la mort du processus vis\u00e9 ... Traitements \u2693\ufe0e Il y a 3 actions possibles lors de la reception d'un signal par un processus : - L' ignorance : SIG_IGN - La prise en compte pour effectuer une action sp\u00e9cifique : nomFonction - La restauration du comportement par defaut : SIG_DFL Certains signaux ne peuvent pas \u00eatre ignor\u00e9s, par exemple SIGKILL . Dans le cas d'une action sp\u00e9cifique : - l\u2019action est faite dans une fonction qui doit \u00eatre sp\u00e9cifiquement attach\u00e9e au signal donn\u00e9. - cet attachement est valable pour toute la dur\u00e9e du programme. A l\u2019arriv\u00e9e du signal : \u2013 le traitement en cours est interrompu \u2013 la fonction est ex\u00e9cut\u00e9e \u2013 le traitement est repris o\u00f9 il en \u00e9tait avant l'interruption Primitives \u2693\ufe0e Signal \u2693\ufe0e La primitive signal() permet de sp\u00e9cifier le comportement d\u2019un processus \u00e0 la r\u00e9ception d\u2019un signal donn\u00e9. C'est une fonction non bloquante qu'il faut voir comme une configuration utilis\u00e9e plus tard, lors de la reception du signal. 1 2 3 4 5 #include <signal.h> void ( * signal ( int sig , void ( * fcn )( int )))( int ) - sig : num\u00e9ro du signal - ( * fcn ) : action apr\u00e8s r\u00e9ception -> Intercepte le signal de num\u00e9ro sig -> Ex\u00e9cute la fonction fcn Exemples \u2693\ufe0e 1 2 signal ( SIGUSR1 , traite ) ; signal ( SIGINT , SIG_IGN ); Kill \u2693\ufe0e La primitive kill() permet d\u2019envoyer un signal \u00e0 un processus, via son PID . L\u2019envoi de signal ne peut se faire qu\u2019entre t\u00e2ches de m\u00eame UID. Si on utilise PID = 0 : tous les processus du groupe sont concern\u00e9s (broadcast). Elle envoie n'importe quel signal, pas uniquement SIGKILL malgr\u00e8s son nom !! 1 2 3 4 5 #include <signal.h> int kill ( int pid , int no_signal ); \u2013 pid no du process r\u00e9cepteur \u2013 r\u00e9sultat : 0 si le signal a \u00e9 t\u00e9 envoy\u00e9 , -1 sinon ( erreur ) Exemples \u2693\ufe0e 1 2 kill ( 0 , SIGUSR1 ); kill ( 1234 , SIGKILL ); Pause \u2693\ufe0e La primitive pause() correspond \u00e0 de l\u2019attente pure, d'un signal quelconque . C'est une fonction bloquante . 1 2 3 4 void pause ( void ); - Elle ne fait rien - Attend l \u2019 arriv\u00e9e d \u2019 un signal quelconque Exemple \u2693\ufe0e 1 pause (); Alarm \u2693\ufe0e La primitive alarm() envoi un signal de type SIGALRM au processus appelant apr\u00e8s laps de temps (en seconde). C'est une fonction non bloquante . 1 2 3 4 5 6 7 8 #include <unistd.h> int alarm ( int sec ); - resultat : temps \u00e9 coul\u00e9 depuis le dernier appel \u00e0 alarm (); Note : - l ' appel \u00e0 alarm ( 0 ); annule toutes les alarmes enregistr\u00e9es ! - chaque appel enreigistre une nouvelle alarme , en indiquant en retour le temps restant pour l ' alarme pr\u00e9c\u00e9demment enregistr\u00e9e . Exemple \u2693\ufe0e 1 alarm ( 12 ); Exemple complet \u2693\ufe0e Dans le p\u00e8re : Dans le fils : #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid ; pid = fork (); if ( pid == 0 ) execv ( \"fille\" , NULL ); signal ( SIGUSR1 , fonc ); for (;;) { printf ( \" je boucle \\n \" ); sleep ( 1 ); } } void fonc ( int sig ) { printf ( \" signal recu %d \\n \" , sig ); exit ( 0 ); } #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { sleep ( 5 ); kill ( getppid (), SIGUSR1 ); exit ( 0 ); } La position de l'appel \u00e0 signal() dans le programme est tr\u00e8s importante ! La configuration doit \u00eatre faite avant la reception du signal en question !","title":"Programmation Syst\u00e8me - Signaux"},{"location":"40_progsys_signals/#programmation-systeme-signaux","text":"","title":"Programmation Syst\u00e8me - Signaux"},{"location":"40_progsys_signals/#definition","text":"Les signaux constituent un m\u00e9canisme de fondamental de communication entre processus : Ils sont utilis\u00e9s par un processus pour signaler \u00e0 un autre processus (ou \u00e0 un groupe de processus) l\u2019arriv\u00e9e d\u2019un \u00e9v\u00e9nement qui peut \u00eatre : \u2013 mat\u00e9riel \u2013 li\u00e9 au fonctionnement multit\u00e2che \u2013 li\u00e9 \u00e0 une application sp\u00e9cifique Ce sont des interruptions logicielles !","title":"D\u00e9finition"},{"location":"40_progsys_signals/#exemples-de-signaux","text":"Liste non exhaustive ... Nom N\u00b0 Fonction SIGHUP 1 d\u00e9connection du terminal SIGINT 2 interruption ^C SIGQUIT 3 abandon ^\\ (core) SIGKILL 9 destruction (ne peut \u00eatre ignor\u00e9) SIGUSR1 10 r\u00e9serv\u00e9 \u00e0 l\u2019utilisateur (communication inter-processus) SIGUSR2 12 r\u00e9serv\u00e9 \u00e0 l\u2019utilisateur (communication inter-processus) SIGPIPE 13 essai d\u2019\u00e9criture dans un pipe non ouvert SIGALRM 14 horloge (arr\u00eat de l\u2019horloge d\u2019un processus: alarm() ) SIGTERM 15 terminaison normale d\u2019un processus SIGCHLD 17 mort d\u2019un fils (envoy\u00e9 au p\u00e8re) ... ... ... Tout ces signaux se trouvent dans le fichier header : signal.h Le comportement par d\u00e9faut des signaux SIGUSR1 et SIGUSR2 est : SIGKILL ! Si non red\u00e9finis, leur reception entrainera la mort du processus vis\u00e9 ...","title":"Exemples de Signaux"},{"location":"40_progsys_signals/#traitements","text":"Il y a 3 actions possibles lors de la reception d'un signal par un processus : - L' ignorance : SIG_IGN - La prise en compte pour effectuer une action sp\u00e9cifique : nomFonction - La restauration du comportement par defaut : SIG_DFL Certains signaux ne peuvent pas \u00eatre ignor\u00e9s, par exemple SIGKILL . Dans le cas d'une action sp\u00e9cifique : - l\u2019action est faite dans une fonction qui doit \u00eatre sp\u00e9cifiquement attach\u00e9e au signal donn\u00e9. - cet attachement est valable pour toute la dur\u00e9e du programme. A l\u2019arriv\u00e9e du signal : \u2013 le traitement en cours est interrompu \u2013 la fonction est ex\u00e9cut\u00e9e \u2013 le traitement est repris o\u00f9 il en \u00e9tait avant l'interruption","title":"Traitements"},{"location":"40_progsys_signals/#primitives","text":"","title":"Primitives"},{"location":"40_progsys_signals/#signal","text":"La primitive signal() permet de sp\u00e9cifier le comportement d\u2019un processus \u00e0 la r\u00e9ception d\u2019un signal donn\u00e9. C'est une fonction non bloquante qu'il faut voir comme une configuration utilis\u00e9e plus tard, lors de la reception du signal. 1 2 3 4 5 #include <signal.h> void ( * signal ( int sig , void ( * fcn )( int )))( int ) - sig : num\u00e9ro du signal - ( * fcn ) : action apr\u00e8s r\u00e9ception -> Intercepte le signal de num\u00e9ro sig -> Ex\u00e9cute la fonction fcn","title":"Signal"},{"location":"40_progsys_signals/#exemples","text":"1 2 signal ( SIGUSR1 , traite ) ; signal ( SIGINT , SIG_IGN );","title":"Exemples"},{"location":"40_progsys_signals/#kill","text":"La primitive kill() permet d\u2019envoyer un signal \u00e0 un processus, via son PID . L\u2019envoi de signal ne peut se faire qu\u2019entre t\u00e2ches de m\u00eame UID. Si on utilise PID = 0 : tous les processus du groupe sont concern\u00e9s (broadcast). Elle envoie n'importe quel signal, pas uniquement SIGKILL malgr\u00e8s son nom !! 1 2 3 4 5 #include <signal.h> int kill ( int pid , int no_signal ); \u2013 pid no du process r\u00e9cepteur \u2013 r\u00e9sultat : 0 si le signal a \u00e9 t\u00e9 envoy\u00e9 , -1 sinon ( erreur )","title":"Kill"},{"location":"40_progsys_signals/#exemples_1","text":"1 2 kill ( 0 , SIGUSR1 ); kill ( 1234 , SIGKILL );","title":"Exemples"},{"location":"40_progsys_signals/#pause","text":"La primitive pause() correspond \u00e0 de l\u2019attente pure, d'un signal quelconque . C'est une fonction bloquante . 1 2 3 4 void pause ( void ); - Elle ne fait rien - Attend l \u2019 arriv\u00e9e d \u2019 un signal quelconque","title":"Pause"},{"location":"40_progsys_signals/#exemple","text":"1 pause ();","title":"Exemple"},{"location":"40_progsys_signals/#alarm","text":"La primitive alarm() envoi un signal de type SIGALRM au processus appelant apr\u00e8s laps de temps (en seconde). C'est une fonction non bloquante . 1 2 3 4 5 6 7 8 #include <unistd.h> int alarm ( int sec ); - resultat : temps \u00e9 coul\u00e9 depuis le dernier appel \u00e0 alarm (); Note : - l ' appel \u00e0 alarm ( 0 ); annule toutes les alarmes enregistr\u00e9es ! - chaque appel enreigistre une nouvelle alarme , en indiquant en retour le temps restant pour l ' alarme pr\u00e9c\u00e9demment enregistr\u00e9e .","title":"Alarm"},{"location":"40_progsys_signals/#exemple_1","text":"1 alarm ( 12 );","title":"Exemple"},{"location":"40_progsys_signals/#exemple-complet","text":"Dans le p\u00e8re : Dans le fils : #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid ; pid = fork (); if ( pid == 0 ) execv ( \"fille\" , NULL ); signal ( SIGUSR1 , fonc ); for (;;) { printf ( \" je boucle \\n \" ); sleep ( 1 ); } } void fonc ( int sig ) { printf ( \" signal recu %d \\n \" , sig ); exit ( 0 ); } #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { sleep ( 5 ); kill ( getppid (), SIGUSR1 ); exit ( 0 ); } La position de l'appel \u00e0 signal() dans le programme est tr\u00e8s importante ! La configuration doit \u00eatre faite avant la reception du signal en question !","title":"Exemple complet"},{"location":"41_progsys_tp1_proc/","text":"Programmation Syst\u00e8me : TP1 - Echauffement \u2693\ufe0e Programme avec Param\u00e8tres \u2693\ufe0e Exercice 1 \u2693\ufe0e Ecrire un programme qui affiche ses param\u00e8tres puis les variables d\u2019environnement de votre OS. Tip En C, il existe 3 prototypes de fonction main : 1 2 3 int main ( void ); int main ( int argc , char * argv []); int main ( int argc , char * argv [], char * arge []); A vous de choisir celle appropri\u00e9e ! Un petit coup de Google ne fait pas de mal ... Exercice 2 \u2693\ufe0e Ecrire un programme de calculatrice simple, qui prends deux nombres ainsi que l'op\u00e9rateur en param\u00e8tres. Ex d'\u00e9xecution attendue : 1 2 calc 5 + 3 r\u00e9sultat = 8","title":"Programmation Syst\u00e8me - TP1 Echauffement"},{"location":"41_progsys_tp1_proc/#programmation-systeme-tp1-echauffement","text":"","title":"Programmation Syst\u00e8me : TP1 - Echauffement"},{"location":"41_progsys_tp1_proc/#programme-avec-parametres","text":"","title":"Programme avec Param\u00e8tres"},{"location":"41_progsys_tp1_proc/#exercice-1","text":"Ecrire un programme qui affiche ses param\u00e8tres puis les variables d\u2019environnement de votre OS. Tip En C, il existe 3 prototypes de fonction main : 1 2 3 int main ( void ); int main ( int argc , char * argv []); int main ( int argc , char * argv [], char * arge []); A vous de choisir celle appropri\u00e9e ! Un petit coup de Google ne fait pas de mal ...","title":"Exercice 1"},{"location":"41_progsys_tp1_proc/#exercice-2","text":"Ecrire un programme de calculatrice simple, qui prends deux nombres ainsi que l'op\u00e9rateur en param\u00e8tres. Ex d'\u00e9xecution attendue : 1 2 calc 5 + 3 r\u00e9sultat = 8","title":"Exercice 2"},{"location":"41_progsys_tp1_proc_corr/","text":"Programmation Syst\u00e8me : TP1 - Echauffement \u2693\ufe0e Programme avec Param\u00e8tres \u2693\ufe0e Exercice 1 \u2693\ufe0e Ecrire un programme qui affiche ses param\u00e8tres puis les variables d\u2019environnement de votre OS. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( int argc , char * argv [], char * arge []) { //Partie variables d'env printf ( \"Nombre d'arguments = %d \\n \" , argc ); for ( i = 0 ; i < argc ; i ++ ) printf ( \"Argument %d : %s \\n \" , i , argv [ i ]); printf ( \"Variables d'env: \\n \" ); i = 0 ; while ( arge [ i ] != NULL ) { printf ( \"Variable d'Env[%d]=%s \\n \" , i , arge [ i ]); i ++ ; } return 0 ; } Exercice 2 \u2693\ufe0e Ecrire un programme de calculatrice simple, qui prends deux nombres ainsi que l'op\u00e9rateur en param\u00e8tres. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( int argc , char * argv [], char * arge []) { //Partie Calculette int o1 , o2 ; char op ; int res ; int i = 0 ; if ( argc != 4 ) { printf ( \" \\t J'attends 3 arguments pass\u00e9s au programme ! \\n \" ); exit ( 0 ); } o1 = atoi ( argv [ 1 ]); o2 = atoi ( argv [ 3 ]); op =* ( argv [ 2 ]); switch ( op ) { case '+' : res = o1 + o2 ; break ; case '-' : res = o1 - o2 ; break ; case '*' : res = o1 * o2 ; break ; case '/' : res = o1 / o2 ; break ; default : printf ( \"erreur d'operande \\n \" ); } printf ( \"res=%d \\n \" , res ); return 0 ; } Zombie War \u2693\ufe0e Exercice 3 \u2693\ufe0e Ecrire un programme en C qui cr\u00e9er deux processus et qui met en valeur le ph\u00e9nom\u00e8ne des processus zombie . Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { pid_t pid ; pid = fork (); if ( pid == -1 ) { printf ( \"Error on fork \\n \" ); exit ( -1 ); } if ( pid == 0 ) { printf ( \"FILS : mon pid = %d et celui de mon pere est %d \\n \" , getpid (), getppid ()); sleep ( 10 ); printf ( \">>> mort du fils \\n \" ); } else { printf ( \" PERE : mon pid = %d, j'attends la mort de mon fils \\n \" , getpid ()); sleep ( 20 ); //Pendant 10 sec on observe le zombie ... exit ( 0 ); } } Le corriger pour le rendre \u00ab propre \u00bb ! Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { pid_t pid ; pid = fork (); if ( pid == -1 ) { printf ( \"Error on fork \\n \" ); exit ( -1 ); } if ( pid == 0 ) { printf ( \"FILS : mon pid = %d et celui de mon pere est %d \\n \" , getpid (), getppid ()); sleep ( 10 ); printf ( \">>> mort du fils \\n \" ); exit ( 0 ); } else { printf ( \" PERE : mon pid = %d, j'attends la mort de mon fils \\n \" , getpid ()); wait ( NULL ); printf ( \"Pere : j'ai recut la mort de mon fils, je peux mourir en Paix. RIP. \\n \" ); sleep ( 10 ); // Pendant ces 10 sec, on n'observe PLUS de Zombie :) exit ( 0 ); } }","title":""},{"location":"41_progsys_tp1_proc_corr/#programmation-systeme-tp1-echauffement","text":"","title":"Programmation Syst\u00e8me : TP1 - Echauffement"},{"location":"41_progsys_tp1_proc_corr/#programme-avec-parametres","text":"","title":"Programme avec Param\u00e8tres"},{"location":"41_progsys_tp1_proc_corr/#exercice-1","text":"Ecrire un programme qui affiche ses param\u00e8tres puis les variables d\u2019environnement de votre OS. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( int argc , char * argv [], char * arge []) { //Partie variables d'env printf ( \"Nombre d'arguments = %d \\n \" , argc ); for ( i = 0 ; i < argc ; i ++ ) printf ( \"Argument %d : %s \\n \" , i , argv [ i ]); printf ( \"Variables d'env: \\n \" ); i = 0 ; while ( arge [ i ] != NULL ) { printf ( \"Variable d'Env[%d]=%s \\n \" , i , arge [ i ]); i ++ ; } return 0 ; }","title":"Exercice 1"},{"location":"41_progsys_tp1_proc_corr/#exercice-2","text":"Ecrire un programme de calculatrice simple, qui prends deux nombres ainsi que l'op\u00e9rateur en param\u00e8tres. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( int argc , char * argv [], char * arge []) { //Partie Calculette int o1 , o2 ; char op ; int res ; int i = 0 ; if ( argc != 4 ) { printf ( \" \\t J'attends 3 arguments pass\u00e9s au programme ! \\n \" ); exit ( 0 ); } o1 = atoi ( argv [ 1 ]); o2 = atoi ( argv [ 3 ]); op =* ( argv [ 2 ]); switch ( op ) { case '+' : res = o1 + o2 ; break ; case '-' : res = o1 - o2 ; break ; case '*' : res = o1 * o2 ; break ; case '/' : res = o1 / o2 ; break ; default : printf ( \"erreur d'operande \\n \" ); } printf ( \"res=%d \\n \" , res ); return 0 ; }","title":"Exercice 2"},{"location":"41_progsys_tp1_proc_corr/#zombie-war","text":"","title":"Zombie War"},{"location":"41_progsys_tp1_proc_corr/#exercice-3","text":"Ecrire un programme en C qui cr\u00e9er deux processus et qui met en valeur le ph\u00e9nom\u00e8ne des processus zombie . Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { pid_t pid ; pid = fork (); if ( pid == -1 ) { printf ( \"Error on fork \\n \" ); exit ( -1 ); } if ( pid == 0 ) { printf ( \"FILS : mon pid = %d et celui de mon pere est %d \\n \" , getpid (), getppid ()); sleep ( 10 ); printf ( \">>> mort du fils \\n \" ); } else { printf ( \" PERE : mon pid = %d, j'attends la mort de mon fils \\n \" , getpid ()); sleep ( 20 ); //Pendant 10 sec on observe le zombie ... exit ( 0 ); } } Le corriger pour le rendre \u00ab propre \u00bb ! Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { pid_t pid ; pid = fork (); if ( pid == -1 ) { printf ( \"Error on fork \\n \" ); exit ( -1 ); } if ( pid == 0 ) { printf ( \"FILS : mon pid = %d et celui de mon pere est %d \\n \" , getpid (), getppid ()); sleep ( 10 ); printf ( \">>> mort du fils \\n \" ); exit ( 0 ); } else { printf ( \" PERE : mon pid = %d, j'attends la mort de mon fils \\n \" , getpid ()); wait ( NULL ); printf ( \"Pere : j'ai recut la mort de mon fils, je peux mourir en Paix. RIP. \\n \" ); sleep ( 10 ); // Pendant ces 10 sec, on n'observe PLUS de Zombie :) exit ( 0 ); } }","title":"Exercice 3"},{"location":"41_progsys_tp2_proc/","text":"Programmation Syst\u00e8me : TP2 - Fork/Execv \u2693\ufe0e Sur Papier \u2693\ufe0e Exercice 1 : Arbre g\u00e9n\u00e9alogique \u2693\ufe0e On a le code suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main () { int p1 , p2 , p3 ; p1 = p2 = p3 = -1 ; p1 = fork (); p2 = fork (); p3 = fork (); if ( p1 == 0 ) execv ( \"F1\" , NULL ); if ( p2 == 0 ) execv ( \"F2\" , NULL ); if ( p3 == 0 ) execv ( \"F3\" , NULL ); pause (); exit ( 0 ); } Combien de processus s'executent ? Sur quels programmes (P\u00e8re, F1, F2 et F3) ? Justifiez vos r\u00e9ponses en dessinant un arbre g\u00e9n\u00e9alogique. Exercice 2 : Lecture de code \u2693\ufe0e On suppose que le pid du p\u00e8re est 100 et celui du fils 200, quelles sont les valeurs affich\u00e9es par le programme ci-dessous ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { int pid ; int x = 0 ; x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); pid = fork (); if ( pid == 0 ) { x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } else printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } A coder ! \u2693\ufe0e Exercice 3 : fork() \u2693\ufe0e Dans un m\u00eame programme , un processus en active un autre et se met en attente de la fin de celui-ci, r\u00e9cup\u00e8re le mot d\u2019\u00e9tat (valeur retourn\u00e9e par exit() ) transmis et l\u2019affiche. Chacun des processus affiche son PID et celui de son p\u00e8re. Le p\u00e8re affiche en plus le PID de son fils. Tip Les simples mots \"Dans un m\u00eame programme\" impliquent un fork() ! Exercice 4 : execv() \u2693\ufe0e Un processus (programme P) en active un autre F en lui transmettant une chaine de caract\u00e8res saisie au clavier. F calcule la longueur de la chaine et la transmet comme mot d\u2019\u00e9tat \u00e0 P . P affiche la longueur. Tip Les simples mots \"Un programme ... en active un autre \" impliquent : fork() + execv() !","title":"Programmation Syst\u00e8me - TP2 Fork/Execv"},{"location":"41_progsys_tp2_proc/#programmation-systeme-tp2-forkexecv","text":"","title":"Programmation Syst\u00e8me : TP2 - Fork/Execv"},{"location":"41_progsys_tp2_proc/#sur-papier","text":"","title":"Sur Papier"},{"location":"41_progsys_tp2_proc/#exercice-1-arbre-genealogique","text":"On a le code suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main () { int p1 , p2 , p3 ; p1 = p2 = p3 = -1 ; p1 = fork (); p2 = fork (); p3 = fork (); if ( p1 == 0 ) execv ( \"F1\" , NULL ); if ( p2 == 0 ) execv ( \"F2\" , NULL ); if ( p3 == 0 ) execv ( \"F3\" , NULL ); pause (); exit ( 0 ); } Combien de processus s'executent ? Sur quels programmes (P\u00e8re, F1, F2 et F3) ? Justifiez vos r\u00e9ponses en dessinant un arbre g\u00e9n\u00e9alogique.","title":"Exercice 1 : Arbre g\u00e9n\u00e9alogique"},{"location":"41_progsys_tp2_proc/#exercice-2-lecture-de-code","text":"On suppose que le pid du p\u00e8re est 100 et celui du fils 200, quelles sont les valeurs affich\u00e9es par le programme ci-dessous ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main ( void ) { int pid ; int x = 0 ; x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); pid = fork (); if ( pid == 0 ) { x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } else printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); }","title":"Exercice 2 : Lecture de code"},{"location":"41_progsys_tp2_proc/#a-coder","text":"","title":"A coder !"},{"location":"41_progsys_tp2_proc/#exercice-3-fork","text":"Dans un m\u00eame programme , un processus en active un autre et se met en attente de la fin de celui-ci, r\u00e9cup\u00e8re le mot d\u2019\u00e9tat (valeur retourn\u00e9e par exit() ) transmis et l\u2019affiche. Chacun des processus affiche son PID et celui de son p\u00e8re. Le p\u00e8re affiche en plus le PID de son fils. Tip Les simples mots \"Dans un m\u00eame programme\" impliquent un fork() !","title":"Exercice 3 : fork()"},{"location":"41_progsys_tp2_proc/#exercice-4-execv","text":"Un processus (programme P) en active un autre F en lui transmettant une chaine de caract\u00e8res saisie au clavier. F calcule la longueur de la chaine et la transmet comme mot d\u2019\u00e9tat \u00e0 P . P affiche la longueur. Tip Les simples mots \"Un programme ... en active un autre \" impliquent : fork() + execv() !","title":"Exercice 4 : execv()"},{"location":"41_progsys_tp2_proc_corr/","text":"Programmation Syst\u00e8me : TP2 - Processus \u2693\ufe0e Sur Papier \u2693\ufe0e Exercice 1 : Arbre g\u00e9n\u00e9alogique \u2693\ufe0e On a le code suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main () { int p1 , p2 , p3 ; p1 = p2 = p3 = -1 ; p1 = fork (); p2 = fork (); p3 = fork (); if ( p1 == 0 ) execv ( \"F1\" , NULL ); if ( p2 == 0 ) execv ( \"F2\" , NULL ); if ( p3 == 0 ) execv ( \"F3\" , NULL ); pause (); exit ( 0 ); } Combien de processus s'executent ? Sur quels programmes (P\u00e8re, F1, F2 et F3) ? Justifiez vos r\u00e9ponses en dessinant un arbre g\u00e9n\u00e9alogique. Exercice 2 : Lecture de code \u2693\ufe0e On suppose que le pid du p\u00e8re est 100 et celui du fils 200, quelles sont les valeurs affich\u00e9es par le programme ci-dessous ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid ; int x = 0 ; x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); pid = fork (); if ( pid == 0 ) { x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } else printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } Solution 1 2 3 4 5 mon pid est 100 x = 1 mon pid est 200 x = 2 mon pid est 200 x = 2 mon pid est 100 x = 1 mon pid est 100 x = 1 L'ordre d'affichage peut chnager selon l'orde de passage de processus ! Cela d\u00e9pends du timing, de l'algo d'ordonnacement en vigueur etc ... A coder ! \u2693\ufe0e Exercice 3 : fork() \u2693\ufe0e Dans un m\u00eame programme , un processus en active un autre et se met en attente de la fin de celui-ci, r\u00e9cup\u00e8re le mot d\u2019\u00e9tat (valeur retourn\u00e9e par exit() ) transmis et l\u2019affiche. Chacun des processus affiche son PID et celui de son p\u00e8re. Le p\u00e8re affiche en plus le PID de son fils. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid ; int status ; pid = fork (); if ( pid == 0 ) { printf ( \" FILS : mon pid est %d \\n \" , getpid ()); printf ( \" FILS : mon ppid est %d \\n \" , getppid ()); exit ( 10 ); } else { printf ( \"PERE : mon pid est %d \\n \" , getpid ()); printf ( \"PERE : mon ppid est %d \\n \" , getppid () ); printf ( \"PERE: mon fils est %d\" , pid ); wait ( & status ); printf ( \" \\n PERE status : %d\" , status >> 8 ); } return 0 ; } Exercice 4 : execv() \u2693\ufe0e Un processus (programme P) en active un autre F en lui transmettant une chaine de caract\u00e8res saisie au clavier. F calcule la longueur de la chaine et la transmet comme mot d\u2019\u00e9tat \u00e0 P . P affiche la longueur. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid ; int stat ; char message [ 100 ]; int longueur ; char * argv [ 3 ]; argv [ 0 ] = \"F\" ; argv [ 2 ] = NULL ; printf ( \"Entrez une chaine de caractere : \" ); scanf ( \"%s\" , message ); pid = fork (); argv [ 1 ] = message ; if ( pid == 0 ) { printf ( \" FILS : mon pid est %d \\n \" , getpid ()); printf ( \" FILS : mon ppid est %d \\n \" , getppid ()); execv ( \"F\" , argv ); } else { printf ( \"PERE : mon pid est %d \\n \" , getpid ()); printf ( \"PERE : mon ppid est %d \\n \" , getppid () ); printf ( \"PERE: mon fils est %d\" , pid ); wait ( & stat ); printf ( \" \\n PERE status == longueur message : %d\" , stat >> 8 ); } return 0 ; } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( int argc , char * argv []) { int cpt = 0 ; char * mess ; mess = argv [ 1 ]; while ( mess [ cpt ] != '\\0' ){ cpt ++ ; } printf ( \"FILS : La chaine fait %d \\n \" , cpt ); exit ( cpt ); }","title":""},{"location":"41_progsys_tp2_proc_corr/#programmation-systeme-tp2-processus","text":"","title":"Programmation Syst\u00e8me : TP2 - Processus"},{"location":"41_progsys_tp2_proc_corr/#sur-papier","text":"","title":"Sur Papier"},{"location":"41_progsys_tp2_proc_corr/#exercice-1-arbre-genealogique","text":"On a le code suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main () { int p1 , p2 , p3 ; p1 = p2 = p3 = -1 ; p1 = fork (); p2 = fork (); p3 = fork (); if ( p1 == 0 ) execv ( \"F1\" , NULL ); if ( p2 == 0 ) execv ( \"F2\" , NULL ); if ( p3 == 0 ) execv ( \"F3\" , NULL ); pause (); exit ( 0 ); } Combien de processus s'executent ? Sur quels programmes (P\u00e8re, F1, F2 et F3) ? Justifiez vos r\u00e9ponses en dessinant un arbre g\u00e9n\u00e9alogique.","title":"Exercice 1 : Arbre g\u00e9n\u00e9alogique"},{"location":"41_progsys_tp2_proc_corr/#exercice-2-lecture-de-code","text":"On suppose que le pid du p\u00e8re est 100 et celui du fils 200, quelles sont les valeurs affich\u00e9es par le programme ci-dessous ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid ; int x = 0 ; x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); pid = fork (); if ( pid == 0 ) { x ++ ; printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } else printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); printf ( \" mon pid est %d x = %d \\n \" , getpid (), x ); } Solution 1 2 3 4 5 mon pid est 100 x = 1 mon pid est 200 x = 2 mon pid est 200 x = 2 mon pid est 100 x = 1 mon pid est 100 x = 1 L'ordre d'affichage peut chnager selon l'orde de passage de processus ! Cela d\u00e9pends du timing, de l'algo d'ordonnacement en vigueur etc ...","title":"Exercice 2 : Lecture de code"},{"location":"41_progsys_tp2_proc_corr/#a-coder","text":"","title":"A coder !"},{"location":"41_progsys_tp2_proc_corr/#exercice-3-fork","text":"Dans un m\u00eame programme , un processus en active un autre et se met en attente de la fin de celui-ci, r\u00e9cup\u00e8re le mot d\u2019\u00e9tat (valeur retourn\u00e9e par exit() ) transmis et l\u2019affiche. Chacun des processus affiche son PID et celui de son p\u00e8re. Le p\u00e8re affiche en plus le PID de son fils. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid ; int status ; pid = fork (); if ( pid == 0 ) { printf ( \" FILS : mon pid est %d \\n \" , getpid ()); printf ( \" FILS : mon ppid est %d \\n \" , getppid ()); exit ( 10 ); } else { printf ( \"PERE : mon pid est %d \\n \" , getpid ()); printf ( \"PERE : mon ppid est %d \\n \" , getppid () ); printf ( \"PERE: mon fils est %d\" , pid ); wait ( & status ); printf ( \" \\n PERE status : %d\" , status >> 8 ); } return 0 ; }","title":"Exercice 3 : fork()"},{"location":"41_progsys_tp2_proc_corr/#exercice-4-execv","text":"Un processus (programme P) en active un autre F en lui transmettant une chaine de caract\u00e8res saisie au clavier. F calcule la longueur de la chaine et la transmet comme mot d\u2019\u00e9tat \u00e0 P . P affiche la longueur. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid ; int stat ; char message [ 100 ]; int longueur ; char * argv [ 3 ]; argv [ 0 ] = \"F\" ; argv [ 2 ] = NULL ; printf ( \"Entrez une chaine de caractere : \" ); scanf ( \"%s\" , message ); pid = fork (); argv [ 1 ] = message ; if ( pid == 0 ) { printf ( \" FILS : mon pid est %d \\n \" , getpid ()); printf ( \" FILS : mon ppid est %d \\n \" , getppid ()); execv ( \"F\" , argv ); } else { printf ( \"PERE : mon pid est %d \\n \" , getpid ()); printf ( \"PERE : mon ppid est %d \\n \" , getppid () ); printf ( \"PERE: mon fils est %d\" , pid ); wait ( & stat ); printf ( \" \\n PERE status == longueur message : %d\" , stat >> 8 ); } return 0 ; } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( int argc , char * argv []) { int cpt = 0 ; char * mess ; mess = argv [ 1 ]; while ( mess [ cpt ] != '\\0' ){ cpt ++ ; } printf ( \"FILS : La chaine fait %d \\n \" , cpt ); exit ( cpt ); }","title":"Exercice 4 : execv()"},{"location":"41_progsys_tp3_sig/","text":"Programmation Syst\u00e8me : TP3 - Signaux \u2693\ufe0e Sur Papier \u2693\ufe0e Exercice 1 \u2693\ufe0e Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void interruption ( int sig ) { printf ( \"UN \\n \" ); } int main ( void ) { signal ( SIGCHLD , interruption ); if ( fork () ) { printf ( \"DEUX \\n \" ); wait ( NULL ); } else printf ( \"TROIS \\n \" ); exit ( 0 ); } Exercice 2 \u2693\ufe0e Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <signal.h> #include <stdlib.h> #include <stdio.h> void stop ( int sig ); int main ( void ) { int pid ; pid = fork (); if ( pid == 0 ){ pause (); signal ( SIGUSR1 , stop ); printf ( \"ici le fils: j'attends un signal de mon p\u00e8re \\n ); } else { sleep ( 1 ); printf ( \"ici le pere: j'envoie un signal a mon fils \\n \" ); kill ( pid , SIGUSR1 ); sleep ( 1 ); kill ( pid , SIGKILL ); wait ( NULL ); printf ( \"ici le pere: j'ai arret\u00e9 mon fils \\n \" ); } } void stop ( int sig ) { printf ( \"ici le fils mon pere m'a tu\u00e9 \\n \" ); exit ( 0 ); } A coder ! \u2693\ufe0e Exercice 3 \u2693\ufe0e Ecrire un programme ex3 qui contr\u00f4le la frappe du caract\u00e8re \"ctrl C\". Les 5 premi\u00e8res fois: affichage de \"Vous avez tape CTRL C\" sur l'\u00e9cran, la 6\u00e8me : arr\u00eat de la t\u00e2che. Exercice 4 \u2693\ufe0e Une t\u00e2che m\u00e8re ex4 active une t\u00e2che fille (sur un seul programme). La t\u00e2che fille se met en boucle infinie. La t\u00e2che m\u00e8re lui envoie un signal, la d\u00e9bloquer et attend la fin de la fille. Tip Attention \u00e0 la position de l'appel \u00e0 signal() : par d\u00e9faut, la reception de SIGUSR1 tue le process ... Il faut donc etre sur que le cablage est fait cot\u00e9 fils avant l'appel \u00e0 kill() cot\u00e9 p\u00e8re ! Exercice 5 \u2693\ufe0e Une t\u00e2che m\u00e8re ex5 active une t\u00e2che fille ex5f (sur deux programmes).. La t\u00e2che fille se met en boucle infinie. Lorsqu'on tape sur une touche, la m\u00e8re envoie \u00e0 sa fille un signal, la d\u00e9bloque et attend la fin de celle-ci. Exercice 6 \u2693\ufe0e Ecrire un programme qui simule un r\u00e9veil en utilisant le signal SIGALRM. Exercice 7 \u2693\ufe0e R\u00e9aliser un dispositif r\u00e9veil sans l'utilisation du signal SIGALRM : La t\u00e2che m\u00e8re ex7 active une t\u00e2che fille ex7-2 et lui demande de la r\u00e9veiller au bout d'un certain temps.","title":"Programmation Syst\u00e8me - TP3 Signaux"},{"location":"41_progsys_tp3_sig/#programmation-systeme-tp3-signaux","text":"","title":"Programmation Syst\u00e8me : TP3 - Signaux"},{"location":"41_progsys_tp3_sig/#sur-papier","text":"","title":"Sur Papier"},{"location":"41_progsys_tp3_sig/#exercice-1","text":"Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void interruption ( int sig ) { printf ( \"UN \\n \" ); } int main ( void ) { signal ( SIGCHLD , interruption ); if ( fork () ) { printf ( \"DEUX \\n \" ); wait ( NULL ); } else printf ( \"TROIS \\n \" ); exit ( 0 ); }","title":"Exercice 1"},{"location":"41_progsys_tp3_sig/#exercice-2","text":"Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <signal.h> #include <stdlib.h> #include <stdio.h> void stop ( int sig ); int main ( void ) { int pid ; pid = fork (); if ( pid == 0 ){ pause (); signal ( SIGUSR1 , stop ); printf ( \"ici le fils: j'attends un signal de mon p\u00e8re \\n ); } else { sleep ( 1 ); printf ( \"ici le pere: j'envoie un signal a mon fils \\n \" ); kill ( pid , SIGUSR1 ); sleep ( 1 ); kill ( pid , SIGKILL ); wait ( NULL ); printf ( \"ici le pere: j'ai arret\u00e9 mon fils \\n \" ); } } void stop ( int sig ) { printf ( \"ici le fils mon pere m'a tu\u00e9 \\n \" ); exit ( 0 ); }","title":"Exercice 2"},{"location":"41_progsys_tp3_sig/#a-coder","text":"","title":"A coder !"},{"location":"41_progsys_tp3_sig/#exercice-3","text":"Ecrire un programme ex3 qui contr\u00f4le la frappe du caract\u00e8re \"ctrl C\". Les 5 premi\u00e8res fois: affichage de \"Vous avez tape CTRL C\" sur l'\u00e9cran, la 6\u00e8me : arr\u00eat de la t\u00e2che.","title":"Exercice 3"},{"location":"41_progsys_tp3_sig/#exercice-4","text":"Une t\u00e2che m\u00e8re ex4 active une t\u00e2che fille (sur un seul programme). La t\u00e2che fille se met en boucle infinie. La t\u00e2che m\u00e8re lui envoie un signal, la d\u00e9bloquer et attend la fin de la fille. Tip Attention \u00e0 la position de l'appel \u00e0 signal() : par d\u00e9faut, la reception de SIGUSR1 tue le process ... Il faut donc etre sur que le cablage est fait cot\u00e9 fils avant l'appel \u00e0 kill() cot\u00e9 p\u00e8re !","title":"Exercice 4"},{"location":"41_progsys_tp3_sig/#exercice-5","text":"Une t\u00e2che m\u00e8re ex5 active une t\u00e2che fille ex5f (sur deux programmes).. La t\u00e2che fille se met en boucle infinie. Lorsqu'on tape sur une touche, la m\u00e8re envoie \u00e0 sa fille un signal, la d\u00e9bloque et attend la fin de celle-ci.","title":"Exercice 5"},{"location":"41_progsys_tp3_sig/#exercice-6","text":"Ecrire un programme qui simule un r\u00e9veil en utilisant le signal SIGALRM.","title":"Exercice 6"},{"location":"41_progsys_tp3_sig/#exercice-7","text":"R\u00e9aliser un dispositif r\u00e9veil sans l'utilisation du signal SIGALRM : La t\u00e2che m\u00e8re ex7 active une t\u00e2che fille ex7-2 et lui demande de la r\u00e9veiller au bout d'un certain temps.","title":"Exercice 7"},{"location":"41_progsys_tp3_sig_corr/","text":"Programmation Syst\u00e8me : TP3 - Signaux \u2693\ufe0e Sur Papier \u2693\ufe0e Exercice 1 \u2693\ufe0e Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void interruption ( int sig ) { printf ( \"UN \\n \" ); } int main ( void ) { signal ( SIGCHLD , interruption ); if ( fork () ) { printf ( \"DEUX \\n \" ); wait ( NULL ); } else printf ( \"TROIS \\n \" ); exit ( 0 ); } Solution 1 Solution 2 Solution 3 DEUX -> TROIS -> UN TROIS -> UN -> DEUX TROIS -> DEUX -> UN Exercice 2 \u2693\ufe0e Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void stop ( int sig ); int main ( void ) { int pid ; pid = fork (); if ( pid == 0 ){ pause (); signal ( SIGUSR1 , stop ); printf ( \"ici le fils: j'attends un signal de mon p\u00e8re \\n ); } else { sleep ( 1 ); printf ( \"ici le pere: j'envoie un signal a mon fils \\n \" ); kill ( pid , SIGUSR1 ); sleep ( 1 ); kill ( pid , SIGKILL ); wait ( NULL ); printf ( \"ici le pere: j'ai arret\u00e9 mon fils \\n \" ); } } void stop ( int sig ) { printf ( \"ici le fils mon pere m'a tu\u00e9 \\n \" ); exit ( 0 ); } R\u00e9ponse : ici le pere: j'envoi un signal a mon fils ici le pere: j'ai arrete mon fils A coder ! \u2693\ufe0e Exercice 3 \u2693\ufe0e Ecrire un programme ex3 qui contr\u00f4le la frappe du caract\u00e8re \"ctrl C\". Les 5 premi\u00e8res fois: affichage de \"Vous avez tape CTRL C\" sur l'\u00e9cran, la 6\u00e8me : arr\u00eat de la t\u00e2che. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void catchCtrlC () { static int cpt = 0 ; if ( cpt ++ < 5 ) { printf ( \" \\r Vous avez tap\u00e9 CTRL C (x%d) \\n \" , cpt ); if ( cpt == 5 ) signal ( SIGINT , SIG_DFL ); // On r\u00e9tablit le comportement par d\u00e9faut du CTRL C } } int main () { printf ( \"--- DEBUT --- \\n \" ); signal ( SIGINT , catchCtrlC ); // On connecte le nouveau signal pour modifier le comportement lors d'un CTRL C for (;;); // On boucle \u00e0 l'infinie printf ( \"--- FIN --- \\n \" ); return 0 ; } Version variable globale (moins bien ...) : Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int n = 0 ; void fonc ( int sig ); int main ( void ) { signal ( SIGINT , fonc ); printf ( \"[Main] je boucle \\n \" ); while ( n < 5 ) { printf ( \"[Main] appuyer sur CTRL C \\n \" ); pause (); } return 0 ; } void fonc ( int sig ) { printf ( \"[fonc] num signal re\u00e7u =<%d> \\n \" , sig ); n ++ ; printf ( \"[fonc] appuyer sur CTRL C- <%d> \\n \" , n ); } Exercice 4 \u2693\ufe0e Une t\u00e2che m\u00e8re ex4 active une t\u00e2che fille (sur un seul programme). La t\u00e2che fille se met en boucle infinie. La t\u00e2che m\u00e8re lui envoie un signal, la d\u00e9bloquer et attend la fin de la fille. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void stop ( int sig ){ printf ( \" FILLE : Ma m\u00e8re m'arr\u00eate en m'envoyant le signal %d \\n \" , sig ); exit ( 0 ); } int main ( void ){ int pid ; pid = fork (); signal ( SIGUSR1 , stop ); if ( pid == 0 ){ for (;;){ printf ( \" FILLE BOUCLE \\n \" ); sleep ( 1 ); } } else { printf ( \" MERE : j'arr\u00eate la fille \\n \" ); kill ( pid , SIGUSR1 ); wait ( NULL ); } } Exercice 5 \u2693\ufe0e Une t\u00e2che m\u00e8re ex5 active une t\u00e2che fille ex5f (sur deux programmes).. La t\u00e2che fille se met en boucle infinie. Lorsqu'on tape sur une touche, la m\u00e8re envoie \u00e0 sa fille un signal, la d\u00e9bloque et attend la fin de celle-ci. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid , status ; char ch ; char * argv [ 2 ]; pid = fork (); if ( pid == 0 ){ argv [ 0 ] = \"exo5F\" ; argv [ 1 ] = NULL ; execv ( \"exo5F\" , argv ); } else { printf ( \"PARENT : press key to stop child \\n \" ); scanf ( \"%c\" , & ch ); kill ( pid , SIGUSR1 ); wait ( & status ); printf ( \"PARENT : Child stopped with status %d \\n \" , status >> 8 ); } } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void stop ( int sig ){ printf ( \"CHILD : Stopped by parent with signal %d \\n \" , sig ); exit ( 3 ); } int main ( void ) { signal ( SIGUSR1 , stop ); for (;;) { printf ( \"CHILD : LOOPING \\n \" ); sleep ( 1 ); } } Exercice 6 \u2693\ufe0e Ecrire un programme qui simule un r\u00e9veil en utilisant le signal SIGALRM. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void reveil ( int sig ){ printf ( \" BIP BIP BOP !!!! \\n \" ); exit ( 0 ); } int main ( void ) { int i = 0 ; int car ; printf ( \"Dans cb de temps veux-tu te lever ?\" ); scanf ( \"%d\" , & car ); alarm ( car ); signal ( SIGALRM , reveil ); for (;;){ i ++ ; printf ( \" \\r Tu dors depuis %d sec\" , i ); // \\r used for next line fflush ( stdout ); // flushing stdout allows to erase previous printf so it appears updated instead of new line ! sleep ( 1 ); } } Tip On pouvait aussi simplement utiliser la fonction pause() \u00e0 la place de la derni\u00e8re boucle si l'on ne souhaite pas l'affichage du d\u00e9compte Exercice 7 \u2693\ufe0e R\u00e9aliser un dispositif r\u00e9veil sans l'utilisation du signal SIGALRM : La t\u00e2che m\u00e8re ex7 active une t\u00e2che fille ex7-2 et lui demande de la r\u00e9veiller au bout d'un certain temps. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void reveil ( int sig ){ printf ( \" BIP BIP BOP !!!! \\n \" ); wait ( NULL ); exit ( 0 ); } int main ( void ) { int delai , pid ; char heure [ 10 ]; char * argv [ 3 ]; signal ( SIGUSR1 , reveil ); printf ( \"MERE : Entrez l'heure de reveil : \" ); scanf ( \"%d\" , & delai ); sprintf ( heure , \"%d\" , delai ); pid = fork (); if ( pid == 0 ) { argv [ 0 ] = \"exo7F\" ; argv [ 1 ] = heure ; argv [ 2 ] = NULL ; execv ( \"exo7F\" , argv ); } printf ( \"MERE : J'attends le reveil de ma fille dans %d sec \\n \" , delai ); pause (); } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( int argc , char * argv []) { int delai , i ; delai = atoi ( argv [ 1 ]); printf ( \"FILLE \\n \" ); for ( i = delai ; i > 0 ; i -- ) { printf ( \" Je reveille ma m\u00e8re dans %d \\n \" , i ); sleep ( 1 ); } kill ( getppid (), SIGUSR1 ); exit ( 0 ); }","title":""},{"location":"41_progsys_tp3_sig_corr/#programmation-systeme-tp3-signaux","text":"","title":"Programmation Syst\u00e8me : TP3 - Signaux"},{"location":"41_progsys_tp3_sig_corr/#sur-papier","text":"","title":"Sur Papier"},{"location":"41_progsys_tp3_sig_corr/#exercice-1","text":"Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void interruption ( int sig ) { printf ( \"UN \\n \" ); } int main ( void ) { signal ( SIGCHLD , interruption ); if ( fork () ) { printf ( \"DEUX \\n \" ); wait ( NULL ); } else printf ( \"TROIS \\n \" ); exit ( 0 ); } Solution 1 Solution 2 Solution 3 DEUX -> TROIS -> UN TROIS -> UN -> DEUX TROIS -> DEUX -> UN","title":"Exercice 1"},{"location":"41_progsys_tp3_sig_corr/#exercice-2","text":"Donner les diff\u00e9rents affichages possibles pouvant se produire avec le programme suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void stop ( int sig ); int main ( void ) { int pid ; pid = fork (); if ( pid == 0 ){ pause (); signal ( SIGUSR1 , stop ); printf ( \"ici le fils: j'attends un signal de mon p\u00e8re \\n ); } else { sleep ( 1 ); printf ( \"ici le pere: j'envoie un signal a mon fils \\n \" ); kill ( pid , SIGUSR1 ); sleep ( 1 ); kill ( pid , SIGKILL ); wait ( NULL ); printf ( \"ici le pere: j'ai arret\u00e9 mon fils \\n \" ); } } void stop ( int sig ) { printf ( \"ici le fils mon pere m'a tu\u00e9 \\n \" ); exit ( 0 ); } R\u00e9ponse : ici le pere: j'envoi un signal a mon fils ici le pere: j'ai arrete mon fils","title":"Exercice 2"},{"location":"41_progsys_tp3_sig_corr/#a-coder","text":"","title":"A coder !"},{"location":"41_progsys_tp3_sig_corr/#exercice-3","text":"Ecrire un programme ex3 qui contr\u00f4le la frappe du caract\u00e8re \"ctrl C\". Les 5 premi\u00e8res fois: affichage de \"Vous avez tape CTRL C\" sur l'\u00e9cran, la 6\u00e8me : arr\u00eat de la t\u00e2che. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void catchCtrlC () { static int cpt = 0 ; if ( cpt ++ < 5 ) { printf ( \" \\r Vous avez tap\u00e9 CTRL C (x%d) \\n \" , cpt ); if ( cpt == 5 ) signal ( SIGINT , SIG_DFL ); // On r\u00e9tablit le comportement par d\u00e9faut du CTRL C } } int main () { printf ( \"--- DEBUT --- \\n \" ); signal ( SIGINT , catchCtrlC ); // On connecte le nouveau signal pour modifier le comportement lors d'un CTRL C for (;;); // On boucle \u00e0 l'infinie printf ( \"--- FIN --- \\n \" ); return 0 ; } Version variable globale (moins bien ...) : Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int n = 0 ; void fonc ( int sig ); int main ( void ) { signal ( SIGINT , fonc ); printf ( \"[Main] je boucle \\n \" ); while ( n < 5 ) { printf ( \"[Main] appuyer sur CTRL C \\n \" ); pause (); } return 0 ; } void fonc ( int sig ) { printf ( \"[fonc] num signal re\u00e7u =<%d> \\n \" , sig ); n ++ ; printf ( \"[fonc] appuyer sur CTRL C- <%d> \\n \" , n ); }","title":"Exercice 3"},{"location":"41_progsys_tp3_sig_corr/#exercice-4","text":"Une t\u00e2che m\u00e8re ex4 active une t\u00e2che fille (sur un seul programme). La t\u00e2che fille se met en boucle infinie. La t\u00e2che m\u00e8re lui envoie un signal, la d\u00e9bloquer et attend la fin de la fille. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void stop ( int sig ){ printf ( \" FILLE : Ma m\u00e8re m'arr\u00eate en m'envoyant le signal %d \\n \" , sig ); exit ( 0 ); } int main ( void ){ int pid ; pid = fork (); signal ( SIGUSR1 , stop ); if ( pid == 0 ){ for (;;){ printf ( \" FILLE BOUCLE \\n \" ); sleep ( 1 ); } } else { printf ( \" MERE : j'arr\u00eate la fille \\n \" ); kill ( pid , SIGUSR1 ); wait ( NULL ); } }","title":"Exercice 4"},{"location":"41_progsys_tp3_sig_corr/#exercice-5","text":"Une t\u00e2che m\u00e8re ex5 active une t\u00e2che fille ex5f (sur deux programmes).. La t\u00e2che fille se met en boucle infinie. Lorsqu'on tape sur une touche, la m\u00e8re envoie \u00e0 sa fille un signal, la d\u00e9bloque et attend la fin de celle-ci. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int pid , status ; char ch ; char * argv [ 2 ]; pid = fork (); if ( pid == 0 ){ argv [ 0 ] = \"exo5F\" ; argv [ 1 ] = NULL ; execv ( \"exo5F\" , argv ); } else { printf ( \"PARENT : press key to stop child \\n \" ); scanf ( \"%c\" , & ch ); kill ( pid , SIGUSR1 ); wait ( & status ); printf ( \"PARENT : Child stopped with status %d \\n \" , status >> 8 ); } } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void stop ( int sig ){ printf ( \"CHILD : Stopped by parent with signal %d \\n \" , sig ); exit ( 3 ); } int main ( void ) { signal ( SIGUSR1 , stop ); for (;;) { printf ( \"CHILD : LOOPING \\n \" ); sleep ( 1 ); } }","title":"Exercice 5"},{"location":"41_progsys_tp3_sig_corr/#exercice-6","text":"Ecrire un programme qui simule un r\u00e9veil en utilisant le signal SIGALRM. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void reveil ( int sig ){ printf ( \" BIP BIP BOP !!!! \\n \" ); exit ( 0 ); } int main ( void ) { int i = 0 ; int car ; printf ( \"Dans cb de temps veux-tu te lever ?\" ); scanf ( \"%d\" , & car ); alarm ( car ); signal ( SIGALRM , reveil ); for (;;){ i ++ ; printf ( \" \\r Tu dors depuis %d sec\" , i ); // \\r used for next line fflush ( stdout ); // flushing stdout allows to erase previous printf so it appears updated instead of new line ! sleep ( 1 ); } } Tip On pouvait aussi simplement utiliser la fonction pause() \u00e0 la place de la derni\u00e8re boucle si l'on ne souhaite pas l'affichage du d\u00e9compte","title":"Exercice 6"},{"location":"41_progsys_tp3_sig_corr/#exercice-7","text":"R\u00e9aliser un dispositif r\u00e9veil sans l'utilisation du signal SIGALRM : La t\u00e2che m\u00e8re ex7 active une t\u00e2che fille ex7-2 et lui demande de la r\u00e9veiller au bout d'un certain temps. Solution P\u00e8re : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> void reveil ( int sig ){ printf ( \" BIP BIP BOP !!!! \\n \" ); wait ( NULL ); exit ( 0 ); } int main ( void ) { int delai , pid ; char heure [ 10 ]; char * argv [ 3 ]; signal ( SIGUSR1 , reveil ); printf ( \"MERE : Entrez l'heure de reveil : \" ); scanf ( \"%d\" , & delai ); sprintf ( heure , \"%d\" , delai ); pid = fork (); if ( pid == 0 ) { argv [ 0 ] = \"exo7F\" ; argv [ 1 ] = heure ; argv [ 2 ] = NULL ; execv ( \"exo7F\" , argv ); } printf ( \"MERE : J'attends le reveil de ma fille dans %d sec \\n \" , delai ); pause (); } Fils : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( int argc , char * argv []) { int delai , i ; delai = atoi ( argv [ 1 ]); printf ( \"FILLE \\n \" ); for ( i = delai ; i > 0 ; i -- ) { printf ( \" Je reveille ma m\u00e8re dans %d \\n \" , i ); sleep ( 1 ); } kill ( getppid (), SIGUSR1 ); exit ( 0 ); }","title":"Exercice 7"},{"location":"41_progsys_tp4_fic/","text":"Programmation Syst\u00e8me : TP4 - E/S Bas Niveau \u2693\ufe0e Exercice 1 : Chaine vs. Int \u2693\ufe0e \u00c9crire un programme en C qui : Ouvre (cr\u00e9er si n\u2019existe pas) un fichier \u00ab test \u00bb , en lecture et \u00e9criture. Affiche son descripteur de fichier Y \u00e9crit une chaine de caract\u00e8res ainsi qu\u2019un entier Affiche la position du curseur de fichier Le replace au d\u00e9but du fichier Relis le fichier Ferme les descripteur proprement et se termine.","title":"Programmation Syst\u00e8me - TP4 E/S Bas Niveau"},{"location":"41_progsys_tp4_fic/#programmation-systeme-tp4-es-bas-niveau","text":"","title":"Programmation Syst\u00e8me : TP4 - E/S Bas Niveau"},{"location":"41_progsys_tp4_fic/#exercice-1-chaine-vs-int","text":"\u00c9crire un programme en C qui : Ouvre (cr\u00e9er si n\u2019existe pas) un fichier \u00ab test \u00bb , en lecture et \u00e9criture. Affiche son descripteur de fichier Y \u00e9crit une chaine de caract\u00e8res ainsi qu\u2019un entier Affiche la position du curseur de fichier Le replace au d\u00e9but du fichier Relis le fichier Ferme les descripteur proprement et se termine.","title":"Exercice 1 : Chaine vs. Int"},{"location":"41_progsys_tp4_fic_corr/","text":"Programmation Syst\u00e8me : TP4 - E/S Bas Niveau \u2693\ufe0e Exercice 1 : Chaine vs. Int \u2693\ufe0e \u00c9crire un programme en C qui : Ouvre (cr\u00e9er si n\u2019existe pas) un fichier \u00ab test \u00bb , en lecture et \u00e9criture. Affiche son descripteur de fichier Y \u00e9crit une chaine de caract\u00e8res ainsi qu\u2019un entier Affiche la position du curseur de fichier Le replace au d\u00e9but du fichier Relis le fichier Ferme les descripteur proprement et se termine. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int desc = open ( \"test\" , O_RDWR | O_CREAT , 0750 ); printf ( \"Le desc de fichier vaut : %d \\n \" , desc ); char c [ 6 ] = \"chaine\" ; int x = 97 ; write ( desc , c , sizeof ( c )); write ( desc , & x , sizeof ( x )); int pos = lseek ( desc , 0 , SEEK_CUR ); printf ( \"Position courante du curseur : %d \\n \" , pos ); pos = lseek ( desc , 0 , SEEK_SET ); printf ( \"Nouvelle position courante du curseur : %d \\n \" , pos ); char cl [ 6 ]; int nb , xl ; nb = read ( desc , cl , 6 ); printf ( \" C : '%s' avec nb octets lus : %d \\n \" , cl , nb ); nb = read ( desc , & xl , sizeof ( int )); printf ( \" X : '%d' avec nb octets lus : %d \\n \" , xl , nb ); printf ( \"Taille d'un INT : %lu \\n \" , sizeof ( int )); close ( desc ); return 0 ; } !!! tip La valeur 97 correspond \u00e0 la lettre a dans la table ASCII, d'o\u00f9 le fait qu'il apparait dans vi , qui arrive \u00e0 d\u00e9coder le premier octet de l'int comme un caract\u00e8re !","title":""},{"location":"41_progsys_tp4_fic_corr/#programmation-systeme-tp4-es-bas-niveau","text":"","title":"Programmation Syst\u00e8me : TP4 - E/S Bas Niveau"},{"location":"41_progsys_tp4_fic_corr/#exercice-1-chaine-vs-int","text":"\u00c9crire un programme en C qui : Ouvre (cr\u00e9er si n\u2019existe pas) un fichier \u00ab test \u00bb , en lecture et \u00e9criture. Affiche son descripteur de fichier Y \u00e9crit une chaine de caract\u00e8res ainsi qu\u2019un entier Affiche la position du curseur de fichier Le replace au d\u00e9but du fichier Relis le fichier Ferme les descripteur proprement et se termine. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { int desc = open ( \"test\" , O_RDWR | O_CREAT , 0750 ); printf ( \"Le desc de fichier vaut : %d \\n \" , desc ); char c [ 6 ] = \"chaine\" ; int x = 97 ; write ( desc , c , sizeof ( c )); write ( desc , & x , sizeof ( x )); int pos = lseek ( desc , 0 , SEEK_CUR ); printf ( \"Position courante du curseur : %d \\n \" , pos ); pos = lseek ( desc , 0 , SEEK_SET ); printf ( \"Nouvelle position courante du curseur : %d \\n \" , pos ); char cl [ 6 ]; int nb , xl ; nb = read ( desc , cl , 6 ); printf ( \" C : '%s' avec nb octets lus : %d \\n \" , cl , nb ); nb = read ( desc , & xl , sizeof ( int )); printf ( \" X : '%d' avec nb octets lus : %d \\n \" , xl , nb ); printf ( \"Taille d'un INT : %lu \\n \" , sizeof ( int )); close ( desc ); return 0 ; } !!! tip La valeur 97 correspond \u00e0 la lettre a dans la table ASCII, d'o\u00f9 le fait qu'il apparait dans vi , qui arrive \u00e0 d\u00e9coder le premier octet de l'int comme un caract\u00e8re !","title":"Exercice 1 : Chaine vs. Int"},{"location":"41_progsys_tp5_pipes/","text":"Programmation Syst\u00e8me : TP5 - Pipes \u2693\ufe0e Exercice 1 : Pipe anonyme \u2693\ufe0e Ecrire un programme qui permet \u00e0 deux taches (sur un seul programme) de communiquer entre elles en utilisant un pipe non nomm\u00e9 : On saisi un message au clavier dans la tache fille, qui l\u2019envoie, caract\u00e8re par caract\u00e8re, \u00e0 la m\u00e8re qui l\u2019affiche (la m\u00e8re affiche tout d'un coup). Warn La fonction getchar() met en buffer les char un a un en attendant l'appuye sur ENTRER. Elle ne commence \u00e0 d\u00e9piler le buffer char par char qu'\u00e0 ce moment la ... Exercice 2 : Pipe Nomm\u00e9 \u2693\ufe0e Ecrire un syst\u00e8me de deux taches sur deux programmes diff\u00e9rents tel que : pere2 : active fils2 lit un fichier dont le nom (chemin) est transmit comme param\u00e8tre au programme \u00e9crit le contenu du fichier dans le pipe nomm\u00e9 \u00ab pipe \u00bb fils2 : lit dans le pipe \u00e9crit ce qu\u2019il lit \u00e0 l\u2019\u00e9cran. Exercice 3 : Ecriture et lecture de nombres dans un pipe nomm\u00e9 \u2693\ufe0e Ecrire un syst\u00e8me de deux taches sur deux programmes diff\u00e9rents tel que : pere3 : active fils3 \u00e9crit un nombre entier dans le pipe nomm\u00e9 \u00ab pipe2 \u00bb fils3 : lit dans le pipe \u00e9crit ce qu\u2019il lit \u00e0 l\u2019\u00e9cran. Exercice 4 : Calculette efficace ! \u2693\ufe0e Cr\u00e9er, dans un m\u00eame programme, un m\u00e9canisme pour r\u00e9aliser une calculette sur des r\u00e9els o\u00f9 la saisie de l'op\u00e9ration est faite par une t\u00e2che, et le calcul par une autre t\u00e2che, celle-ci communiquant le r\u00e9sultat \u00e0 la premi\u00e8re qui l'affiche. De plus une session de la calculette ne doit pas se limiter \u00e0 une op\u00e9ration mais \u00e0 autant que le d\u00e9sire l'op\u00e9rateur (chaque op\u00e9ration est g\u00e9r\u00e9e par un programme diff\u00e9rent).","title":"Programmation Syst\u00e8me - TP5 Pipes"},{"location":"41_progsys_tp5_pipes/#programmation-systeme-tp5-pipes","text":"","title":"Programmation Syst\u00e8me : TP5 - Pipes"},{"location":"41_progsys_tp5_pipes/#exercice-1-pipe-anonyme","text":"Ecrire un programme qui permet \u00e0 deux taches (sur un seul programme) de communiquer entre elles en utilisant un pipe non nomm\u00e9 : On saisi un message au clavier dans la tache fille, qui l\u2019envoie, caract\u00e8re par caract\u00e8re, \u00e0 la m\u00e8re qui l\u2019affiche (la m\u00e8re affiche tout d'un coup). Warn La fonction getchar() met en buffer les char un a un en attendant l'appuye sur ENTRER. Elle ne commence \u00e0 d\u00e9piler le buffer char par char qu'\u00e0 ce moment la ...","title":"Exercice 1 : Pipe anonyme"},{"location":"41_progsys_tp5_pipes/#exercice-2-pipe-nomme","text":"Ecrire un syst\u00e8me de deux taches sur deux programmes diff\u00e9rents tel que : pere2 : active fils2 lit un fichier dont le nom (chemin) est transmit comme param\u00e8tre au programme \u00e9crit le contenu du fichier dans le pipe nomm\u00e9 \u00ab pipe \u00bb fils2 : lit dans le pipe \u00e9crit ce qu\u2019il lit \u00e0 l\u2019\u00e9cran.","title":"Exercice 2 : Pipe Nomm\u00e9"},{"location":"41_progsys_tp5_pipes/#exercice-3-ecriture-et-lecture-de-nombres-dans-un-pipe-nomme","text":"Ecrire un syst\u00e8me de deux taches sur deux programmes diff\u00e9rents tel que : pere3 : active fils3 \u00e9crit un nombre entier dans le pipe nomm\u00e9 \u00ab pipe2 \u00bb fils3 : lit dans le pipe \u00e9crit ce qu\u2019il lit \u00e0 l\u2019\u00e9cran.","title":"Exercice 3 : Ecriture et lecture de nombres dans un pipe nomm\u00e9"},{"location":"41_progsys_tp5_pipes/#exercice-4-calculette-efficace","text":"Cr\u00e9er, dans un m\u00eame programme, un m\u00e9canisme pour r\u00e9aliser une calculette sur des r\u00e9els o\u00f9 la saisie de l'op\u00e9ration est faite par une t\u00e2che, et le calcul par une autre t\u00e2che, celle-ci communiquant le r\u00e9sultat \u00e0 la premi\u00e8re qui l'affiche. De plus une session de la calculette ne doit pas se limiter \u00e0 une op\u00e9ration mais \u00e0 autant que le d\u00e9sire l'op\u00e9rateur (chaque op\u00e9ration est g\u00e9r\u00e9e par un programme diff\u00e9rent).","title":"Exercice 4 : Calculette efficace !"},{"location":"41_progsys_tp5_pipes_corr/","text":"Programmation Syst\u00e8me : TP5 - Pipes \u2693\ufe0e Programmation Syst\u00e8me : TP5 - Pipes \u2693\ufe0e Exercice 1 : Pipe anonyme \u2693\ufe0e Ecrire un programme qui permet \u00e0 deux taches (sur un seul programme) de communiquer entre elles en utilisant un pipe non nomm\u00e9 : On saisi un message au clavier dans la tache fille, qui l\u2019envoie, caract\u00e8re par caract\u00e8re, \u00e0 la m\u00e8re qui l\u2019affiche (la m\u00e8re affiche tout d'un coup). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { char bufmere [ 80 ]; char buffille [ 80 ]; int p [ 2 ]; int pid , nb_car , i ; pipe ( p ); pid = fork (); if ( pid == 0 ) { close ( p [ 0 ]); printf ( \"ici la fille... que voulez vous ecrire a ma mere? \\n \" ); while ( buffille [ 0 ] != '\\n' ) { buffille [ 0 ] = getchar (); write ( p [ 1 ], & buffille [ 0 ], sizeof ( char )); } } else { close ( p [ 1 ]); i = read ( p [ 0 ], bufmere , 80 ) ; bufmere [ i ] = '\\n' ; printf ( \"ici la mere...je recois ce message de ma fille: \\n \" ) ; printf ( \"%s\" , bufmere ) ; } } Exercice 2 : Pipe Nomm\u00e9 \u2693\ufe0e Ecrire un syst\u00e8me de deux taches sur deux programmes diff\u00e9rents tel que : pere2 : active fils2 lit un fichier dont le nom (chemin) est transmit comme param\u00e8tre au programme \u00e9crit le contenu du fichier dans le pipe nomm\u00e9 \u00ab pipe \u00bb fils2 : lit dans le pipe \u00e9crit ce qu\u2019il lit \u00e0 l\u2019\u00e9cran. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <stdio.h> #include <sys/stat.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> #include <errno.h> #include <string.h> int main ( int argc , char * argv []) { char fic [ 512 ], buf [ 512 ]; int dp , df , nb_char , pid ; printf ( \" \\n ici le processus producteur.... \\n \" ); pid = fork (); if ( pid == 0 ) execv ( \"exo2F\" , NULL ); mkfifo ( \"pipe\" , 0750 ); dp = open ( \"pipe\" , O_WRONLY ) ; if ( dp == -1 ) printf ( \"probleme d ouverture du pipe en ecriture par la mere\" ) ; df = open ( argv [ 1 ], O_RDONLY ) ; if ( df == -1 ) printf ( \"probleme d ouverture du fichier en lecture par la mere \" ); printf ( \"READ FILE \\n \" ); nb_char = -1 ; while ( nb_char != 0 ){ nb_char = read ( df , fic , 80 ); printf ( \"PERE : je lis %d char \\n \" , nb_char ); printf ( \"jai lu : %s\" , fic ); write ( dp , fic , nb_char ); } close ( df ); close ( dp ); wait ( NULL ); exit ( 0 ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include <stdio.h> #include <sys/stat.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> #include <errno.h> #include <string.h> void erreur ( char * mes ); int main ( void ) { char buf [ 80 ] ; int dp , nb_char ; printf ( \" \\n ici le processus consommateur... \\n \" ) ; dp = open ( \"pipe\" , O_RDONLY ) ; nb_char = read ( dp , buf , 80 ) ; buf [ nb_char ] = '\\0' ; printf ( \"lu %d \\n \" , nb_char ); if ( nb_char == -1 ) erreur ( \"erreur de lecture dans le pipe par la fille\" ); while ( nb_char != 0 ) { printf ( \"1 Fils reste %d \\n \" , nb_char ); printf ( \"%s \\n \" , buf ); write ( 1 , buf , nb_char ); nb_char = read ( dp , buf , 80 ); buf [ nb_char ] = '\\0' ; printf ( \"2 Fils reste %d \\n \" , nb_char ); if ( nb_char == -1 ) erreur ( \"erreur de lecture dans le pipe par la fille\" ); } printf ( \"FIN FILS \\n \" ); close ( dp ) ; exit ( 0 ) ; } void erreur ( char * mes ) { printf ( \" \\n Erreur %s \\n \" , mes ) ; exit ( 0 ); } Exercice 3 : Ecriture et lecture de nombres dans un pipe nomm\u00e9 \u2693\ufe0e Ecrire un syst\u00e8me de deux taches sur deux programmes diff\u00e9rents tel que : pere3 : active fils3 \u00e9crit un nombre entier dans le pipe nomm\u00e9 \u00ab pipe2 \u00bb fils3 : lit dans le pipe \u00e9crit ce qu\u2019il lit \u00e0 l\u2019\u00e9cran. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <stdio.h> #include <fcntl.h> int main ( int argc , char * argv []){ int p1 = 0 ; int tmp = 25310 ; int dp , f ; char buf ; unlink ( \"pipe\" ); mkfifo ( \"pipe\" , 0666 ); p1 = fork (); if ( p1 != 0 ){ dp = open ( \"pipe\" , O_WRONLY ); write ( dp , & tmp , sizeof ( int )); close ( dp ); } else { execv ( \"ex3_1\" , NULL ); } return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdio.h> #include <fcntl.h> int main ( void ){ int des ; int buf ; des = open ( \"pipe\" , O_RDONLY ); read ( des , & buf , sizeof ( int )); printf ( \"%d\" , buf ); close ( des ); return 0 ; } Exercice 4 : Calculette efficace ! \u2693\ufe0e Cr\u00e9er, dans un m\u00eame programme, un m\u00e9canisme pour r\u00e9aliser une calculette sur des r\u00e9els o\u00f9 la saisie de l'op\u00e9ration est faite par une t\u00e2che, et le calcul par une autre t\u00e2che, celle-ci communiquant le r\u00e9sultat \u00e0 la premi\u00e8re qui l'affiche. De plus une session de la calculette ne doit pas se limiter \u00e0 une op\u00e9ration mais \u00e0 autant que le d\u00e9sire l'op\u00e9rateur. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include <stdio.h> #include <fcntl.h> #include <unistd.h> int main ( int argc , char * argv []){ int p1 = 0 ; int dp , des , dp1 , des1 ; char buf ; float op1 = 0 , op2 = 0 , res = 0 ; char opt ; int c ; unlink ( \"pipe\" ); mkfifo ( \"pipe\" , 0666 ); unlink ( \"pipe1\" ); mkfifo ( \"pipe1\" , 0666 ); p1 = fork (); if ( p1 != 0 ){ //pere dp = open ( \"pipe\" , O_WRONLY ); dp1 = open ( \"pipe1\" , O_RDONLY ); while ( 1 ){ printf ( \" \\n\\n Entrer le nouveau calcul : \" ); scanf ( \"%f\" , & op1 ); while (( c = getchar ()) != '\\n' && c != '\\n' ); //fseek(stdin, 0, SEEK_END); scanf ( \"%c\" , & opt ); while (( c = getchar ()) != '\\n' && c != '\\n' ); scanf ( \"%f\" , & op2 ); while (( c = getchar ()) != '\\n' && c != '\\n' ); write ( dp , & op1 , sizeof ( float )); write ( dp , & opt , sizeof ( char )); write ( dp , & op2 , sizeof ( float )); while ( ! read ( dp1 , & res , sizeof ( float ))); printf ( \" \\n %.2f %c %.2f = %.2f \\n \" , op1 , opt , op2 , res ); } close ( dp ); close ( dp1 ); } else { //fils des = open ( \"pipe\" , O_RDONLY ); des1 = open ( \"pipe1\" , O_WRONLY ); while ( 1 ){ while ( ! read ( des , & op1 , sizeof ( float ))); while ( ! read ( des , & opt , sizeof ( char ))); while ( ! read ( des , & op2 , sizeof ( float ))); if ( opt == '+' ){ res = op1 + op2 ; } else if ( opt == '-' ){ res = op1 - op2 ; } else if ( opt == '*' ){ res = op1 * op2 ; } else if ( opt == '/' ){ res = op1 / op2 ; } write ( des1 , & res , sizeof ( float )); } close ( des ); close ( des1 ); } return 0 ; }","title":""},{"location":"41_progsys_tp5_pipes_corr/#programmation-systeme-tp5-pipes","text":"","title":"Programmation Syst\u00e8me : TP5 - Pipes"},{"location":"41_progsys_tp5_pipes_corr/#programmation-systeme-tp5-pipes_1","text":"","title":"Programmation Syst\u00e8me : TP5 - Pipes"},{"location":"41_progsys_tp5_pipes_corr/#exercice-1-pipe-anonyme","text":"Ecrire un programme qui permet \u00e0 deux taches (sur un seul programme) de communiquer entre elles en utilisant un pipe non nomm\u00e9 : On saisi un message au clavier dans la tache fille, qui l\u2019envoie, caract\u00e8re par caract\u00e8re, \u00e0 la m\u00e8re qui l\u2019affiche (la m\u00e8re affiche tout d'un coup). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <stdio.h> #include <sys/types.h> #include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> int main ( void ) { char bufmere [ 80 ]; char buffille [ 80 ]; int p [ 2 ]; int pid , nb_car , i ; pipe ( p ); pid = fork (); if ( pid == 0 ) { close ( p [ 0 ]); printf ( \"ici la fille... que voulez vous ecrire a ma mere? \\n \" ); while ( buffille [ 0 ] != '\\n' ) { buffille [ 0 ] = getchar (); write ( p [ 1 ], & buffille [ 0 ], sizeof ( char )); } } else { close ( p [ 1 ]); i = read ( p [ 0 ], bufmere , 80 ) ; bufmere [ i ] = '\\n' ; printf ( \"ici la mere...je recois ce message de ma fille: \\n \" ) ; printf ( \"%s\" , bufmere ) ; } }","title":"Exercice 1 : Pipe anonyme"},{"location":"41_progsys_tp5_pipes_corr/#exercice-2-pipe-nomme","text":"Ecrire un syst\u00e8me de deux taches sur deux programmes diff\u00e9rents tel que : pere2 : active fils2 lit un fichier dont le nom (chemin) est transmit comme param\u00e8tre au programme \u00e9crit le contenu du fichier dans le pipe nomm\u00e9 \u00ab pipe \u00bb fils2 : lit dans le pipe \u00e9crit ce qu\u2019il lit \u00e0 l\u2019\u00e9cran. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <stdio.h> #include <sys/stat.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> #include <errno.h> #include <string.h> int main ( int argc , char * argv []) { char fic [ 512 ], buf [ 512 ]; int dp , df , nb_char , pid ; printf ( \" \\n ici le processus producteur.... \\n \" ); pid = fork (); if ( pid == 0 ) execv ( \"exo2F\" , NULL ); mkfifo ( \"pipe\" , 0750 ); dp = open ( \"pipe\" , O_WRONLY ) ; if ( dp == -1 ) printf ( \"probleme d ouverture du pipe en ecriture par la mere\" ) ; df = open ( argv [ 1 ], O_RDONLY ) ; if ( df == -1 ) printf ( \"probleme d ouverture du fichier en lecture par la mere \" ); printf ( \"READ FILE \\n \" ); nb_char = -1 ; while ( nb_char != 0 ){ nb_char = read ( df , fic , 80 ); printf ( \"PERE : je lis %d char \\n \" , nb_char ); printf ( \"jai lu : %s\" , fic ); write ( dp , fic , nb_char ); } close ( df ); close ( dp ); wait ( NULL ); exit ( 0 ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include <stdio.h> #include <sys/stat.h> #include <sys/types.h> //#include <sys/wait.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <fcntl.h> #include <errno.h> #include <string.h> void erreur ( char * mes ); int main ( void ) { char buf [ 80 ] ; int dp , nb_char ; printf ( \" \\n ici le processus consommateur... \\n \" ) ; dp = open ( \"pipe\" , O_RDONLY ) ; nb_char = read ( dp , buf , 80 ) ; buf [ nb_char ] = '\\0' ; printf ( \"lu %d \\n \" , nb_char ); if ( nb_char == -1 ) erreur ( \"erreur de lecture dans le pipe par la fille\" ); while ( nb_char != 0 ) { printf ( \"1 Fils reste %d \\n \" , nb_char ); printf ( \"%s \\n \" , buf ); write ( 1 , buf , nb_char ); nb_char = read ( dp , buf , 80 ); buf [ nb_char ] = '\\0' ; printf ( \"2 Fils reste %d \\n \" , nb_char ); if ( nb_char == -1 ) erreur ( \"erreur de lecture dans le pipe par la fille\" ); } printf ( \"FIN FILS \\n \" ); close ( dp ) ; exit ( 0 ) ; } void erreur ( char * mes ) { printf ( \" \\n Erreur %s \\n \" , mes ) ; exit ( 0 ); }","title":"Exercice 2 : Pipe Nomm\u00e9"},{"location":"41_progsys_tp5_pipes_corr/#exercice-3-ecriture-et-lecture-de-nombres-dans-un-pipe-nomme","text":"Ecrire un syst\u00e8me de deux taches sur deux programmes diff\u00e9rents tel que : pere3 : active fils3 \u00e9crit un nombre entier dans le pipe nomm\u00e9 \u00ab pipe2 \u00bb fils3 : lit dans le pipe \u00e9crit ce qu\u2019il lit \u00e0 l\u2019\u00e9cran. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <stdio.h> #include <fcntl.h> int main ( int argc , char * argv []){ int p1 = 0 ; int tmp = 25310 ; int dp , f ; char buf ; unlink ( \"pipe\" ); mkfifo ( \"pipe\" , 0666 ); p1 = fork (); if ( p1 != 0 ){ dp = open ( \"pipe\" , O_WRONLY ); write ( dp , & tmp , sizeof ( int )); close ( dp ); } else { execv ( \"ex3_1\" , NULL ); } return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdio.h> #include <fcntl.h> int main ( void ){ int des ; int buf ; des = open ( \"pipe\" , O_RDONLY ); read ( des , & buf , sizeof ( int )); printf ( \"%d\" , buf ); close ( des ); return 0 ; }","title":"Exercice 3 : Ecriture et lecture de nombres dans un pipe nomm\u00e9"},{"location":"41_progsys_tp5_pipes_corr/#exercice-4-calculette-efficace","text":"Cr\u00e9er, dans un m\u00eame programme, un m\u00e9canisme pour r\u00e9aliser une calculette sur des r\u00e9els o\u00f9 la saisie de l'op\u00e9ration est faite par une t\u00e2che, et le calcul par une autre t\u00e2che, celle-ci communiquant le r\u00e9sultat \u00e0 la premi\u00e8re qui l'affiche. De plus une session de la calculette ne doit pas se limiter \u00e0 une op\u00e9ration mais \u00e0 autant que le d\u00e9sire l'op\u00e9rateur. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include <stdio.h> #include <fcntl.h> #include <unistd.h> int main ( int argc , char * argv []){ int p1 = 0 ; int dp , des , dp1 , des1 ; char buf ; float op1 = 0 , op2 = 0 , res = 0 ; char opt ; int c ; unlink ( \"pipe\" ); mkfifo ( \"pipe\" , 0666 ); unlink ( \"pipe1\" ); mkfifo ( \"pipe1\" , 0666 ); p1 = fork (); if ( p1 != 0 ){ //pere dp = open ( \"pipe\" , O_WRONLY ); dp1 = open ( \"pipe1\" , O_RDONLY ); while ( 1 ){ printf ( \" \\n\\n Entrer le nouveau calcul : \" ); scanf ( \"%f\" , & op1 ); while (( c = getchar ()) != '\\n' && c != '\\n' ); //fseek(stdin, 0, SEEK_END); scanf ( \"%c\" , & opt ); while (( c = getchar ()) != '\\n' && c != '\\n' ); scanf ( \"%f\" , & op2 ); while (( c = getchar ()) != '\\n' && c != '\\n' ); write ( dp , & op1 , sizeof ( float )); write ( dp , & opt , sizeof ( char )); write ( dp , & op2 , sizeof ( float )); while ( ! read ( dp1 , & res , sizeof ( float ))); printf ( \" \\n %.2f %c %.2f = %.2f \\n \" , op1 , opt , op2 , res ); } close ( dp ); close ( dp1 ); } else { //fils des = open ( \"pipe\" , O_RDONLY ); des1 = open ( \"pipe1\" , O_WRONLY ); while ( 1 ){ while ( ! read ( des , & op1 , sizeof ( float ))); while ( ! read ( des , & opt , sizeof ( char ))); while ( ! read ( des , & op2 , sizeof ( float ))); if ( opt == '+' ){ res = op1 + op2 ; } else if ( opt == '-' ){ res = op1 - op2 ; } else if ( opt == '*' ){ res = op1 * op2 ; } else if ( opt == '/' ){ res = op1 / op2 ; } write ( des1 , & res , sizeof ( float )); } close ( des ); close ( des1 ); } return 0 ; }","title":"Exercice 4 : Calculette efficace !"}]}